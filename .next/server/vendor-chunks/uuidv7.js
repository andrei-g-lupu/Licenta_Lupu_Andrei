"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/uuidv7";
exports.ids = ["vendor-chunks/uuidv7"];
exports.modules = {

/***/ "(rsc)/./node_modules/uuidv7/dist/index.cjs":
/*!********************************************!*\
  !*** ./node_modules/uuidv7/dist/index.cjs ***!
  \********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * uuidv7: An experimental implementation of the proposed UUID Version 7\n *\n * @license Apache-2.0\n * @copyright 2021-2023 LiosK\n * @packageDocumentation\n */ Object.defineProperty(exports, \"__esModule\", ({\n    value: true\n}));\nexports.uuidv4obj = exports.uuidv4 = exports.uuidv7obj = exports.uuidv7 = exports.V7Generator = exports.UUID = void 0;\nconst DIGITS = \"0123456789abcdef\";\n/** Represents a UUID as a 16-byte byte array. */ class UUID {\n    /** @param bytes - The 16-byte byte array representation. */ constructor(bytes){\n        this.bytes = bytes;\n    }\n    /**\n     * Creates an object from the internal representation, a 16-byte byte array\n     * containing the binary UUID representation in the big-endian byte order.\n     *\n     * This method does NOT shallow-copy the argument, and thus the created object\n     * holds the reference to the underlying buffer.\n     *\n     * @throws TypeError if the length of the argument is not 16.\n     */ static ofInner(bytes) {\n        if (bytes.length !== 16) {\n            throw new TypeError(\"not 128-bit length\");\n        } else {\n            return new UUID(bytes);\n        }\n    }\n    /**\n     * Builds a byte array from UUIDv7 field values.\n     *\n     * @param unixTsMs - A 48-bit `unix_ts_ms` field value.\n     * @param randA - A 12-bit `rand_a` field value.\n     * @param randBHi - The higher 30 bits of 62-bit `rand_b` field value.\n     * @param randBLo - The lower 32 bits of 62-bit `rand_b` field value.\n     * @throws RangeError if any field value is out of the specified range.\n     */ static fromFieldsV7(unixTsMs, randA, randBHi, randBLo) {\n        if (!Number.isInteger(unixTsMs) || !Number.isInteger(randA) || !Number.isInteger(randBHi) || !Number.isInteger(randBLo) || unixTsMs < 0 || randA < 0 || randBHi < 0 || randBLo < 0 || unixTsMs > 281474976710655 || randA > 0xfff || randBHi > 1073741823 || randBLo > 4294967295) {\n            throw new RangeError(\"invalid field value\");\n        }\n        const bytes = new Uint8Array(16);\n        bytes[0] = unixTsMs / 2 ** 40;\n        bytes[1] = unixTsMs / 2 ** 32;\n        bytes[2] = unixTsMs / 2 ** 24;\n        bytes[3] = unixTsMs / 2 ** 16;\n        bytes[4] = unixTsMs / 2 ** 8;\n        bytes[5] = unixTsMs;\n        bytes[6] = 0x70 | randA >>> 8;\n        bytes[7] = randA;\n        bytes[8] = 0x80 | randBHi >>> 24;\n        bytes[9] = randBHi >>> 16;\n        bytes[10] = randBHi >>> 8;\n        bytes[11] = randBHi;\n        bytes[12] = randBLo >>> 24;\n        bytes[13] = randBLo >>> 16;\n        bytes[14] = randBLo >>> 8;\n        bytes[15] = randBLo;\n        return new UUID(bytes);\n    }\n    /**\n     * Builds a byte array from a string representation.\n     *\n     * This method accepts the following formats:\n     *\n     * - 32-digit hexadecimal format without hyphens: `0189dcd553117d408db09496a2eef37b`\n     * - 8-4-4-4-12 hyphenated format: `0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     * - Hyphenated format with surrounding braces: `{0189dcd5-5311-7d40-8db0-9496a2eef37b}`\n     * - RFC 4122 URN format: `urn:uuid:0189dcd5-5311-7d40-8db0-9496a2eef37b`\n     *\n     * Leading and trailing whitespaces represents an error.\n     *\n     * @throws SyntaxError if the argument could not parse as a valid UUID string.\n     */ static parse(uuid) {\n        var _a, _b, _c, _d;\n        let hex = undefined;\n        switch(uuid.length){\n            case 32:\n                hex = (_a = /^[0-9a-f]{32}$/i.exec(uuid)) === null || _a === void 0 ? void 0 : _a[0];\n                break;\n            case 36:\n                hex = (_b = /^([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _b === void 0 ? void 0 : _b.slice(1, 6).join(\"\");\n                break;\n            case 38:\n                hex = (_c = /^\\{([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})\\}$/i.exec(uuid)) === null || _c === void 0 ? void 0 : _c.slice(1, 6).join(\"\");\n                break;\n            case 45:\n                hex = (_d = /^urn:uuid:([0-9a-f]{8})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{4})-([0-9a-f]{12})$/i.exec(uuid)) === null || _d === void 0 ? void 0 : _d.slice(1, 6).join(\"\");\n                break;\n            default:\n                break;\n        }\n        if (hex) {\n            const inner = new Uint8Array(16);\n            for(let i = 0; i < 16; i += 4){\n                const n = parseInt(hex.substring(2 * i, 2 * i + 8), 16);\n                inner[i + 0] = n >>> 24;\n                inner[i + 1] = n >>> 16;\n                inner[i + 2] = n >>> 8;\n                inner[i + 3] = n;\n            }\n            return new UUID(inner);\n        } else {\n            throw new SyntaxError(\"could not parse UUID string\");\n        }\n    }\n    /**\n     * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n     * (`0189dcd5-5311-7d40-8db0-9496a2eef37b`).\n     */ toString() {\n        let text = \"\";\n        for(let i = 0; i < this.bytes.length; i++){\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n            if (i === 3 || i === 5 || i === 7 || i === 9) {\n                text += \"-\";\n            }\n        }\n        return text;\n    }\n    /**\n     * @returns The 32-digit hexadecimal representation without hyphens\n     * (`0189dcd553117d408db09496a2eef37b`).\n     */ toHex() {\n        let text = \"\";\n        for(let i = 0; i < this.bytes.length; i++){\n            text += DIGITS.charAt(this.bytes[i] >>> 4);\n            text += DIGITS.charAt(this.bytes[i] & 0xf);\n        }\n        return text;\n    }\n    /** @returns The 8-4-4-4-12 canonical hexadecimal string representation. */ toJSON() {\n        return this.toString();\n    }\n    /**\n     * Reports the variant field value of the UUID or, if appropriate, \"NIL\" or\n     * \"MAX\".\n     *\n     * For convenience, this method reports \"NIL\" or \"MAX\" if `this` represents\n     * the Nil or Max UUID, although the Nil and Max UUIDs are technically\n     * subsumed under the variants `0b0` and `0b111`, respectively.\n     */ getVariant() {\n        const n = this.bytes[8] >>> 4;\n        if (n < 0) {\n            throw new Error(\"unreachable\");\n        } else if (n <= 7) {\n            return this.bytes.every((e)=>e === 0) ? \"NIL\" : \"VAR_0\";\n        } else if (n <= 11) {\n            return \"VAR_10\";\n        } else if (n <= 13) {\n            return \"VAR_110\";\n        } else if (n <= 15) {\n            return this.bytes.every((e)=>e === 0xff) ? \"MAX\" : \"VAR_RESERVED\";\n        } else {\n            throw new Error(\"unreachable\");\n        }\n    }\n    /**\n     * Returns the version field value of the UUID or `undefined` if the UUID does\n     * not have the variant field value of `0b10`.\n     */ getVersion() {\n        return this.getVariant() === \"VAR_10\" ? this.bytes[6] >>> 4 : undefined;\n    }\n    /** Creates an object from `this`. */ clone() {\n        return new UUID(this.bytes.slice(0));\n    }\n    /** Returns true if `this` is equivalent to `other`. */ equals(other) {\n        return this.compareTo(other) === 0;\n    }\n    /**\n     * Returns a negative integer, zero, or positive integer if `this` is less\n     * than, equal to, or greater than `other`, respectively.\n     */ compareTo(other) {\n        for(let i = 0; i < 16; i++){\n            const diff = this.bytes[i] - other.bytes[i];\n            if (diff !== 0) {\n                return Math.sign(diff);\n            }\n        }\n        return 0;\n    }\n}\nexports.UUID = UUID;\n/**\n * Encapsulates the monotonic counter state.\n *\n * This class provides APIs to utilize a separate counter state from that of the\n * global generator used by {@link uuidv7} and {@link uuidv7obj}. In addition to\n * the default {@link generate} method, this class has {@link generateOrAbort}\n * that is useful to absolutely guarantee the monotonically increasing order of\n * generated UUIDs. See their respective documentation for details.\n */ class V7Generator {\n    /**\n     * Creates a generator object with the default random number generator, or\n     * with the specified one if passed as an argument. The specified random\n     * number generator should be cryptographically strong and securely seeded.\n     */ constructor(randomNumberGenerator){\n        this.timestamp = 0;\n        this.counter = 0;\n        this.random = randomNumberGenerator !== null && randomNumberGenerator !== void 0 ? randomNumberGenerator : getDefaultRandom();\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method resets the\n     * generator and returns a new UUID based on the given timestamp, breaking the\n     * increasing order of UUIDs.\n     *\n     * See {@link generateOrAbort} for the other mode of generation and\n     * {@link generateOrResetCore} for the low-level primitive.\n     */ generate() {\n        return this.generateOrResetCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the current timestamp, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method returns a monotonically increasing UUID by reusing the previous\n     * timestamp even if the up-to-date timestamp is smaller than the immediately\n     * preceding UUID's. However, when such a clock rollback is considered\n     * significant (i.e., by more than ten seconds), this method aborts and\n     * returns `undefined` immediately.\n     *\n     * See {@link generate} for the other mode of generation and\n     * {@link generateOrAbortCore} for the low-level primitive.\n     */ generateOrAbort() {\n        return this.generateOrAbortCore(Date.now(), 10000);\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or resets the\n     * generator upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generate} except that it takes a custom\n     * timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */ generateOrResetCore(unixTsMs, rollbackAllowance) {\n        let value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        if (value === undefined) {\n            // reset state and resume\n            this.timestamp = 0;\n            value = this.generateOrAbortCore(unixTsMs, rollbackAllowance);\n        }\n        return value;\n    }\n    /**\n     * Generates a new UUIDv7 object from the `unixTsMs` passed, or returns\n     * `undefined` upon significant timestamp rollback.\n     *\n     * This method is equivalent to {@link generateOrAbort} except that it takes a\n     * custom timestamp and clock rollback allowance.\n     *\n     * @param rollbackAllowance - The amount of `unixTsMs` rollback that is\n     * considered significant. A suggested value is `10_000` (milliseconds).\n     * @throws RangeError if `unixTsMs` is not a 48-bit positive integer.\n     */ generateOrAbortCore(unixTsMs, rollbackAllowance) {\n        const MAX_COUNTER = 4398046511103;\n        if (!Number.isInteger(unixTsMs) || unixTsMs < 1 || unixTsMs > 281474976710655) {\n            throw new RangeError(\"`unixTsMs` must be a 48-bit positive integer\");\n        } else if (rollbackAllowance < 0 || rollbackAllowance > 281474976710655) {\n            throw new RangeError(\"`rollbackAllowance` out of reasonable range\");\n        }\n        if (unixTsMs > this.timestamp) {\n            this.timestamp = unixTsMs;\n            this.resetCounter();\n        } else if (unixTsMs + rollbackAllowance >= this.timestamp) {\n            // go on with previous timestamp if new one is not much smaller\n            this.counter++;\n            if (this.counter > MAX_COUNTER) {\n                // increment timestamp at counter overflow\n                this.timestamp++;\n                this.resetCounter();\n            }\n        } else {\n            // abort if clock went backwards to unbearable extent\n            return undefined;\n        }\n        return UUID.fromFieldsV7(this.timestamp, Math.trunc(this.counter / 2 ** 30), this.counter & 2 ** 30 - 1, this.random.nextUint32());\n    }\n    /** Initializes the counter at a 42-bit random integer. */ resetCounter() {\n        this.counter = this.random.nextUint32() * 0x400 + (this.random.nextUint32() & 0x3ff);\n    }\n    /**\n     * Generates a new UUIDv4 object utilizing the random number generator inside.\n     *\n     * @internal\n     */ generateV4() {\n        const bytes = new Uint8Array(Uint32Array.of(this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32(), this.random.nextUint32()).buffer);\n        bytes[6] = 0x40 | bytes[6] >>> 4;\n        bytes[8] = 0x80 | bytes[8] >>> 2;\n        return UUID.ofInner(bytes);\n    }\n}\nexports.V7Generator = V7Generator;\n/** Returns the default random number generator available in the environment. */ const getDefaultRandom = ()=>{\n    // detect Web Crypto API\n    if (typeof crypto !== \"undefined\" && typeof crypto.getRandomValues !== \"undefined\") {\n        return new BufferedCryptoRandom();\n    } else {\n        // fall back on Math.random() unless the flag is set to true\n        if (typeof UUIDV7_DENY_WEAK_RNG !== \"undefined\" && UUIDV7_DENY_WEAK_RNG) {\n            throw new Error(\"no cryptographically strong RNG available\");\n        }\n        return {\n            nextUint32: ()=>Math.trunc(Math.random() * 65536) * 65536 + Math.trunc(Math.random() * 65536)\n        };\n    }\n};\n/**\n * Wraps `crypto.getRandomValues()` to enable buffering; this uses a small\n * buffer by default to avoid both unbearable throughput decline in some\n * environments and the waste of time and space for unused values.\n */ class BufferedCryptoRandom {\n    constructor(){\n        this.buffer = new Uint32Array(8);\n        this.cursor = 0xffff;\n    }\n    nextUint32() {\n        if (this.cursor >= this.buffer.length) {\n            crypto.getRandomValues(this.buffer);\n            this.cursor = 0;\n        }\n        return this.buffer[this.cursor++];\n    }\n}\nlet defaultGenerator;\n/**\n * Generates a UUIDv7 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */ const uuidv7 = ()=>(0, exports.uuidv7obj)().toString();\nexports.uuidv7 = uuidv7;\n/** Generates a UUIDv7 object. */ const uuidv7obj = ()=>(defaultGenerator || (defaultGenerator = new V7Generator())).generate();\nexports.uuidv7obj = uuidv7obj;\n/**\n * Generates a UUIDv4 string.\n *\n * @returns The 8-4-4-4-12 canonical hexadecimal string representation\n * (\"xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx\").\n */ const uuidv4 = ()=>(0, exports.uuidv4obj)().toString();\nexports.uuidv4 = uuidv4;\n/** Generates a UUIDv4 object. */ const uuidv4obj = ()=>(defaultGenerator || (defaultGenerator = new V7Generator())).generateV4();\nexports.uuidv4obj = uuidv4obj;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvdXVpZHY3L2Rpc3QvaW5kZXguY2pzIiwibWFwcGluZ3MiOiJBQUFhO0FBQ2I7Ozs7OztDQU1DLEdBQ0RBLDhDQUE2QztJQUFFRyxPQUFPO0FBQUssQ0FBQyxFQUFDO0FBQzdERCxpQkFBaUIsR0FBR0EsY0FBYyxHQUFHQSxpQkFBaUIsR0FBR0EsY0FBYyxHQUFHQSxtQkFBbUIsR0FBR0EsWUFBWSxHQUFHLEtBQUs7QUFDcEgsTUFBTVEsU0FBUztBQUNmLCtDQUErQyxHQUMvQyxNQUFNRDtJQUNGLDBEQUEwRCxHQUMxREUsWUFBWUMsS0FBSyxDQUFFO1FBQ2YsSUFBSSxDQUFDQSxLQUFLLEdBQUdBO0lBQ2pCO0lBQ0E7Ozs7Ozs7O0tBUUMsR0FDRCxPQUFPQyxRQUFRRCxLQUFLLEVBQUU7UUFDbEIsSUFBSUEsTUFBTUUsTUFBTSxLQUFLLElBQUk7WUFDckIsTUFBTSxJQUFJQyxVQUFVO1FBQ3hCLE9BQ0s7WUFDRCxPQUFPLElBQUlOLEtBQUtHO1FBQ3BCO0lBQ0o7SUFDQTs7Ozs7Ozs7S0FRQyxHQUNELE9BQU9JLGFBQWFDLFFBQVEsRUFBRUMsS0FBSyxFQUFFQyxPQUFPLEVBQUVDLE9BQU8sRUFBRTtRQUNuRCxJQUFJLENBQUNDLE9BQU9DLFNBQVMsQ0FBQ0wsYUFDbEIsQ0FBQ0ksT0FBT0MsU0FBUyxDQUFDSixVQUNsQixDQUFDRyxPQUFPQyxTQUFTLENBQUNILFlBQ2xCLENBQUNFLE9BQU9DLFNBQVMsQ0FBQ0YsWUFDbEJILFdBQVcsS0FDWEMsUUFBUSxLQUNSQyxVQUFVLEtBQ1ZDLFVBQVUsS0FDVkgsV0FBVyxtQkFDWEMsUUFBUSxTQUNSQyxVQUFVLGNBQ1ZDLFVBQVUsWUFBWTtZQUN0QixNQUFNLElBQUlHLFdBQVc7UUFDekI7UUFDQSxNQUFNWCxRQUFRLElBQUlZLFdBQVc7UUFDN0JaLEtBQUssQ0FBQyxFQUFFLEdBQUdLLFdBQVcsS0FBSztRQUMzQkwsS0FBSyxDQUFDLEVBQUUsR0FBR0ssV0FBVyxLQUFLO1FBQzNC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UUFDOUIsSUFBSSxDQUFDTyxNQUFNLEdBQUc7SUFDbEI7SUFDQVQsYUFBYTtRQUNULElBQUksSUFBSSxDQUFDUyxNQUFNLElBQUksSUFBSSxDQUFDTCxNQUFNLENBQUNoRSxNQUFNLEVBQUU7WUFDbkNpRSxPQUFPQyxlQUFlLENBQUMsSUFBSSxDQUFDRixNQUFNO1lBQ2xDLElBQUksQ0FBQ0ssTUFBTSxHQUFHO1FBQ2xCO1FBQ0EsT0FBTyxJQUFJLENBQUNMLE1BQU0sQ0FBQyxJQUFJLENBQUNLLE1BQU0sR0FBRztJQUNyQztBQUNKO0FBQ0EsSUFBSUM7QUFDSjs7Ozs7Q0FLQyxHQUNELE1BQU03RSxTQUFTLElBQU0sQ0FBQyxHQUFHTCxRQUFRSSxTQUFTLElBQUlvQyxRQUFRO0FBQ3REeEMsY0FBYyxHQUFHSztBQUNqQiwrQkFBK0IsR0FDL0IsTUFBTUQsWUFBWSxJQUFNLENBQUM4RSxvQkFBcUJBLENBQUFBLG1CQUFtQixJQUFJNUUsYUFBWSxDQUFDLEVBQUd3RCxRQUFRO0FBQzdGOUQsaUJBQWlCLEdBQUdJO0FBQ3BCOzs7OztDQUtDLEdBQ0QsTUFBTUQsU0FBUyxJQUFNLENBQUMsR0FBR0gsUUFBUUUsU0FBUyxJQUFJc0MsUUFBUTtBQUN0RHhDLGNBQWMsR0FBR0c7QUFDakIsK0JBQStCLEdBQy9CLE1BQU1ELFlBQVksSUFBTSxDQUFDZ0Ysb0JBQXFCQSxDQUFBQSxtQkFBbUIsSUFBSTVFLGFBQVksQ0FBQyxFQUFHbUUsVUFBVTtBQUMvRnpFLGlCQUFpQixHQUFHRSIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJzdF9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL3V1aWR2Ny9kaXN0L2luZGV4LmNqcz8yOTI4Il0sInNvdXJjZXNDb250ZW50IjpbIlwidXNlIHN0cmljdFwiO1xuLyoqXG4gKiB1dWlkdjc6IEFuIGV4cGVyaW1lbnRhbCBpbXBsZW1lbnRhdGlvbiBvZiB0aGUgcHJvcG9zZWQgVVVJRCBWZXJzaW9uIDdcbiAqXG4gKiBAbGljZW5zZSBBcGFjaGUtMi4wXG4gKiBAY29weXJpZ2h0IDIwMjEtMjAyMyBMaW9zS1xuICogQHBhY2thZ2VEb2N1bWVudGF0aW9uXG4gKi9cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMudXVpZHY0b2JqID0gZXhwb3J0cy51dWlkdjQgPSBleHBvcnRzLnV1aWR2N29iaiA9IGV4cG9ydHMudXVpZHY3ID0gZXhwb3J0cy5WN0dlbmVyYXRvciA9IGV4cG9ydHMuVVVJRCA9IHZvaWQgMDtcbmNvbnN0IERJR0lUUyA9IFwiMDEyMzQ1Njc4OWFiY2RlZlwiO1xuLyoqIFJlcHJlc2VudHMgYSBVVUlEIGFzIGEgMTYtYnl0ZSBieXRlIGFycmF5LiAqL1xuY2xhc3MgVVVJRCB7XG4gICAgLyoqIEBwYXJhbSBieXRlcyAtIFRoZSAxNi1ieXRlIGJ5dGUgYXJyYXkgcmVwcmVzZW50YXRpb24uICovXG4gICAgY29uc3RydWN0b3IoYnl0ZXMpIHtcbiAgICAgICAgdGhpcy5ieXRlcyA9IGJ5dGVzO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBDcmVhdGVzIGFuIG9iamVjdCBmcm9tIHRoZSBpbnRlcm5hbCByZXByZXNlbnRhdGlvbiwgYSAxNi1ieXRlIGJ5dGUgYXJyYXlcbiAgICAgKiBjb250YWluaW5nIHRoZSBiaW5hcnkgVVVJRCByZXByZXNlbnRhdGlvbiBpbiB0aGUgYmlnLWVuZGlhbiBieXRlIG9yZGVyLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgZG9lcyBOT1Qgc2hhbGxvdy1jb3B5IHRoZSBhcmd1bWVudCwgYW5kIHRodXMgdGhlIGNyZWF0ZWQgb2JqZWN0XG4gICAgICogaG9sZHMgdGhlIHJlZmVyZW5jZSB0byB0aGUgdW5kZXJseWluZyBidWZmZXIuXG4gICAgICpcbiAgICAgKiBAdGhyb3dzIFR5cGVFcnJvciBpZiB0aGUgbGVuZ3RoIG9mIHRoZSBhcmd1bWVudCBpcyBub3QgMTYuXG4gICAgICovXG4gICAgc3RhdGljIG9mSW5uZXIoYnl0ZXMpIHtcbiAgICAgICAgaWYgKGJ5dGVzLmxlbmd0aCAhPT0gMTYpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJub3QgMTI4LWJpdCBsZW5ndGhcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IFVVSUQoYnl0ZXMpO1xuICAgICAgICB9XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGJ5dGUgYXJyYXkgZnJvbSBVVUlEdjcgZmllbGQgdmFsdWVzLlxuICAgICAqXG4gICAgICogQHBhcmFtIHVuaXhUc01zIC0gQSA0OC1iaXQgYHVuaXhfdHNfbXNgIGZpZWxkIHZhbHVlLlxuICAgICAqIEBwYXJhbSByYW5kQSAtIEEgMTItYml0IGByYW5kX2FgIGZpZWxkIHZhbHVlLlxuICAgICAqIEBwYXJhbSByYW5kQkhpIC0gVGhlIGhpZ2hlciAzMCBiaXRzIG9mIDYyLWJpdCBgcmFuZF9iYCBmaWVsZCB2YWx1ZS5cbiAgICAgKiBAcGFyYW0gcmFuZEJMbyAtIFRoZSBsb3dlciAzMiBiaXRzIG9mIDYyLWJpdCBgcmFuZF9iYCBmaWVsZCB2YWx1ZS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYW55IGZpZWxkIHZhbHVlIGlzIG91dCBvZiB0aGUgc3BlY2lmaWVkIHJhbmdlLlxuICAgICAqL1xuICAgIHN0YXRpYyBmcm9tRmllbGRzVjcodW5peFRzTXMsIHJhbmRBLCByYW5kQkhpLCByYW5kQkxvKSB7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih1bml4VHNNcykgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHJhbmRBKSB8fFxuICAgICAgICAgICAgIU51bWJlci5pc0ludGVnZXIocmFuZEJIaSkgfHxcbiAgICAgICAgICAgICFOdW1iZXIuaXNJbnRlZ2VyKHJhbmRCTG8pIHx8XG4gICAgICAgICAgICB1bml4VHNNcyA8IDAgfHxcbiAgICAgICAgICAgIHJhbmRBIDwgMCB8fFxuICAgICAgICAgICAgcmFuZEJIaSA8IDAgfHxcbiAgICAgICAgICAgIHJhbmRCTG8gPCAwIHx8XG4gICAgICAgICAgICB1bml4VHNNcyA+IDI4MTQ3NDk3NjcxMDY1NSB8fFxuICAgICAgICAgICAgcmFuZEEgPiAweGZmZiB8fFxuICAgICAgICAgICAgcmFuZEJIaSA+IDEwNzM3NDE4MjMgfHxcbiAgICAgICAgICAgIHJhbmRCTG8gPiA0Mjk0OTY3Mjk1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImludmFsaWQgZmllbGQgdmFsdWVcIik7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgIGJ5dGVzWzBdID0gdW5peFRzTXMgLyAyICoqIDQwO1xuICAgICAgICBieXRlc1sxXSA9IHVuaXhUc01zIC8gMiAqKiAzMjtcbiAgICAgICAgYnl0ZXNbMl0gPSB1bml4VHNNcyAvIDIgKiogMjQ7XG4gICAgICAgIGJ5dGVzWzNdID0gdW5peFRzTXMgLyAyICoqIDE2O1xuICAgICAgICBieXRlc1s0XSA9IHVuaXhUc01zIC8gMiAqKiA4O1xuICAgICAgICBieXRlc1s1XSA9IHVuaXhUc01zO1xuICAgICAgICBieXRlc1s2XSA9IDB4NzAgfCAocmFuZEEgPj4+IDgpO1xuICAgICAgICBieXRlc1s3XSA9IHJhbmRBO1xuICAgICAgICBieXRlc1s4XSA9IDB4ODAgfCAocmFuZEJIaSA+Pj4gMjQpO1xuICAgICAgICBieXRlc1s5XSA9IHJhbmRCSGkgPj4+IDE2O1xuICAgICAgICBieXRlc1sxMF0gPSByYW5kQkhpID4+PiA4O1xuICAgICAgICBieXRlc1sxMV0gPSByYW5kQkhpO1xuICAgICAgICBieXRlc1sxMl0gPSByYW5kQkxvID4+PiAyNDtcbiAgICAgICAgYnl0ZXNbMTNdID0gcmFuZEJMbyA+Pj4gMTY7XG4gICAgICAgIGJ5dGVzWzE0XSA9IHJhbmRCTG8gPj4+IDg7XG4gICAgICAgIGJ5dGVzWzE1XSA9IHJhbmRCTG87XG4gICAgICAgIHJldHVybiBuZXcgVVVJRChieXRlcyk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEJ1aWxkcyBhIGJ5dGUgYXJyYXkgZnJvbSBhIHN0cmluZyByZXByZXNlbnRhdGlvbi5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGFjY2VwdHMgdGhlIGZvbGxvd2luZyBmb3JtYXRzOlxuICAgICAqXG4gICAgICogLSAzMi1kaWdpdCBoZXhhZGVjaW1hbCBmb3JtYXQgd2l0aG91dCBoeXBoZW5zOiBgMDE4OWRjZDU1MzExN2Q0MDhkYjA5NDk2YTJlZWYzN2JgXG4gICAgICogLSA4LTQtNC00LTEyIGh5cGhlbmF0ZWQgZm9ybWF0OiBgMDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdiYFxuICAgICAqIC0gSHlwaGVuYXRlZCBmb3JtYXQgd2l0aCBzdXJyb3VuZGluZyBicmFjZXM6IGB7MDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdifWBcbiAgICAgKiAtIFJGQyA0MTIyIFVSTiBmb3JtYXQ6IGB1cm46dXVpZDowMTg5ZGNkNS01MzExLTdkNDAtOGRiMC05NDk2YTJlZWYzN2JgXG4gICAgICpcbiAgICAgKiBMZWFkaW5nIGFuZCB0cmFpbGluZyB3aGl0ZXNwYWNlcyByZXByZXNlbnRzIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogQHRocm93cyBTeW50YXhFcnJvciBpZiB0aGUgYXJndW1lbnQgY291bGQgbm90IHBhcnNlIGFzIGEgdmFsaWQgVVVJRCBzdHJpbmcuXG4gICAgICovXG4gICAgc3RhdGljIHBhcnNlKHV1aWQpIHtcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kO1xuICAgICAgICBsZXQgaGV4ID0gdW5kZWZpbmVkO1xuICAgICAgICBzd2l0Y2ggKHV1aWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYXNlIDMyOlxuICAgICAgICAgICAgICAgIGhleCA9IChfYSA9IC9eWzAtOWEtZl17MzJ9JC9pLmV4ZWModXVpZCkpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYVswXTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgMzY6XG4gICAgICAgICAgICAgICAgaGV4ID1cbiAgICAgICAgICAgICAgICAgICAgKF9iID0gL14oWzAtOWEtZl17OH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXsxMn0pJC9pXG4gICAgICAgICAgICAgICAgICAgICAgICAuZXhlYyh1dWlkKSkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnNsaWNlKDEsIDYpLmpvaW4oXCJcIik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIDM4OlxuICAgICAgICAgICAgICAgIGhleCA9XG4gICAgICAgICAgICAgICAgICAgIChfYyA9IC9eXFx7KFswLTlhLWZdezh9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17MTJ9KVxcfSQvaVxuICAgICAgICAgICAgICAgICAgICAgICAgLmV4ZWModXVpZCkpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5zbGljZSgxLCA2KS5qb2luKFwiXCIpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSA0NTpcbiAgICAgICAgICAgICAgICBoZXggPVxuICAgICAgICAgICAgICAgICAgICAoX2QgPSAvXnVybjp1dWlkOihbMC05YS1mXXs4fSktKFswLTlhLWZdezR9KS0oWzAtOWEtZl17NH0pLShbMC05YS1mXXs0fSktKFswLTlhLWZdezEyfSkkL2lcbiAgICAgICAgICAgICAgICAgICAgICAgIC5leGVjKHV1aWQpKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quc2xpY2UoMSwgNikuam9pbihcIlwiKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGhleCkge1xuICAgICAgICAgICAgY29uc3QgaW5uZXIgPSBuZXcgVWludDhBcnJheSgxNik7XG4gICAgICAgICAgICBmb3IgKGxldCBpID0gMDsgaSA8IDE2OyBpICs9IDQpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBuID0gcGFyc2VJbnQoaGV4LnN1YnN0cmluZygyICogaSwgMiAqIGkgKyA4KSwgMTYpO1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAwXSA9IG4gPj4+IDI0O1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAxXSA9IG4gPj4+IDE2O1xuICAgICAgICAgICAgICAgIGlubmVyW2kgKyAyXSA9IG4gPj4+IDg7XG4gICAgICAgICAgICAgICAgaW5uZXJbaSArIDNdID0gbjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBuZXcgVVVJRChpbm5lcik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgU3ludGF4RXJyb3IoXCJjb3VsZCBub3QgcGFyc2UgVVVJRCBzdHJpbmdcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgLyoqXG4gICAgICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICAgICAqIChgMDE4OWRjZDUtNTMxMS03ZDQwLThkYjAtOTQ5NmEyZWVmMzdiYCkuXG4gICAgICovXG4gICAgdG9TdHJpbmcoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSA+Pj4gNCk7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSAmIDB4Zik7XG4gICAgICAgICAgICBpZiAoaSA9PT0gMyB8fCBpID09PSA1IHx8IGkgPT09IDcgfHwgaSA9PT0gOSkge1xuICAgICAgICAgICAgICAgIHRleHQgKz0gXCItXCI7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEByZXR1cm5zIFRoZSAzMi1kaWdpdCBoZXhhZGVjaW1hbCByZXByZXNlbnRhdGlvbiB3aXRob3V0IGh5cGhlbnNcbiAgICAgKiAoYDAxODlkY2Q1NTMxMTdkNDA4ZGIwOTQ5NmEyZWVmMzdiYCkuXG4gICAgICovXG4gICAgdG9IZXgoKSB7XG4gICAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCB0aGlzLmJ5dGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSA+Pj4gNCk7XG4gICAgICAgICAgICB0ZXh0ICs9IERJR0lUUy5jaGFyQXQodGhpcy5ieXRlc1tpXSAmIDB4Zik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRleHQ7XG4gICAgfVxuICAgIC8qKiBAcmV0dXJucyBUaGUgOC00LTQtNC0xMiBjYW5vbmljYWwgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uLiAqL1xuICAgIHRvSlNPTigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmVwb3J0cyB0aGUgdmFyaWFudCBmaWVsZCB2YWx1ZSBvZiB0aGUgVVVJRCBvciwgaWYgYXBwcm9wcmlhdGUsIFwiTklMXCIgb3JcbiAgICAgKiBcIk1BWFwiLlxuICAgICAqXG4gICAgICogRm9yIGNvbnZlbmllbmNlLCB0aGlzIG1ldGhvZCByZXBvcnRzIFwiTklMXCIgb3IgXCJNQVhcIiBpZiBgdGhpc2AgcmVwcmVzZW50c1xuICAgICAqIHRoZSBOaWwgb3IgTWF4IFVVSUQsIGFsdGhvdWdoIHRoZSBOaWwgYW5kIE1heCBVVUlEcyBhcmUgdGVjaG5pY2FsbHlcbiAgICAgKiBzdWJzdW1lZCB1bmRlciB0aGUgdmFyaWFudHMgYDBiMGAgYW5kIGAwYjExMWAsIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBnZXRWYXJpYW50KCkge1xuICAgICAgICBjb25zdCBuID0gdGhpcy5ieXRlc1s4XSA+Pj4gNDtcbiAgICAgICAgaWYgKG4gPCAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMDExMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXZlcnkoKGUpID0+IGUgPT09IDApID8gXCJOSUxcIiA6IFwiVkFSXzBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMTAxMSkge1xuICAgICAgICAgICAgcmV0dXJuIFwiVkFSXzEwXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobiA8PSAwYjExMDEpIHtcbiAgICAgICAgICAgIHJldHVybiBcIlZBUl8xMTBcIjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChuIDw9IDBiMTExMSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYnl0ZXMuZXZlcnkoKGUpID0+IGUgPT09IDB4ZmYpID8gXCJNQVhcIiA6IFwiVkFSX1JFU0VSVkVEXCI7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ1bnJlYWNoYWJsZVwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKipcbiAgICAgKiBSZXR1cm5zIHRoZSB2ZXJzaW9uIGZpZWxkIHZhbHVlIG9mIHRoZSBVVUlEIG9yIGB1bmRlZmluZWRgIGlmIHRoZSBVVUlEIGRvZXNcbiAgICAgKiBub3QgaGF2ZSB0aGUgdmFyaWFudCBmaWVsZCB2YWx1ZSBvZiBgMGIxMGAuXG4gICAgICovXG4gICAgZ2V0VmVyc2lvbigpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0VmFyaWFudCgpID09PSBcIlZBUl8xMFwiID8gdGhpcy5ieXRlc1s2XSA+Pj4gNCA6IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgLyoqIENyZWF0ZXMgYW4gb2JqZWN0IGZyb20gYHRoaXNgLiAqL1xuICAgIGNsb25lKCkge1xuICAgICAgICByZXR1cm4gbmV3IFVVSUQodGhpcy5ieXRlcy5zbGljZSgwKSk7XG4gICAgfVxuICAgIC8qKiBSZXR1cm5zIHRydWUgaWYgYHRoaXNgIGlzIGVxdWl2YWxlbnQgdG8gYG90aGVyYC4gKi9cbiAgICBlcXVhbHMob3RoZXIpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuY29tcGFyZVRvKG90aGVyKSA9PT0gMDtcbiAgICB9XG4gICAgLyoqXG4gICAgICogUmV0dXJucyBhIG5lZ2F0aXZlIGludGVnZXIsIHplcm8sIG9yIHBvc2l0aXZlIGludGVnZXIgaWYgYHRoaXNgIGlzIGxlc3NcbiAgICAgKiB0aGFuLCBlcXVhbCB0bywgb3IgZ3JlYXRlciB0aGFuIGBvdGhlcmAsIHJlc3BlY3RpdmVseS5cbiAgICAgKi9cbiAgICBjb21wYXJlVG8ob3RoZXIpIHtcbiAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCAxNjsgaSsrKSB7XG4gICAgICAgICAgICBjb25zdCBkaWZmID0gdGhpcy5ieXRlc1tpXSAtIG90aGVyLmJ5dGVzW2ldO1xuICAgICAgICAgICAgaWYgKGRpZmYgIT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gTWF0aC5zaWduKGRpZmYpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAwO1xuICAgIH1cbn1cbmV4cG9ydHMuVVVJRCA9IFVVSUQ7XG4vKipcbiAqIEVuY2Fwc3VsYXRlcyB0aGUgbW9ub3RvbmljIGNvdW50ZXIgc3RhdGUuXG4gKlxuICogVGhpcyBjbGFzcyBwcm92aWRlcyBBUElzIHRvIHV0aWxpemUgYSBzZXBhcmF0ZSBjb3VudGVyIHN0YXRlIGZyb20gdGhhdCBvZiB0aGVcbiAqIGdsb2JhbCBnZW5lcmF0b3IgdXNlZCBieSB7QGxpbmsgdXVpZHY3fSBhbmQge0BsaW5rIHV1aWR2N29ian0uIEluIGFkZGl0aW9uIHRvXG4gKiB0aGUgZGVmYXVsdCB7QGxpbmsgZ2VuZXJhdGV9IG1ldGhvZCwgdGhpcyBjbGFzcyBoYXMge0BsaW5rIGdlbmVyYXRlT3JBYm9ydH1cbiAqIHRoYXQgaXMgdXNlZnVsIHRvIGFic29sdXRlbHkgZ3VhcmFudGVlIHRoZSBtb25vdG9uaWNhbGx5IGluY3JlYXNpbmcgb3JkZXIgb2ZcbiAqIGdlbmVyYXRlZCBVVUlEcy4gU2VlIHRoZWlyIHJlc3BlY3RpdmUgZG9jdW1lbnRhdGlvbiBmb3IgZGV0YWlscy5cbiAqL1xuY2xhc3MgVjdHZW5lcmF0b3Ige1xuICAgIC8qKlxuICAgICAqIENyZWF0ZXMgYSBnZW5lcmF0b3Igb2JqZWN0IHdpdGggdGhlIGRlZmF1bHQgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IsIG9yXG4gICAgICogd2l0aCB0aGUgc3BlY2lmaWVkIG9uZSBpZiBwYXNzZWQgYXMgYW4gYXJndW1lbnQuIFRoZSBzcGVjaWZpZWQgcmFuZG9tXG4gICAgICogbnVtYmVyIGdlbmVyYXRvciBzaG91bGQgYmUgY3J5cHRvZ3JhcGhpY2FsbHkgc3Ryb25nIGFuZCBzZWN1cmVseSBzZWVkZWQuXG4gICAgICovXG4gICAgY29uc3RydWN0b3IocmFuZG9tTnVtYmVyR2VuZXJhdG9yKSB7XG4gICAgICAgIHRoaXMudGltZXN0YW1wID0gMDtcbiAgICAgICAgdGhpcy5jb3VudGVyID0gMDtcbiAgICAgICAgdGhpcy5yYW5kb20gPSByYW5kb21OdW1iZXJHZW5lcmF0b3IgIT09IG51bGwgJiYgcmFuZG9tTnVtYmVyR2VuZXJhdG9yICE9PSB2b2lkIDAgPyByYW5kb21OdW1iZXJHZW5lcmF0b3IgOiBnZXREZWZhdWx0UmFuZG9tKCk7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjcgb2JqZWN0IGZyb20gdGhlIGN1cnJlbnQgdGltZXN0YW1wLCBvciByZXNldHMgdGhlXG4gICAgICogZ2VuZXJhdG9yIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBVVUlEIGJ5IHJldXNpbmcgdGhlIHByZXZpb3VzXG4gICAgICogdGltZXN0YW1wIGV2ZW4gaWYgdGhlIHVwLXRvLWRhdGUgdGltZXN0YW1wIGlzIHNtYWxsZXIgdGhhbiB0aGUgaW1tZWRpYXRlbHlcbiAgICAgKiBwcmVjZWRpbmcgVVVJRCdzLiBIb3dldmVyLCB3aGVuIHN1Y2ggYSBjbG9jayByb2xsYmFjayBpcyBjb25zaWRlcmVkXG4gICAgICogc2lnbmlmaWNhbnQgKGkuZS4sIGJ5IG1vcmUgdGhhbiB0ZW4gc2Vjb25kcyksIHRoaXMgbWV0aG9kIHJlc2V0cyB0aGVcbiAgICAgKiBnZW5lcmF0b3IgYW5kIHJldHVybnMgYSBuZXcgVVVJRCBiYXNlZCBvbiB0aGUgZ2l2ZW4gdGltZXN0YW1wLCBicmVha2luZyB0aGVcbiAgICAgKiBpbmNyZWFzaW5nIG9yZGVyIG9mIFVVSURzLlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBnZW5lcmF0ZU9yQWJvcnR9IGZvciB0aGUgb3RoZXIgbW9kZSBvZiBnZW5lcmF0aW9uIGFuZFxuICAgICAqIHtAbGluayBnZW5lcmF0ZU9yUmVzZXRDb3JlfSBmb3IgdGhlIGxvdy1sZXZlbCBwcmltaXRpdmUuXG4gICAgICovXG4gICAgZ2VuZXJhdGUoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlT3JSZXNldENvcmUoRGF0ZS5ub3coKSwgMTAwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBjdXJyZW50IHRpbWVzdGFtcCwgb3IgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgcmV0dXJucyBhIG1vbm90b25pY2FsbHkgaW5jcmVhc2luZyBVVUlEIGJ5IHJldXNpbmcgdGhlIHByZXZpb3VzXG4gICAgICogdGltZXN0YW1wIGV2ZW4gaWYgdGhlIHVwLXRvLWRhdGUgdGltZXN0YW1wIGlzIHNtYWxsZXIgdGhhbiB0aGUgaW1tZWRpYXRlbHlcbiAgICAgKiBwcmVjZWRpbmcgVVVJRCdzLiBIb3dldmVyLCB3aGVuIHN1Y2ggYSBjbG9jayByb2xsYmFjayBpcyBjb25zaWRlcmVkXG4gICAgICogc2lnbmlmaWNhbnQgKGkuZS4sIGJ5IG1vcmUgdGhhbiB0ZW4gc2Vjb25kcyksIHRoaXMgbWV0aG9kIGFib3J0cyBhbmRcbiAgICAgKiByZXR1cm5zIGB1bmRlZmluZWRgIGltbWVkaWF0ZWx5LlxuICAgICAqXG4gICAgICogU2VlIHtAbGluayBnZW5lcmF0ZX0gZm9yIHRoZSBvdGhlciBtb2RlIG9mIGdlbmVyYXRpb24gYW5kXG4gICAgICoge0BsaW5rIGdlbmVyYXRlT3JBYm9ydENvcmV9IGZvciB0aGUgbG93LWxldmVsIHByaW1pdGl2ZS5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9yQWJvcnQoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUoRGF0ZS5ub3coKSwgMTAwMDApO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBgdW5peFRzTXNgIHBhc3NlZCwgb3IgcmVzZXRzIHRoZVxuICAgICAqIGdlbmVyYXRvciB1cG9uIHNpZ25pZmljYW50IHRpbWVzdGFtcCByb2xsYmFjay5cbiAgICAgKlxuICAgICAqIFRoaXMgbWV0aG9kIGlzIGVxdWl2YWxlbnQgdG8ge0BsaW5rIGdlbmVyYXRlfSBleGNlcHQgdGhhdCBpdCB0YWtlcyBhIGN1c3RvbVxuICAgICAqIHRpbWVzdGFtcCBhbmQgY2xvY2sgcm9sbGJhY2sgYWxsb3dhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvbGxiYWNrQWxsb3dhbmNlIC0gVGhlIGFtb3VudCBvZiBgdW5peFRzTXNgIHJvbGxiYWNrIHRoYXQgaXNcbiAgICAgKiBjb25zaWRlcmVkIHNpZ25pZmljYW50LiBBIHN1Z2dlc3RlZCB2YWx1ZSBpcyBgMTBfMDAwYCAobWlsbGlzZWNvbmRzKS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYHVuaXhUc01zYCBpcyBub3QgYSA0OC1iaXQgcG9zaXRpdmUgaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9yUmVzZXRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSkge1xuICAgICAgICBsZXQgdmFsdWUgPSB0aGlzLmdlbmVyYXRlT3JBYm9ydENvcmUodW5peFRzTXMsIHJvbGxiYWNrQWxsb3dhbmNlKTtcbiAgICAgICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIC8vIHJlc2V0IHN0YXRlIGFuZCByZXN1bWVcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gMDtcbiAgICAgICAgICAgIHZhbHVlID0gdGhpcy5nZW5lcmF0ZU9yQWJvcnRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBHZW5lcmF0ZXMgYSBuZXcgVVVJRHY3IG9iamVjdCBmcm9tIHRoZSBgdW5peFRzTXNgIHBhc3NlZCwgb3IgcmV0dXJuc1xuICAgICAqIGB1bmRlZmluZWRgIHVwb24gc2lnbmlmaWNhbnQgdGltZXN0YW1wIHJvbGxiYWNrLlxuICAgICAqXG4gICAgICogVGhpcyBtZXRob2QgaXMgZXF1aXZhbGVudCB0byB7QGxpbmsgZ2VuZXJhdGVPckFib3J0fSBleGNlcHQgdGhhdCBpdCB0YWtlcyBhXG4gICAgICogY3VzdG9tIHRpbWVzdGFtcCBhbmQgY2xvY2sgcm9sbGJhY2sgYWxsb3dhbmNlLlxuICAgICAqXG4gICAgICogQHBhcmFtIHJvbGxiYWNrQWxsb3dhbmNlIC0gVGhlIGFtb3VudCBvZiBgdW5peFRzTXNgIHJvbGxiYWNrIHRoYXQgaXNcbiAgICAgKiBjb25zaWRlcmVkIHNpZ25pZmljYW50LiBBIHN1Z2dlc3RlZCB2YWx1ZSBpcyBgMTBfMDAwYCAobWlsbGlzZWNvbmRzKS5cbiAgICAgKiBAdGhyb3dzIFJhbmdlRXJyb3IgaWYgYHVuaXhUc01zYCBpcyBub3QgYSA0OC1iaXQgcG9zaXRpdmUgaW50ZWdlci5cbiAgICAgKi9cbiAgICBnZW5lcmF0ZU9yQWJvcnRDb3JlKHVuaXhUc01zLCByb2xsYmFja0FsbG93YW5jZSkge1xuICAgICAgICBjb25zdCBNQVhfQ09VTlRFUiA9IDQzOTgwNDY1MTExMDM7XG4gICAgICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcih1bml4VHNNcykgfHxcbiAgICAgICAgICAgIHVuaXhUc01zIDwgMSB8fFxuICAgICAgICAgICAgdW5peFRzTXMgPiAyODE0NzQ5NzY3MTA2NTUpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBSYW5nZUVycm9yKFwiYHVuaXhUc01zYCBtdXN0IGJlIGEgNDgtYml0IHBvc2l0aXZlIGludGVnZXJcIik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAocm9sbGJhY2tBbGxvd2FuY2UgPCAwIHx8IHJvbGxiYWNrQWxsb3dhbmNlID4gMjgxNDc0OTc2NzEwNjU1KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcihcImByb2xsYmFja0FsbG93YW5jZWAgb3V0IG9mIHJlYXNvbmFibGUgcmFuZ2VcIik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHVuaXhUc01zID4gdGhpcy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIHRoaXMudGltZXN0YW1wID0gdW5peFRzTXM7XG4gICAgICAgICAgICB0aGlzLnJlc2V0Q291bnRlcigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHVuaXhUc01zICsgcm9sbGJhY2tBbGxvd2FuY2UgPj0gdGhpcy50aW1lc3RhbXApIHtcbiAgICAgICAgICAgIC8vIGdvIG9uIHdpdGggcHJldmlvdXMgdGltZXN0YW1wIGlmIG5ldyBvbmUgaXMgbm90IG11Y2ggc21hbGxlclxuICAgICAgICAgICAgdGhpcy5jb3VudGVyKys7XG4gICAgICAgICAgICBpZiAodGhpcy5jb3VudGVyID4gTUFYX0NPVU5URVIpIHtcbiAgICAgICAgICAgICAgICAvLyBpbmNyZW1lbnQgdGltZXN0YW1wIGF0IGNvdW50ZXIgb3ZlcmZsb3dcbiAgICAgICAgICAgICAgICB0aGlzLnRpbWVzdGFtcCsrO1xuICAgICAgICAgICAgICAgIHRoaXMucmVzZXRDb3VudGVyKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAvLyBhYm9ydCBpZiBjbG9jayB3ZW50IGJhY2t3YXJkcyB0byB1bmJlYXJhYmxlIGV4dGVudFxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gVVVJRC5mcm9tRmllbGRzVjcodGhpcy50aW1lc3RhbXAsIE1hdGgudHJ1bmModGhpcy5jb3VudGVyIC8gMiAqKiAzMCksIHRoaXMuY291bnRlciAmICgyICoqIDMwIC0gMSksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSk7XG4gICAgfVxuICAgIC8qKiBJbml0aWFsaXplcyB0aGUgY291bnRlciBhdCBhIDQyLWJpdCByYW5kb20gaW50ZWdlci4gKi9cbiAgICByZXNldENvdW50ZXIoKSB7XG4gICAgICAgIHRoaXMuY291bnRlciA9XG4gICAgICAgICAgICB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkgKiAweDQwMCArICh0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkgJiAweDNmZik7XG4gICAgfVxuICAgIC8qKlxuICAgICAqIEdlbmVyYXRlcyBhIG5ldyBVVUlEdjQgb2JqZWN0IHV0aWxpemluZyB0aGUgcmFuZG9tIG51bWJlciBnZW5lcmF0b3IgaW5zaWRlLlxuICAgICAqXG4gICAgICogQGludGVybmFsXG4gICAgICovXG4gICAgZ2VuZXJhdGVWNCgpIHtcbiAgICAgICAgY29uc3QgYnl0ZXMgPSBuZXcgVWludDhBcnJheShVaW50MzJBcnJheS5vZih0aGlzLnJhbmRvbS5uZXh0VWludDMyKCksIHRoaXMucmFuZG9tLm5leHRVaW50MzIoKSwgdGhpcy5yYW5kb20ubmV4dFVpbnQzMigpLCB0aGlzLnJhbmRvbS5uZXh0VWludDMyKCkpLmJ1ZmZlcik7XG4gICAgICAgIGJ5dGVzWzZdID0gMHg0MCB8IChieXRlc1s2XSA+Pj4gNCk7XG4gICAgICAgIGJ5dGVzWzhdID0gMHg4MCB8IChieXRlc1s4XSA+Pj4gMik7XG4gICAgICAgIHJldHVybiBVVUlELm9mSW5uZXIoYnl0ZXMpO1xuICAgIH1cbn1cbmV4cG9ydHMuVjdHZW5lcmF0b3IgPSBWN0dlbmVyYXRvcjtcbi8qKiBSZXR1cm5zIHRoZSBkZWZhdWx0IHJhbmRvbSBudW1iZXIgZ2VuZXJhdG9yIGF2YWlsYWJsZSBpbiB0aGUgZW52aXJvbm1lbnQuICovXG5jb25zdCBnZXREZWZhdWx0UmFuZG9tID0gKCkgPT4ge1xuICAgIC8vIGRldGVjdCBXZWIgQ3J5cHRvIEFQSVxuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSBcInVuZGVmaW5lZFwiICYmXG4gICAgICAgIHR5cGVvZiBjcnlwdG8uZ2V0UmFuZG9tVmFsdWVzICE9PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgICAgIHJldHVybiBuZXcgQnVmZmVyZWRDcnlwdG9SYW5kb20oKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8vIGZhbGwgYmFjayBvbiBNYXRoLnJhbmRvbSgpIHVubGVzcyB0aGUgZmxhZyBpcyBzZXQgdG8gdHJ1ZVxuICAgICAgICBpZiAodHlwZW9mIFVVSURWN19ERU5ZX1dFQUtfUk5HICE9PSBcInVuZGVmaW5lZFwiICYmIFVVSURWN19ERU5ZX1dFQUtfUk5HKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJubyBjcnlwdG9ncmFwaGljYWxseSBzdHJvbmcgUk5HIGF2YWlsYWJsZVwiKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmV4dFVpbnQzMjogKCkgPT4gTWF0aC50cnVuYyhNYXRoLnJhbmRvbSgpICogNjU1MzYpICogNjU1MzYgK1xuICAgICAgICAgICAgICAgIE1hdGgudHJ1bmMoTWF0aC5yYW5kb20oKSAqIDY1NTM2KSxcbiAgICAgICAgfTtcbiAgICB9XG59O1xuLyoqXG4gKiBXcmFwcyBgY3J5cHRvLmdldFJhbmRvbVZhbHVlcygpYCB0byBlbmFibGUgYnVmZmVyaW5nOyB0aGlzIHVzZXMgYSBzbWFsbFxuICogYnVmZmVyIGJ5IGRlZmF1bHQgdG8gYXZvaWQgYm90aCB1bmJlYXJhYmxlIHRocm91Z2hwdXQgZGVjbGluZSBpbiBzb21lXG4gKiBlbnZpcm9ubWVudHMgYW5kIHRoZSB3YXN0ZSBvZiB0aW1lIGFuZCBzcGFjZSBmb3IgdW51c2VkIHZhbHVlcy5cbiAqL1xuY2xhc3MgQnVmZmVyZWRDcnlwdG9SYW5kb20ge1xuICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICB0aGlzLmJ1ZmZlciA9IG5ldyBVaW50MzJBcnJheSg4KTtcbiAgICAgICAgdGhpcy5jdXJzb3IgPSAweGZmZmY7XG4gICAgfVxuICAgIG5leHRVaW50MzIoKSB7XG4gICAgICAgIGlmICh0aGlzLmN1cnNvciA+PSB0aGlzLmJ1ZmZlci5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNyeXB0by5nZXRSYW5kb21WYWx1ZXModGhpcy5idWZmZXIpO1xuICAgICAgICAgICAgdGhpcy5jdXJzb3IgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmJ1ZmZlclt0aGlzLmN1cnNvcisrXTtcbiAgICB9XG59XG5sZXQgZGVmYXVsdEdlbmVyYXRvcjtcbi8qKlxuICogR2VuZXJhdGVzIGEgVVVJRHY3IHN0cmluZy5cbiAqXG4gKiBAcmV0dXJucyBUaGUgOC00LTQtNC0xMiBjYW5vbmljYWwgaGV4YWRlY2ltYWwgc3RyaW5nIHJlcHJlc2VudGF0aW9uXG4gKiAoXCJ4eHh4eHh4eC14eHh4LXh4eHgteHh4eC14eHh4eHh4eHh4eHhcIikuXG4gKi9cbmNvbnN0IHV1aWR2NyA9ICgpID0+ICgwLCBleHBvcnRzLnV1aWR2N29iaikoKS50b1N0cmluZygpO1xuZXhwb3J0cy51dWlkdjcgPSB1dWlkdjc7XG4vKiogR2VuZXJhdGVzIGEgVVVJRHY3IG9iamVjdC4gKi9cbmNvbnN0IHV1aWR2N29iaiA9ICgpID0+IChkZWZhdWx0R2VuZXJhdG9yIHx8IChkZWZhdWx0R2VuZXJhdG9yID0gbmV3IFY3R2VuZXJhdG9yKCkpKS5nZW5lcmF0ZSgpO1xuZXhwb3J0cy51dWlkdjdvYmogPSB1dWlkdjdvYmo7XG4vKipcbiAqIEdlbmVyYXRlcyBhIFVVSUR2NCBzdHJpbmcuXG4gKlxuICogQHJldHVybnMgVGhlIDgtNC00LTQtMTIgY2Fub25pY2FsIGhleGFkZWNpbWFsIHN0cmluZyByZXByZXNlbnRhdGlvblxuICogKFwieHh4eHh4eHgteHh4eC14eHh4LXh4eHgteHh4eHh4eHh4eHh4XCIpLlxuICovXG5jb25zdCB1dWlkdjQgPSAoKSA9PiAoMCwgZXhwb3J0cy51dWlkdjRvYmopKCkudG9TdHJpbmcoKTtcbmV4cG9ydHMudXVpZHY0ID0gdXVpZHY0O1xuLyoqIEdlbmVyYXRlcyBhIFVVSUR2NCBvYmplY3QuICovXG5jb25zdCB1dWlkdjRvYmogPSAoKSA9PiAoZGVmYXVsdEdlbmVyYXRvciB8fCAoZGVmYXVsdEdlbmVyYXRvciA9IG5ldyBWN0dlbmVyYXRvcigpKSkuZ2VuZXJhdGVWNCgpO1xuZXhwb3J0cy51dWlkdjRvYmogPSB1dWlkdjRvYmo7XG4iXSwibmFtZXMiOlsiT2JqZWN0IiwiZGVmaW5lUHJvcGVydHkiLCJleHBvcnRzIiwidmFsdWUiLCJ1dWlkdjRvYmoiLCJ1dWlkdjQiLCJ1dWlkdjdvYmoiLCJ1dWlkdjciLCJWN0dlbmVyYXRvciIsIlVVSUQiLCJESUdJVFMiLCJjb25zdHJ1Y3RvciIsImJ5dGVzIiwib2ZJbm5lciIsImxlbmd0aCIsIlR5cGVFcnJvciIsImZyb21GaWVsZHNWNyIsInVuaXhUc01zIiwicmFuZEEiLCJyYW5kQkhpIiwicmFuZEJMbyIsIk51bWJlciIsImlzSW50ZWdlciIsIlJhbmdlRXJyb3IiLCJVaW50OEFycmF5IiwicGFyc2UiLCJ1dWlkIiwiX2EiLCJfYiIsIl9jIiwiX2QiLCJoZXgiLCJ1bmRlZmluZWQiLCJleGVjIiwic2xpY2UiLCJqb2luIiwiaW5uZXIiLCJpIiwibiIsInBhcnNlSW50Iiwic3Vic3RyaW5nIiwiU3ludGF4RXJyb3IiLCJ0b1N0cmluZyIsInRleHQiLCJjaGFyQXQiLCJ0b0hleCIsInRvSlNPTiIsImdldFZhcmlhbnQiLCJFcnJvciIsImV2ZXJ5IiwiZSIsImdldFZlcnNpb24iLCJjbG9uZSIsImVxdWFscyIsIm90aGVyIiwiY29tcGFyZVRvIiwiZGlmZiIsIk1hdGgiLCJzaWduIiwicmFuZG9tTnVtYmVyR2VuZXJhdG9yIiwidGltZXN0YW1wIiwiY291bnRlciIsInJhbmRvbSIsImdldERlZmF1bHRSYW5kb20iLCJnZW5lcmF0ZSIsImdlbmVyYXRlT3JSZXNldENvcmUiLCJEYXRlIiwibm93IiwiZ2VuZXJhdGVPckFib3J0IiwiZ2VuZXJhdGVPckFib3J0Q29yZSIsInJvbGxiYWNrQWxsb3dhbmNlIiwiTUFYX0NPVU5URVIiLCJyZXNldENvdW50ZXIiLCJ0cnVuYyIsIm5leHRVaW50MzIiLCJnZW5lcmF0ZVY0IiwiVWludDMyQXJyYXkiLCJvZiIsImJ1ZmZlciIsImNyeXB0byIsImdldFJhbmRvbVZhbHVlcyIsIkJ1ZmZlcmVkQ3J5cHRvUmFuZG9tIiwiVVVJRFY3X0RFTllfV0VBS19STkciLCJjdXJzb3IiLCJkZWZhdWx0R2VuZXJhdG9yIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/uuidv7/dist/index.cjs\n");

/***/ })

};
;