"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/ai";
exports.ids = ["vendor-chunks/ai"];
exports.modules = {

/***/ "(ssr)/./node_modules/ai/react/dist/index.mjs":
/*!**********************************************!*\
  !*** ./node_modules/ai/react/dist/index.mjs ***!
  \**********************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/react */ \"(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs\");\n'use client'\n\n// react/index.ts\n;\nvar useChat = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useChat;\nvar useCompletion = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useCompletion;\nvar useAssistant = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.useAssistant;\nvar experimental_useObject = _ai_sdk_react__WEBPACK_IMPORTED_MODULE_0__.experimental_useObject;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvYWkvcmVhY3QvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBQTs7QUFFQTtBQUNBLENBS3VCO0FBQ3ZCLGNBQWMsa0RBQVk7QUFDMUIsb0JBQW9CLHdEQUFrQjtBQUN0QyxtQkFBbUIsdURBQWlCO0FBQ3BDLDZCQUE2QixpRUFBMkI7QUFNdEQ7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJzdF9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2FpL3JlYWN0L2Rpc3QvaW5kZXgubWpzPzg4YTgiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBjbGllbnQnXG5cbi8vIHJlYWN0L2luZGV4LnRzXG5pbXBvcnQge1xuICB1c2VDaGF0IGFzIHVzZUNoYXRSZWFjdCxcbiAgdXNlQ29tcGxldGlvbiBhcyB1c2VDb21wbGV0aW9uUmVhY3QsXG4gIHVzZUFzc2lzdGFudCBhcyB1c2VBc3Npc3RhbnRSZWFjdCxcbiAgZXhwZXJpbWVudGFsX3VzZU9iamVjdCBhcyBleHBlcmltZW50YWxfdXNlT2JqZWN0UmVhY3Rcbn0gZnJvbSBcIkBhaS1zZGsvcmVhY3RcIjtcbnZhciB1c2VDaGF0ID0gdXNlQ2hhdFJlYWN0O1xudmFyIHVzZUNvbXBsZXRpb24gPSB1c2VDb21wbGV0aW9uUmVhY3Q7XG52YXIgdXNlQXNzaXN0YW50ID0gdXNlQXNzaXN0YW50UmVhY3Q7XG52YXIgZXhwZXJpbWVudGFsX3VzZU9iamVjdCA9IGV4cGVyaW1lbnRhbF91c2VPYmplY3RSZWFjdDtcbmV4cG9ydCB7XG4gIGV4cGVyaW1lbnRhbF91c2VPYmplY3QsXG4gIHVzZUFzc2lzdGFudCxcbiAgdXNlQ2hhdCxcbiAgdXNlQ29tcGxldGlvblxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/ai/react/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/ai/dist/index.mjs":
/*!****************************************!*\
  !*** ./node_modules/ai/dist/index.mjs ***!
  \****************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError),\n/* harmony export */   AIStream: () => (/* binding */ AIStream),\n/* harmony export */   APICallError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError),\n/* harmony export */   AWSBedrockAnthropicMessagesStream: () => (/* binding */ AWSBedrockAnthropicMessagesStream),\n/* harmony export */   AWSBedrockAnthropicStream: () => (/* binding */ AWSBedrockAnthropicStream),\n/* harmony export */   AWSBedrockCohereStream: () => (/* binding */ AWSBedrockCohereStream),\n/* harmony export */   AWSBedrockLlama2Stream: () => (/* binding */ AWSBedrockLlama2Stream),\n/* harmony export */   AWSBedrockStream: () => (/* binding */ AWSBedrockStream),\n/* harmony export */   AnthropicStream: () => (/* binding */ AnthropicStream),\n/* harmony export */   AssistantResponse: () => (/* binding */ AssistantResponse),\n/* harmony export */   CohereStream: () => (/* binding */ CohereStream),\n/* harmony export */   DownloadError: () => (/* binding */ DownloadError),\n/* harmony export */   EmptyResponseBodyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.EmptyResponseBodyError),\n/* harmony export */   GoogleGenerativeAIStream: () => (/* binding */ GoogleGenerativeAIStream),\n/* harmony export */   HuggingFaceStream: () => (/* binding */ HuggingFaceStream),\n/* harmony export */   InkeepStream: () => (/* binding */ InkeepStream),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidDataContentError: () => (/* binding */ InvalidDataContentError),\n/* harmony export */   InvalidMessageRoleError: () => (/* binding */ InvalidMessageRoleError),\n/* harmony export */   InvalidPromptError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidResponseDataError),\n/* harmony export */   InvalidToolArgumentsError: () => (/* binding */ InvalidToolArgumentsError),\n/* harmony export */   JSONParseError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.JSONParseError),\n/* harmony export */   LangChainAdapter: () => (/* binding */ langchain_adapter_exports),\n/* harmony export */   LangChainStream: () => (/* binding */ LangChainStream),\n/* harmony export */   LlamaIndexAdapter: () => (/* binding */ llamaindex_adapter_exports),\n/* harmony export */   LoadAPIKeyError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.LoadAPIKeyError),\n/* harmony export */   MessageConversionError: () => (/* binding */ MessageConversionError),\n/* harmony export */   MistralStream: () => (/* binding */ MistralStream),\n/* harmony export */   NoContentGeneratedError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoContentGeneratedError),\n/* harmony export */   NoObjectGeneratedError: () => (/* binding */ NoObjectGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError),\n/* harmony export */   NoSuchProviderError: () => (/* binding */ NoSuchProviderError),\n/* harmony export */   NoSuchToolError: () => (/* binding */ NoSuchToolError),\n/* harmony export */   OpenAIStream: () => (/* binding */ OpenAIStream),\n/* harmony export */   ReplicateStream: () => (/* binding */ ReplicateStream),\n/* harmony export */   RetryError: () => (/* binding */ RetryError),\n/* harmony export */   StreamData: () => (/* binding */ StreamData2),\n/* harmony export */   StreamingTextResponse: () => (/* binding */ StreamingTextResponse),\n/* harmony export */   TypeValidationError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* reexport safe */ _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError),\n/* harmony export */   convertToCoreMessages: () => (/* binding */ convertToCoreMessages),\n/* harmony export */   cosineSimilarity: () => (/* binding */ cosineSimilarity),\n/* harmony export */   createCallbacksTransformer: () => (/* binding */ createCallbacksTransformer),\n/* harmony export */   createEventStreamTransformer: () => (/* binding */ createEventStreamTransformer),\n/* harmony export */   createStreamDataTransformer: () => (/* binding */ createStreamDataTransformer),\n/* harmony export */   embed: () => (/* binding */ embed),\n/* harmony export */   embedMany: () => (/* binding */ embedMany),\n/* harmony export */   experimental_AssistantResponse: () => (/* binding */ experimental_AssistantResponse),\n/* harmony export */   experimental_StreamData: () => (/* binding */ experimental_StreamData),\n/* harmony export */   experimental_createModelRegistry: () => (/* binding */ experimental_createModelRegistry),\n/* harmony export */   experimental_createProviderRegistry: () => (/* binding */ experimental_createProviderRegistry),\n/* harmony export */   experimental_customProvider: () => (/* binding */ experimental_customProvider),\n/* harmony export */   experimental_generateObject: () => (/* binding */ experimental_generateObject),\n/* harmony export */   experimental_generateText: () => (/* binding */ experimental_generateText),\n/* harmony export */   experimental_streamObject: () => (/* binding */ experimental_streamObject),\n/* harmony export */   experimental_streamText: () => (/* binding */ experimental_streamText),\n/* harmony export */   experimental_wrapLanguageModel: () => (/* binding */ experimental_wrapLanguageModel),\n/* harmony export */   formatStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart),\n/* harmony export */   generateId: () => (/* binding */ generateId2),\n/* harmony export */   generateObject: () => (/* binding */ generateObject),\n/* harmony export */   generateText: () => (/* binding */ generateText),\n/* harmony export */   jsonSchema: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.jsonSchema),\n/* harmony export */   nanoid: () => (/* binding */ nanoid),\n/* harmony export */   parseStreamPart: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parseStreamPart),\n/* harmony export */   processDataProtocolResponse: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* reexport safe */ _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.readDataStream),\n/* harmony export */   readableFromAsyncIterable: () => (/* binding */ readableFromAsyncIterable),\n/* harmony export */   streamObject: () => (/* binding */ streamObject),\n/* harmony export */   streamText: () => (/* binding */ streamText),\n/* harmony export */   streamToResponse: () => (/* binding */ streamToResponse),\n/* harmony export */   tool: () => (/* binding */ tool),\n/* harmony export */   trimStartOfStreamHelper: () => (/* binding */ trimStartOfStreamHelper)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @opentelemetry/api */ \"(rsc)/./node_modules/next/dist/compiled/@opentelemetry/api/index.js\");\n/* harmony import */ var zod__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! zod */ \"(rsc)/./node_modules/zod/lib/index.mjs\");\n/* harmony import */ var eventsource_parser__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! eventsource-parser */ \"(rsc)/./node_modules/eventsource-parser/dist/index.js\");\nvar __defProp = Object.defineProperty;\nvar __export = (target, all)=>{\n    for(var name11 in all)__defProp(target, name11, {\n        get: all[name11],\n        enumerable: true\n    });\n};\n// streams/index.ts\n\n\n// core/index.ts\n\n// util/retry-with-exponential-backoff.ts\n\n\n// util/delay.ts\nasync function delay(delayInMs) {\n    return delayInMs === void 0 ? Promise.resolve() : new Promise((resolve)=>setTimeout(resolve, delayInMs));\n}\n// util/retry-error.ts\n\nvar name = \"AI_RetryError\";\nvar marker = `vercel.ai.error.${name}`;\nvar symbol = Symbol.for(marker);\nvar _a;\nvar RetryError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ message, reason, errors }){\n        super({\n            name,\n            message\n        });\n        this[_a] = true;\n        this.reason = reason;\n        this.errors = errors;\n        this.lastError = errors[errors.length - 1];\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isRetryError(error) {\n        return error instanceof Error && error.name === name && typeof error.reason === \"string\" && Array.isArray(error.errors);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            reason: this.reason,\n            lastError: this.lastError,\n            errors: this.errors\n        };\n    }\n};\n_a = symbol;\n// util/retry-with-exponential-backoff.ts\nvar retryWithExponentialBackoff = ({ maxRetries = 2, initialDelayInMs = 2e3, backoffFactor = 2 } = {})=>async (f)=>_retryWithExponentialBackoff(f, {\n            maxRetries,\n            delayInMs: initialDelayInMs,\n            backoffFactor\n        });\nasync function _retryWithExponentialBackoff(f, { maxRetries, delayInMs, backoffFactor }, errors = []) {\n    try {\n        return await f();\n    } catch (error) {\n        if ((0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error)) {\n            throw error;\n        }\n        if (maxRetries === 0) {\n            throw error;\n        }\n        const errorMessage = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.getErrorMessage)(error);\n        const newErrors = [\n            ...errors,\n            error\n        ];\n        const tryNumber = newErrors.length;\n        if (tryNumber > maxRetries) {\n            throw new RetryError({\n                message: `Failed after ${tryNumber} attempts. Last error: ${errorMessage}`,\n                reason: \"maxRetriesExceeded\",\n                errors: newErrors\n            });\n        }\n        if (error instanceof Error && _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.APICallError.isAPICallError(error) && error.isRetryable === true && tryNumber <= maxRetries) {\n            await delay(delayInMs);\n            return _retryWithExponentialBackoff(f, {\n                maxRetries,\n                delayInMs: backoffFactor * delayInMs,\n                backoffFactor\n            }, newErrors);\n        }\n        if (tryNumber === 1) {\n            throw error;\n        }\n        throw new RetryError({\n            message: `Failed after ${tryNumber} attempts with non-retryable error: '${errorMessage}'`,\n            reason: \"errorNotRetryable\",\n            errors: newErrors\n        });\n    }\n}\n// core/telemetry/assemble-operation-name.ts\nfunction assembleOperationName({ operationId, telemetry }) {\n    return {\n        // standardized operation and resource name:\n        \"operation.name\": `${operationId}${(telemetry == null ? void 0 : telemetry.functionId) != null ? ` ${telemetry.functionId}` : \"\"}`,\n        \"resource.name\": telemetry == null ? void 0 : telemetry.functionId,\n        // detailed, AI SDK specific data:\n        \"ai.operationId\": operationId,\n        \"ai.telemetry.functionId\": telemetry == null ? void 0 : telemetry.functionId\n    };\n}\n// core/telemetry/get-base-telemetry-attributes.ts\nfunction getBaseTelemetryAttributes({ model, settings, telemetry, headers }) {\n    var _a11;\n    return {\n        \"ai.model.provider\": model.provider,\n        \"ai.model.id\": model.modelId,\n        // settings:\n        ...Object.entries(settings).reduce((attributes, [key, value])=>{\n            attributes[`ai.settings.${key}`] = value;\n            return attributes;\n        }, {}),\n        // add metadata as attributes:\n        ...Object.entries((_a11 = telemetry == null ? void 0 : telemetry.metadata) != null ? _a11 : {}).reduce((attributes, [key, value])=>{\n            attributes[`ai.telemetry.metadata.${key}`] = value;\n            return attributes;\n        }, {}),\n        // request headers\n        ...Object.entries(headers != null ? headers : {}).reduce((attributes, [key, value])=>{\n            if (value !== void 0) {\n                attributes[`ai.request.headers.${key}`] = value;\n            }\n            return attributes;\n        }, {})\n    };\n}\n// core/telemetry/get-tracer.ts\n\n// core/telemetry/noop-tracer.ts\nvar noopTracer = {\n    startSpan () {\n        return noopSpan;\n    },\n    startActiveSpan (name11, arg1, arg2, arg3) {\n        if (typeof arg1 === \"function\") {\n            return arg1(noopSpan);\n        }\n        if (typeof arg2 === \"function\") {\n            return arg2(noopSpan);\n        }\n        if (typeof arg3 === \"function\") {\n            return arg3(noopSpan);\n        }\n    }\n};\nvar noopSpan = {\n    spanContext () {\n        return noopSpanContext;\n    },\n    setAttribute () {\n        return this;\n    },\n    setAttributes () {\n        return this;\n    },\n    addEvent () {\n        return this;\n    },\n    addLink () {\n        return this;\n    },\n    addLinks () {\n        return this;\n    },\n    setStatus () {\n        return this;\n    },\n    updateName () {\n        return this;\n    },\n    end () {\n        return this;\n    },\n    isRecording () {\n        return false;\n    },\n    recordException () {\n        return this;\n    }\n};\nvar noopSpanContext = {\n    traceId: \"\",\n    spanId: \"\",\n    traceFlags: 0\n};\n// core/telemetry/get-tracer.ts\nfunction getTracer({ isEnabled = false, tracer } = {}) {\n    if (!isEnabled) {\n        return noopTracer;\n    }\n    if (tracer) {\n        return tracer;\n    }\n    return _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.trace.getTracer(\"ai\");\n}\n// core/telemetry/record-span.ts\n\nfunction recordSpan({ name: name11, tracer, attributes, fn, endWhenDone = true }) {\n    return tracer.startActiveSpan(name11, {\n        attributes\n    }, async (span)=>{\n        try {\n            const result = await fn(span);\n            if (endWhenDone) {\n                span.end();\n            }\n            return result;\n        } catch (error) {\n            try {\n                if (error instanceof Error) {\n                    span.recordException({\n                        name: error.name,\n                        message: error.message,\n                        stack: error.stack\n                    });\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR,\n                        message: error.message\n                    });\n                } else {\n                    span.setStatus({\n                        code: _opentelemetry_api__WEBPACK_IMPORTED_MODULE_2__.SpanStatusCode.ERROR\n                    });\n                }\n            } finally{\n                span.end();\n            }\n            throw error;\n        }\n    });\n}\n// core/telemetry/select-telemetry-attributes.ts\nfunction selectTelemetryAttributes({ telemetry, attributes }) {\n    if ((telemetry == null ? void 0 : telemetry.isEnabled) !== true) {\n        return {};\n    }\n    return Object.entries(attributes).reduce((attributes2, [key, value])=>{\n        if (value === void 0) {\n            return attributes2;\n        }\n        if (typeof value === \"object\" && \"input\" in value && typeof value.input === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordInputs) === false) {\n                return attributes2;\n            }\n            const result = value.input();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        if (typeof value === \"object\" && \"output\" in value && typeof value.output === \"function\") {\n            if ((telemetry == null ? void 0 : telemetry.recordOutputs) === false) {\n                return attributes2;\n            }\n            const result = value.output();\n            return result === void 0 ? attributes2 : {\n                ...attributes2,\n                [key]: result\n            };\n        }\n        return {\n            ...attributes2,\n            [key]: value\n        };\n    }, {});\n}\n// core/embed/embed.ts\nasync function embed({ model, value, maxRetries, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embed\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embed\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                \"ai.value\": {\n                    input: ()=>JSON.stringify(value)\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const { embedding, usage, rawResponse } = await retry(()=>// nested spans to align with the embedMany telemetry data:\n                recordSpan({\n                    name: \"ai.embed.doEmbed\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.embed.doEmbed\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            // specific settings that only make sense on the outer level:\n                            \"ai.values\": {\n                                input: ()=>[\n                                        JSON.stringify(value)\n                                    ]\n                            }\n                        }\n                    }),\n                    tracer,\n                    fn: async (doEmbedSpan)=>{\n                        var _a11;\n                        const modelResponse = await model.doEmbed({\n                            values: [\n                                value\n                            ],\n                            abortSignal,\n                            headers\n                        });\n                        const embedding2 = modelResponse.embeddings[0];\n                        const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                            tokens: NaN\n                        };\n                        doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.embeddings\": {\n                                    output: ()=>modelResponse.embeddings.map((embedding3)=>JSON.stringify(embedding3))\n                                },\n                                \"ai.usage.tokens\": usage2.tokens\n                            }\n                        }));\n                        return {\n                            embedding: embedding2,\n                            usage: usage2,\n                            rawResponse: modelResponse.rawResponse\n                        };\n                    }\n                }));\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embedding\": {\n                        output: ()=>JSON.stringify(embedding)\n                    },\n                    \"ai.usage.tokens\": usage.tokens\n                }\n            }));\n            return new DefaultEmbedResult({\n                value,\n                embedding,\n                usage,\n                rawResponse\n            });\n        }\n    });\n}\nvar DefaultEmbedResult = class {\n    constructor(options){\n        this.value = options.value;\n        this.embedding = options.embedding;\n        this.usage = options.usage;\n        this.rawResponse = options.rawResponse;\n    }\n};\n// core/util/split-array.ts\nfunction splitArray(array, chunkSize) {\n    if (chunkSize <= 0) {\n        throw new Error(\"chunkSize must be greater than 0\");\n    }\n    const result = [];\n    for(let i = 0; i < array.length; i += chunkSize){\n        result.push(array.slice(i, i + chunkSize));\n    }\n    return result;\n}\n// core/embed/embed-many.ts\nasync function embedMany({ model, values, maxRetries, abortSignal, headers, experimental_telemetry: telemetry }) {\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.embedMany\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.embedMany\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.values\": {\n                    input: ()=>values.map((value)=>JSON.stringify(value))\n                }\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const maxEmbeddingsPerCall = model.maxEmbeddingsPerCall;\n            if (maxEmbeddingsPerCall == null) {\n                const { embeddings: embeddings2, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>values.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a11;\n                            const modelResponse = await model.doEmbed({\n                                values,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings3 = modelResponse.embeddings;\n                            const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings3.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings3,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                span.setAttributes(selectTelemetryAttributes({\n                    telemetry,\n                    attributes: {\n                        \"ai.embeddings\": {\n                            output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                        },\n                        \"ai.usage.tokens\": usage.tokens\n                    }\n                }));\n                return new DefaultEmbedManyResult({\n                    values,\n                    embeddings: embeddings2,\n                    usage\n                });\n            }\n            const valueChunks = splitArray(values, maxEmbeddingsPerCall);\n            const embeddings = [];\n            let tokens = 0;\n            for (const chunk of valueChunks){\n                const { embeddings: responseEmbeddings, usage } = await retry(()=>{\n                    return recordSpan({\n                        name: \"ai.embedMany.doEmbed\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.embedMany.doEmbed\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                // specific settings that only make sense on the outer level:\n                                \"ai.values\": {\n                                    input: ()=>chunk.map((value)=>JSON.stringify(value))\n                                }\n                            }\n                        }),\n                        tracer,\n                        fn: async (doEmbedSpan)=>{\n                            var _a11;\n                            const modelResponse = await model.doEmbed({\n                                values: chunk,\n                                abortSignal,\n                                headers\n                            });\n                            const embeddings2 = modelResponse.embeddings;\n                            const usage2 = (_a11 = modelResponse.usage) != null ? _a11 : {\n                                tokens: NaN\n                            };\n                            doEmbedSpan.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.embeddings\": {\n                                        output: ()=>embeddings2.map((embedding)=>JSON.stringify(embedding))\n                                    },\n                                    \"ai.usage.tokens\": usage2.tokens\n                                }\n                            }));\n                            return {\n                                embeddings: embeddings2,\n                                usage: usage2\n                            };\n                        }\n                    });\n                });\n                embeddings.push(...responseEmbeddings);\n                tokens += usage.tokens;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.embeddings\": {\n                        output: ()=>embeddings.map((embedding)=>JSON.stringify(embedding))\n                    },\n                    \"ai.usage.tokens\": tokens\n                }\n            }));\n            return new DefaultEmbedManyResult({\n                values,\n                embeddings,\n                usage: {\n                    tokens\n                }\n            });\n        }\n    });\n}\nvar DefaultEmbedManyResult = class {\n    constructor(options){\n        this.values = options.values;\n        this.embeddings = options.embeddings;\n        this.usage = options.usage;\n    }\n};\n// core/generate-object/generate-object.ts\n\n// util/download-error.ts\n\nvar name2 = \"AI_DownloadError\";\nvar marker2 = `vercel.ai.error.${name2}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar DownloadError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ url, statusCode, statusText, cause, message = cause == null ? `Failed to download ${url}: ${statusCode} ${statusText}` : `Failed to download ${url}: ${cause}` }){\n        super({\n            name: name2,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.statusCode = statusCode;\n        this.statusText = statusText;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isDownloadError(error) {\n        return error instanceof Error && error.name === name2 && typeof error.url === \"string\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.statusText == null || typeof error.statusText === \"string\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            statusCode: this.statusCode,\n            statusText: this.statusText,\n            cause: this.cause\n        };\n    }\n};\n_a2 = symbol2;\n// util/download.ts\nasync function download({ url, fetchImplementation = fetch }) {\n    var _a11;\n    const urlText = url.toString();\n    try {\n        const response = await fetchImplementation(urlText);\n        if (!response.ok) {\n            throw new DownloadError({\n                url: urlText,\n                statusCode: response.status,\n                statusText: response.statusText\n            });\n        }\n        return {\n            data: new Uint8Array(await response.arrayBuffer()),\n            mimeType: (_a11 = response.headers.get(\"content-type\")) != null ? _a11 : void 0\n        };\n    } catch (error) {\n        if (DownloadError.isInstance(error)) {\n            throw error;\n        }\n        throw new DownloadError({\n            url: urlText,\n            cause: error\n        });\n    }\n}\n// core/util/detect-image-mimetype.ts\nvar mimeTypeSignatures = [\n    {\n        mimeType: \"image/gif\",\n        bytes: [\n            71,\n            73,\n            70\n        ]\n    },\n    {\n        mimeType: \"image/png\",\n        bytes: [\n            137,\n            80,\n            78,\n            71\n        ]\n    },\n    {\n        mimeType: \"image/jpeg\",\n        bytes: [\n            255,\n            216\n        ]\n    },\n    {\n        mimeType: \"image/webp\",\n        bytes: [\n            82,\n            73,\n            70,\n            70\n        ]\n    }\n];\nfunction detectImageMimeType(image) {\n    for (const { bytes, mimeType } of mimeTypeSignatures){\n        if (image.length >= bytes.length && bytes.every((byte, index)=>image[index] === byte)) {\n            return mimeType;\n        }\n    }\n    return void 0;\n}\n// core/prompt/data-content.ts\n\n// core/prompt/invalid-data-content-error.ts\n\nvar name3 = \"AI_InvalidDataContentError\";\nvar marker3 = `vercel.ai.error.${name3}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar InvalidDataContentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ content, cause, message = `Invalid data content. Expected a base64 string, Uint8Array, ArrayBuffer, or Buffer, but got ${typeof content}.` }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a3] = true;\n        this.content = content;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidDataContentError(error) {\n        return error instanceof Error && error.name === name3 && error.content != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            cause: this.cause,\n            content: this.content\n        };\n    }\n};\n_a3 = symbol3;\n// core/prompt/data-content.ts\n\nvar dataContentSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(Uint8Array),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(ArrayBuffer),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.custom(// Buffer might not be available in some environments such as CloudFlare:\n    (value)=>{\n        var _a11, _b;\n        return (_b = (_a11 = globalThis.Buffer) == null ? void 0 : _a11.isBuffer(value)) != null ? _b : false;\n    }, {\n        message: \"Must be a Buffer\"\n    })\n]);\nfunction convertDataContentToBase64String(content) {\n    if (typeof content === \"string\") {\n        return content;\n    }\n    if (content instanceof ArrayBuffer) {\n        return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(new Uint8Array(content));\n    }\n    return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertUint8ArrayToBase64)(content);\n}\nfunction convertDataContentToUint8Array(content) {\n    if (content instanceof Uint8Array) {\n        return content;\n    }\n    if (typeof content === \"string\") {\n        try {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.convertBase64ToUint8Array)(content);\n        } catch (error) {\n            throw new InvalidDataContentError({\n                message: \"Invalid data content. Content string is not a base64-encoded media.\",\n                content,\n                cause: error\n            });\n        }\n    }\n    if (content instanceof ArrayBuffer) {\n        return new Uint8Array(content);\n    }\n    throw new InvalidDataContentError({\n        content\n    });\n}\nfunction convertUint8ArrayToText(uint8Array) {\n    try {\n        return new TextDecoder().decode(uint8Array);\n    } catch (error) {\n        throw new Error(\"Error decoding Uint8Array to text\");\n    }\n}\n// core/prompt/invalid-message-role-error.ts\n\nvar name4 = \"AI_InvalidMessageRoleError\";\nvar marker4 = `vercel.ai.error.${name4}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidMessageRoleError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ role, message = `Invalid message role: '${role}'. Must be one of: \"system\", \"user\", \"assistant\", \"tool\".` }){\n        super({\n            name: name4,\n            message\n        });\n        this[_a4] = true;\n        this.role = role;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker4);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidMessageRoleError(error) {\n        return error instanceof Error && error.name === name4 && typeof error.role === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            role: this.role\n        };\n    }\n};\n_a4 = symbol4;\n// core/prompt/split-data-url.ts\nfunction splitDataUrl(dataUrl) {\n    try {\n        const [header, base64Content] = dataUrl.split(\",\");\n        return {\n            mimeType: header.split(\";\")[0].split(\":\")[1],\n            base64Content\n        };\n    } catch (error) {\n        return {\n            mimeType: void 0,\n            base64Content: void 0\n        };\n    }\n}\n// core/prompt/convert-to-language-model-prompt.ts\nasync function convertToLanguageModelPrompt({ prompt, modelSupportsImageUrls = true, modelSupportsUrl = ()=>false, downloadImplementation = download }) {\n    const downloadedAssets = await downloadAssets(prompt.messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl);\n    return [\n        ...prompt.system != null ? [\n            {\n                role: \"system\",\n                content: prompt.system\n            }\n        ] : [],\n        ...prompt.messages.map((message)=>convertToLanguageModelMessage(message, downloadedAssets))\n    ];\n}\nfunction convertToLanguageModelMessage(message, downloadedAssets) {\n    const role = message.role;\n    switch(role){\n        case \"system\":\n            {\n                return {\n                    role: \"system\",\n                    content: message.content,\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"user\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"user\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"user\",\n                    content: message.content.map((part)=>convertPartToLanguageModelPart(part, downloadedAssets)).filter((part)=>part.type !== \"text\" || part.text !== \"\"),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"assistant\":\n            {\n                if (typeof message.content === \"string\") {\n                    return {\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: message.content\n                            }\n                        ],\n                        providerMetadata: message.experimental_providerMetadata\n                    };\n                }\n                return {\n                    role: \"assistant\",\n                    content: message.content.filter(// remove empty text parts:\n                    (part)=>part.type !== \"text\" || part.text !== \"\").map((part)=>{\n                        const { experimental_providerMetadata, ...rest } = part;\n                        return {\n                            ...rest,\n                            providerMetadata: experimental_providerMetadata\n                        };\n                    }),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        case \"tool\":\n            {\n                return {\n                    role: \"tool\",\n                    content: message.content.map((part)=>({\n                            type: \"tool-result\",\n                            toolCallId: part.toolCallId,\n                            toolName: part.toolName,\n                            result: part.result,\n                            content: part.experimental_content,\n                            isError: part.isError,\n                            providerMetadata: part.experimental_providerMetadata\n                        })),\n                    providerMetadata: message.experimental_providerMetadata\n                };\n            }\n        default:\n            {\n                const _exhaustiveCheck = role;\n                throw new InvalidMessageRoleError({\n                    role: _exhaustiveCheck\n                });\n            }\n    }\n}\nasync function downloadAssets(messages, downloadImplementation, modelSupportsImageUrls, modelSupportsUrl) {\n    const urls = messages.filter((message)=>message.role === \"user\").map((message)=>message.content).filter((content)=>Array.isArray(content)).flat().filter((part)=>part.type === \"image\" || part.type === \"file\").filter((part)=>!(part.type === \"image\" && modelSupportsImageUrls === true)).map((part)=>part.type === \"image\" ? part.image : part.data).map((part)=>// support string urls:\n        typeof part === \"string\" && (part.startsWith(\"http:\") || part.startsWith(\"https:\")) ? new URL(part) : part).filter((image)=>image instanceof URL).filter((url)=>!modelSupportsUrl(url));\n    const downloadedImages = await Promise.all(urls.map(async (url)=>({\n            url,\n            data: await downloadImplementation({\n                url\n            })\n        })));\n    return Object.fromEntries(downloadedImages.map(({ url, data })=>[\n            url.toString(),\n            data\n        ]));\n}\nfunction convertPartToLanguageModelPart(part, downloadedAssets) {\n    if (part.type === \"text\") {\n        return {\n            type: \"text\",\n            text: part.text,\n            providerMetadata: part.experimental_providerMetadata\n        };\n    }\n    let mimeType = part.mimeType;\n    let data;\n    let content;\n    let normalizedData;\n    const type = part.type;\n    switch(type){\n        case \"image\":\n            data = part.image;\n            break;\n        case \"file\":\n            data = part.data;\n            break;\n        default:\n            throw new Error(`Unsupported part type: ${type}`);\n    }\n    try {\n        content = typeof data === \"string\" ? new URL(data) : data;\n    } catch (error) {\n        content = data;\n    }\n    if (content instanceof URL) {\n        if (content.protocol === \"data:\") {\n            const { mimeType: dataUrlMimeType, base64Content } = splitDataUrl(content.toString());\n            if (dataUrlMimeType == null || base64Content == null) {\n                throw new Error(`Invalid data URL format in part ${type}`);\n            }\n            mimeType = dataUrlMimeType;\n            normalizedData = convertDataContentToUint8Array(base64Content);\n        } else {\n            const downloadedFile = downloadedAssets[content.toString()];\n            if (downloadedFile) {\n                normalizedData = downloadedFile.data;\n                mimeType != null ? mimeType : mimeType = downloadedFile.mimeType;\n            } else {\n                normalizedData = content;\n            }\n        }\n    } else {\n        normalizedData = convertDataContentToUint8Array(content);\n    }\n    switch(type){\n        case \"image\":\n            if (mimeType == null && normalizedData instanceof Uint8Array) {\n                mimeType = detectImageMimeType(normalizedData);\n            }\n            return {\n                type: \"image\",\n                image: normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n        case \"file\":\n            if (mimeType == null) {\n                throw new Error(`Mime type is missing for file part`);\n            }\n            return {\n                type: \"file\",\n                data: normalizedData instanceof Uint8Array ? convertDataContentToBase64String(normalizedData) : normalizedData,\n                mimeType,\n                providerMetadata: part.experimental_providerMetadata\n            };\n    }\n}\n// errors/invalid-argument-error.ts\n\nvar name5 = \"AI_InvalidArgumentError\";\nvar marker5 = `vercel.ai.error.${name5}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidArgumentError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ parameter, value, message }){\n        super({\n            name: name5,\n            message: `Invalid argument for parameter ${parameter}: ${message}`\n        });\n        this[_a5] = true;\n        this.parameter = parameter;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidArgumentError(error) {\n        return error instanceof Error && error.name === name5 && typeof error.parameter === \"string\" && typeof error.value === \"string\";\n    }\n    toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            parameter: this.parameter,\n            value: this.value\n        };\n    }\n};\n_a5 = symbol5;\n// core/prompt/prepare-call-settings.ts\nfunction prepareCallSettings({ maxTokens, temperature, topP, topK, presencePenalty, frequencyPenalty, stopSequences, seed, maxRetries }) {\n    if (maxTokens != null) {\n        if (!Number.isInteger(maxTokens)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be an integer\"\n            });\n        }\n        if (maxTokens < 1) {\n            throw new InvalidArgumentError({\n                parameter: \"maxTokens\",\n                value: maxTokens,\n                message: \"maxTokens must be >= 1\"\n            });\n        }\n    }\n    if (temperature != null) {\n        if (typeof temperature !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"temperature\",\n                value: temperature,\n                message: \"temperature must be a number\"\n            });\n        }\n    }\n    if (topP != null) {\n        if (typeof topP !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topP\",\n                value: topP,\n                message: \"topP must be a number\"\n            });\n        }\n    }\n    if (topK != null) {\n        if (typeof topK !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"topK\",\n                value: topK,\n                message: \"topK must be a number\"\n            });\n        }\n    }\n    if (presencePenalty != null) {\n        if (typeof presencePenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"presencePenalty\",\n                value: presencePenalty,\n                message: \"presencePenalty must be a number\"\n            });\n        }\n    }\n    if (frequencyPenalty != null) {\n        if (typeof frequencyPenalty !== \"number\") {\n            throw new InvalidArgumentError({\n                parameter: \"frequencyPenalty\",\n                value: frequencyPenalty,\n                message: \"frequencyPenalty must be a number\"\n            });\n        }\n    }\n    if (seed != null) {\n        if (!Number.isInteger(seed)) {\n            throw new InvalidArgumentError({\n                parameter: \"seed\",\n                value: seed,\n                message: \"seed must be an integer\"\n            });\n        }\n    }\n    if (maxRetries != null) {\n        if (!Number.isInteger(maxRetries)) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be an integer\"\n            });\n        }\n        if (maxRetries < 0) {\n            throw new InvalidArgumentError({\n                parameter: \"maxRetries\",\n                value: maxRetries,\n                message: \"maxRetries must be >= 0\"\n            });\n        }\n    }\n    return {\n        maxTokens,\n        temperature: temperature != null ? temperature : 0,\n        topP,\n        topK,\n        presencePenalty,\n        frequencyPenalty,\n        stopSequences: stopSequences != null && stopSequences.length > 0 ? stopSequences : void 0,\n        seed,\n        maxRetries: maxRetries != null ? maxRetries : 2\n    };\n}\n// core/prompt/standardize-prompt.ts\n\n\n\n// core/prompt/message.ts\n\n// core/types/provider-metadata.ts\n\n// core/types/json-value.ts\n\nvar jsonValueSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.lazy(()=>zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.null(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.number(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.boolean(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.record(zod__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.array(jsonValueSchema)\n    ]));\n// core/types/provider-metadata.ts\nvar providerMetadataSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.record(zod__WEBPACK_IMPORTED_MODULE_3__.z.string(), zod__WEBPACK_IMPORTED_MODULE_3__.z.record(zod__WEBPACK_IMPORTED_MODULE_3__.z.string(), jsonValueSchema));\n// core/prompt/content-part.ts\n\n// core/prompt/tool-result-content.ts\n\nvar toolResultContentSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.array(zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n        text: zod__WEBPACK_IMPORTED_MODULE_3__.z.string()\n    }),\n    zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n        type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image\"),\n        data: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.z.string().optional()\n    })\n]));\n// core/prompt/content-part.ts\nvar textPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"text\"),\n    text: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar imagePartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"image\"),\n    image: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.z.string().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar filePartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"file\"),\n    data: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        dataContentSchema,\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.instanceof(URL)\n    ]),\n    mimeType: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar toolCallPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-call\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    args: zod__WEBPACK_IMPORTED_MODULE_3__.z.unknown()\n});\nvar toolResultPartSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    type: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool-result\"),\n    toolCallId: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    toolName: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    result: zod__WEBPACK_IMPORTED_MODULE_3__.z.unknown(),\n    content: toolResultContentSchema.optional(),\n    isError: zod__WEBPACK_IMPORTED_MODULE_3__.z.boolean().optional(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\n// core/prompt/message.ts\nvar coreSystemMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"system\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreUserMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"user\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.array(zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            textPartSchema,\n            imagePartSchema,\n            filePartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreAssistantMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"assistant\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.string(),\n        zod__WEBPACK_IMPORTED_MODULE_3__.z.array(zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n            textPartSchema,\n            toolCallPartSchema\n        ]))\n    ]),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreToolMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.object({\n    role: zod__WEBPACK_IMPORTED_MODULE_3__.z.literal(\"tool\"),\n    content: zod__WEBPACK_IMPORTED_MODULE_3__.z.array(toolResultPartSchema),\n    experimental_providerMetadata: providerMetadataSchema.optional()\n});\nvar coreMessageSchema = zod__WEBPACK_IMPORTED_MODULE_3__.z.union([\n    coreSystemMessageSchema,\n    coreUserMessageSchema,\n    coreAssistantMessageSchema,\n    coreToolMessageSchema\n]);\n// core/prompt/detect-prompt-type.ts\nfunction detectPromptType(prompt) {\n    if (!Array.isArray(prompt)) {\n        return \"other\";\n    }\n    if (prompt.length === 0) {\n        return \"messages\";\n    }\n    const characteristics = prompt.map(detectSingleMessageCharacteristics);\n    if (characteristics.some((c)=>c === \"has-ui-specific-parts\")) {\n        return \"ui-messages\";\n    } else if (characteristics.every((c)=>c === \"has-core-specific-parts\" || c === \"message\")) {\n        return \"messages\";\n    } else {\n        return \"other\";\n    }\n}\nfunction detectSingleMessageCharacteristics(message) {\n    if (typeof message === \"object\" && message !== null && (message.role === \"function\" || // UI-only role\n    message.role === \"data\" || // UI-only role\n    \"toolInvocations\" in message || // UI-specific field\n    \"experimental_attachments\" in message)) {\n        return \"has-ui-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"content\" in message && (Array.isArray(message.content) || // Core messages can have array content\n    \"experimental_providerMetadata\" in message)) {\n        return \"has-core-specific-parts\";\n    } else if (typeof message === \"object\" && message !== null && \"role\" in message && \"content\" in message && typeof message.content === \"string\" && [\n        \"system\",\n        \"user\",\n        \"assistant\",\n        \"tool\"\n    ].includes(message.role)) {\n        return \"message\";\n    } else {\n        return \"other\";\n    }\n}\n// core/prompt/attachments-to-parts.ts\nfunction attachmentsToParts(attachments) {\n    var _a11, _b, _c;\n    const parts = [];\n    for (const attachment of attachments){\n        let url;\n        try {\n            url = new URL(attachment.url);\n        } catch (error) {\n            throw new Error(`Invalid URL: ${attachment.url}`);\n        }\n        switch(url.protocol){\n            case \"http:\":\n            case \"https:\":\n                {\n                    if ((_a11 = attachment.contentType) == null ? void 0 : _a11.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: url\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: url,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            case \"data:\":\n                {\n                    let header;\n                    let base64Content;\n                    let mimeType;\n                    try {\n                        [header, base64Content] = attachment.url.split(\",\");\n                        mimeType = header.split(\";\")[0].split(\":\")[1];\n                    } catch (error) {\n                        throw new Error(`Error processing data URL: ${attachment.url}`);\n                    }\n                    if (mimeType == null || base64Content == null) {\n                        throw new Error(`Invalid data URL format: ${attachment.url}`);\n                    }\n                    if ((_b = attachment.contentType) == null ? void 0 : _b.startsWith(\"image/\")) {\n                        parts.push({\n                            type: \"image\",\n                            image: convertDataContentToUint8Array(base64Content)\n                        });\n                    } else if ((_c = attachment.contentType) == null ? void 0 : _c.startsWith(\"text/\")) {\n                        parts.push({\n                            type: \"text\",\n                            text: convertUint8ArrayToText(convertDataContentToUint8Array(base64Content))\n                        });\n                    } else {\n                        if (!attachment.contentType) {\n                            throw new Error(\"If the attachment is not an image or text, it must specify a content type\");\n                        }\n                        parts.push({\n                            type: \"file\",\n                            data: base64Content,\n                            mimeType: attachment.contentType\n                        });\n                    }\n                    break;\n                }\n            default:\n                {\n                    throw new Error(`Unsupported URL protocol: ${url.protocol}`);\n                }\n        }\n    }\n    return parts;\n}\n// core/prompt/message-conversion-error.ts\n\nvar name6 = \"AI_MessageConversionError\";\nvar marker6 = `vercel.ai.error.${name6}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar MessageConversionError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ originalMessage, message }){\n        super({\n            name: name6,\n            message\n        });\n        this[_a6] = true;\n        this.originalMessage = originalMessage;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker6);\n    }\n};\n_a6 = symbol6;\n// core/prompt/convert-to-core-messages.ts\nfunction convertToCoreMessages(messages, options) {\n    var _a11;\n    const tools = (_a11 = options == null ? void 0 : options.tools) != null ? _a11 : {};\n    const coreMessages = [];\n    for (const message of messages){\n        const { role, content, toolInvocations, experimental_attachments } = message;\n        switch(role){\n            case \"system\":\n                {\n                    coreMessages.push({\n                        role: \"system\",\n                        content\n                    });\n                    break;\n                }\n            case \"user\":\n                {\n                    coreMessages.push({\n                        role: \"user\",\n                        content: experimental_attachments ? [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...attachmentsToParts(experimental_attachments)\n                        ] : content\n                    });\n                    break;\n                }\n            case \"assistant\":\n                {\n                    if (toolInvocations == null) {\n                        coreMessages.push({\n                            role: \"assistant\",\n                            content\n                        });\n                        break;\n                    }\n                    coreMessages.push({\n                        role: \"assistant\",\n                        content: [\n                            {\n                                type: \"text\",\n                                text: content\n                            },\n                            ...toolInvocations.map(({ toolCallId, toolName, args })=>({\n                                    type: \"tool-call\",\n                                    toolCallId,\n                                    toolName,\n                                    args\n                                }))\n                        ]\n                    });\n                    coreMessages.push({\n                        role: \"tool\",\n                        content: toolInvocations.map((toolInvocation)=>{\n                            if (!(\"result\" in toolInvocation)) {\n                                throw new MessageConversionError({\n                                    originalMessage: message,\n                                    message: \"ToolInvocation must have a result: \" + JSON.stringify(toolInvocation)\n                                });\n                            }\n                            const { toolCallId, toolName, result } = toolInvocation;\n                            const tool2 = tools[toolName];\n                            return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result: tool2.experimental_toToolResultContent(result),\n                                experimental_content: tool2.experimental_toToolResultContent(result)\n                            } : {\n                                type: \"tool-result\",\n                                toolCallId,\n                                toolName,\n                                result\n                            };\n                        })\n                    });\n                    break;\n                }\n            case \"function\":\n            case \"data\":\n            case \"tool\":\n                {\n                    break;\n                }\n            default:\n                {\n                    const _exhaustiveCheck = role;\n                    throw new MessageConversionError({\n                        originalMessage: message,\n                        message: `Unsupported role: ${_exhaustiveCheck}`\n                    });\n                }\n        }\n    }\n    return coreMessages;\n}\n// core/prompt/standardize-prompt.ts\nfunction standardizePrompt({ prompt, tools }) {\n    if (prompt.prompt == null && prompt.messages == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt or messages must be defined\"\n        });\n    }\n    if (prompt.prompt != null && prompt.messages != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"prompt and messages cannot be defined at the same time\"\n        });\n    }\n    if (prompt.system != null && typeof prompt.system !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n            prompt,\n            message: \"system must be a string\"\n        });\n    }\n    if (prompt.prompt != null) {\n        if (typeof prompt.prompt !== \"string\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"prompt must be a string\"\n            });\n        }\n        return {\n            type: \"prompt\",\n            system: prompt.system,\n            messages: [\n                {\n                    role: \"user\",\n                    content: prompt.prompt\n                }\n            ]\n        };\n    }\n    if (prompt.messages != null) {\n        const promptType = detectPromptType(prompt.messages);\n        if (promptType === \"other\") {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\"\n            });\n        }\n        const messages = promptType === \"ui-messages\" ? convertToCoreMessages(prompt.messages, {\n            tools\n        }) : prompt.messages;\n        const validationResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n            value: messages,\n            schema: zod__WEBPACK_IMPORTED_MODULE_3__.z.array(coreMessageSchema)\n        });\n        if (!validationResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.InvalidPromptError({\n                prompt,\n                message: \"messages must be an array of CoreMessage or UIMessage\",\n                cause: validationResult.error\n            });\n        }\n        return {\n            type: \"messages\",\n            messages,\n            system: prompt.system\n        };\n    }\n    throw new Error(\"unreachable\");\n}\n// core/types/usage.ts\nfunction calculateLanguageModelUsage(usage) {\n    return {\n        promptTokens: usage.promptTokens,\n        completionTokens: usage.completionTokens,\n        totalTokens: usage.promptTokens + usage.completionTokens\n    };\n}\n// core/util/prepare-response-headers.ts\nfunction prepareResponseHeaders(init, { contentType, dataStreamVersion }) {\n    var _a11;\n    const headers = new Headers((_a11 = init == null ? void 0 : init.headers) != null ? _a11 : {});\n    if (!headers.has(\"Content-Type\")) {\n        headers.set(\"Content-Type\", contentType);\n    }\n    if (dataStreamVersion !== void 0) {\n        headers.set(\"X-Vercel-AI-Data-Stream\", dataStreamVersion);\n    }\n    return headers;\n}\n// core/generate-object/inject-json-instruction.ts\nvar DEFAULT_SCHEMA_PREFIX = \"JSON schema:\";\nvar DEFAULT_SCHEMA_SUFFIX = \"You MUST answer with a JSON object that matches the JSON schema above.\";\nvar DEFAULT_GENERIC_SUFFIX = \"You MUST answer with JSON.\";\nfunction injectJsonInstruction({ prompt, schema, schemaPrefix = schema != null ? DEFAULT_SCHEMA_PREFIX : void 0, schemaSuffix = schema != null ? DEFAULT_SCHEMA_SUFFIX : DEFAULT_GENERIC_SUFFIX }) {\n    return [\n        prompt != null && prompt.length > 0 ? prompt : void 0,\n        prompt != null && prompt.length > 0 ? \"\" : void 0,\n        // add a newline if prompt is not null\n        schemaPrefix,\n        schema != null ? JSON.stringify(schema) : void 0,\n        schemaSuffix\n    ].filter((line)=>line != null).join(\"\\n\");\n}\n// core/generate-object/no-object-generated-error.ts\n\nvar name7 = \"AI_NoObjectGeneratedError\";\nvar marker7 = `vercel.ai.error.${name7}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar NoObjectGeneratedError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    // used in isInstance\n    constructor({ message = \"No object generated.\" } = {}){\n        super({\n            name: name7,\n            message\n        });\n        this[_a7] = true;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isNoObjectGeneratedError(error) {\n        return error instanceof Error && error.name === name7;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            cause: this.cause,\n            message: this.message,\n            stack: this.stack\n        };\n    }\n};\n_a7 = symbol7;\n// core/generate-object/output-strategy.ts\n\n\n\n// core/util/async-iterable-stream.ts\nfunction createAsyncIterableStream(source, transformer) {\n    const transformedStream = source.pipeThrough(new TransformStream(transformer));\n    transformedStream[Symbol.asyncIterator] = ()=>{\n        const reader = transformedStream.getReader();\n        return {\n            async next () {\n                const { done, value } = await reader.read();\n                return done ? {\n                    done: true,\n                    value: void 0\n                } : {\n                    done: false,\n                    value\n                };\n            }\n        };\n    };\n    return transformedStream;\n}\n// core/generate-object/output-strategy.ts\nvar noSchemaOutputStrategy = {\n    type: \"no-schema\",\n    jsonSchema: void 0,\n    validatePartialResult ({ value, textDelta }) {\n        return {\n            success: true,\n            value: {\n                partial: value,\n                textDelta\n            }\n        };\n    },\n    validateFinalResult (value) {\n        return value === void 0 ? {\n            success: false,\n            error: new NoObjectGeneratedError()\n        } : {\n            success: true,\n            value\n        };\n    },\n    createElementStream () {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n            functionality: \"element streams in no-schema mode\"\n        });\n    }\n};\nvar objectOutputStrategy = (schema)=>({\n        type: \"object\",\n        jsonSchema: schema.jsonSchema,\n        validatePartialResult ({ value, textDelta }) {\n            return {\n                success: true,\n                value: {\n                    // Note: currently no validation of partial results:\n                    partial: value,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            return (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                value,\n                schema\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in object mode\"\n            });\n        }\n    });\nvar arrayOutputStrategy = (schema)=>{\n    const { $schema, ...itemSchema } = schema.jsonSchema;\n    return {\n        type: \"enum\",\n        // wrap in object that contains array of elements, since most LLMs will not\n        // be able to generate an array directly:\n        // possible future optimization: use arrays directly when model supports grammar-guided generation\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                elements: {\n                    type: \"array\",\n                    items: itemSchema\n                }\n            },\n            required: [\n                \"elements\"\n            ],\n            additionalProperties: false\n        },\n        validatePartialResult ({ value, latestObject, isFirstDelta, isFinalDelta }) {\n            var _a11;\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            const resultArray = [];\n            for(let i = 0; i < inputArray.length; i++){\n                const element = inputArray[i];\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (i === inputArray.length - 1 && !isFinalDelta) {\n                    continue;\n                }\n                if (!result.success) {\n                    return result;\n                }\n                resultArray.push(result.value);\n            }\n            const publishedElementCount = (_a11 = latestObject == null ? void 0 : latestObject.length) != null ? _a11 : 0;\n            let textDelta = \"\";\n            if (isFirstDelta) {\n                textDelta += \"[\";\n            }\n            if (publishedElementCount > 0) {\n                textDelta += \",\";\n            }\n            textDelta += resultArray.slice(publishedElementCount).map((element)=>JSON.stringify(element)).join(\",\");\n            if (isFinalDelta) {\n                textDelta += \"]\";\n            }\n            return {\n                success: true,\n                value: {\n                    partial: resultArray,\n                    textDelta\n                }\n            };\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || !(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONArray)(value.elements)) {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: \"value must be an object that contains an array of elements\"\n                    })\n                };\n            }\n            const inputArray = value.elements;\n            for (const element of inputArray){\n                const result = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                    value: element,\n                    schema\n                });\n                if (!result.success) {\n                    return result;\n                }\n            }\n            return {\n                success: true,\n                value: inputArray\n            };\n        },\n        createElementStream (originalStream) {\n            let publishedElements = 0;\n            return createAsyncIterableStream(originalStream, {\n                transform (chunk, controller) {\n                    switch(chunk.type){\n                        case \"object\":\n                            {\n                                const array = chunk.object;\n                                for(; publishedElements < array.length; publishedElements++){\n                                    controller.enqueue(array[publishedElements]);\n                                }\n                                break;\n                            }\n                        case \"text-delta\":\n                        case \"finish\":\n                            break;\n                        case \"error\":\n                            controller.error(chunk.error);\n                            break;\n                        default:\n                            {\n                                const _exhaustiveCheck = chunk;\n                                throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                            }\n                    }\n                }\n            });\n        }\n    };\n};\nvar enumOutputStrategy = (enumValues)=>{\n    return {\n        type: \"enum\",\n        // wrap in object that contains result, since most LLMs will not\n        // be able to generate an enum value directly:\n        // possible future optimization: use enums directly when model supports top-level enums\n        jsonSchema: {\n            $schema: \"http://json-schema.org/draft-07/schema#\",\n            type: \"object\",\n            properties: {\n                result: {\n                    type: \"string\",\n                    enum: enumValues\n                }\n            },\n            required: [\n                \"result\"\n            ],\n            additionalProperties: false\n        },\n        validateFinalResult (value) {\n            if (!(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.isJSONObject)(value) || typeof value.result !== \"string\") {\n                return {\n                    success: false,\n                    error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                        value,\n                        cause: 'value must be an object that contains a string in the \"result\" property.'\n                    })\n                };\n            }\n            const result = value.result;\n            return enumValues.includes(result) ? {\n                success: true,\n                value: result\n            } : {\n                success: false,\n                error: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.TypeValidationError({\n                    value,\n                    cause: \"value must be a string in the enum\"\n                })\n            };\n        },\n        validatePartialResult () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"partial results in enum mode\"\n            });\n        },\n        createElementStream () {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.UnsupportedFunctionalityError({\n                functionality: \"element streams in enum mode\"\n            });\n        }\n    };\n};\nfunction getOutputStrategy({ output, schema, enumValues }) {\n    switch(output){\n        case \"object\":\n            return objectOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema));\n        case \"array\":\n            return arrayOutputStrategy((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(schema));\n        case \"enum\":\n            return enumOutputStrategy(enumValues);\n        case \"no-schema\":\n            return noSchemaOutputStrategy;\n        default:\n            {\n                const _exhaustiveCheck = output;\n                throw new Error(`Unsupported output: ${_exhaustiveCheck}`);\n            }\n    }\n}\n// core/generate-object/validate-object-generation-input.ts\nfunction validateObjectGenerationInput({ output, mode, schema, schemaName, schemaDescription, enumValues }) {\n    if (output != null && output !== \"object\" && output !== \"array\" && output !== \"enum\" && output !== \"no-schema\") {\n        throw new InvalidArgumentError({\n            parameter: \"output\",\n            value: output,\n            message: \"Invalid output type.\"\n        });\n    }\n    if (output === \"no-schema\") {\n        if (mode === \"auto\" || mode === \"tool\") {\n            throw new InvalidArgumentError({\n                parameter: \"mode\",\n                value: mode,\n                message: 'Mode must be \"json\" for no-schema output.'\n            });\n        }\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for no-schema output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for no-schema output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for no-schema output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for no-schema output.\"\n            });\n        }\n    }\n    if (output === \"object\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is required for object output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for object output.\"\n            });\n        }\n    }\n    if (output === \"array\") {\n        if (schema == null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Element schema is required for array output.\"\n            });\n        }\n        if (enumValues != null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are not supported for array output.\"\n            });\n        }\n    }\n    if (output === \"enum\") {\n        if (schema != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schema\",\n                value: schema,\n                message: \"Schema is not supported for enum output.\"\n            });\n        }\n        if (schemaDescription != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaDescription\",\n                value: schemaDescription,\n                message: \"Schema description is not supported for enum output.\"\n            });\n        }\n        if (schemaName != null) {\n            throw new InvalidArgumentError({\n                parameter: \"schemaName\",\n                value: schemaName,\n                message: \"Schema name is not supported for enum output.\"\n            });\n        }\n        if (enumValues == null) {\n            throw new InvalidArgumentError({\n                parameter: \"enumValues\",\n                value: enumValues,\n                message: \"Enum values are required for enum output.\"\n            });\n        }\n        for (const value of enumValues){\n            if (typeof value !== \"string\") {\n                throw new InvalidArgumentError({\n                    parameter: \"enumValues\",\n                    value,\n                    message: \"Enum values must be strings.\"\n                });\n            }\n        }\n    }\n}\n// core/generate-object/generate-object.ts\nvar originalGenerateId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function generateObject({ model, enum: enumValues, // rename bc enum is reserved by typescript\nschema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, _internal: { generateId: generateId3 = originalGenerateId, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription,\n        enumValues\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema,\n        enumValues\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a11, _b;\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let result;\n            let finishReason;\n            let usage;\n            let warnings;\n            let rawResponse;\n            let response;\n            let request;\n            let logprobs;\n            let resultProviderMetadata;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>standardizedPrompt.type\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a12, _b2, _c, _d, _e, _f;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-json\",\n                                            schema: outputStrategy.jsonSchema,\n                                            name: schemaName,\n                                            description: schemaDescription\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat: standardizedPrompt.type,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    if (result2.text === void 0) {\n                                        throw new NoObjectGeneratedError();\n                                    }\n                                    const responseData = {\n                                        id: (_b2 = (_a12 = result2.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                                        timestamp: (_d = (_c = result2.response) == null ? void 0 : _c.timestamp) != null ? _d : currentDate(),\n                                        modelId: (_f = (_e = result2.response) == null ? void 0 : _e.modelId) != null ? _f : model.modelId\n                                    };\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // deprecated:\n                                            \"ai.finishReason\": result2.finishReason,\n                                            \"ai.result.object\": {\n                                                output: ()=>result2.text\n                                            },\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.prompt_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.completion_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText: result2.text,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_a11 = generateResult.request) != null ? _a11 : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        const promptMessages = await convertToLanguageModelPrompt({\n                            prompt: standardizedPrompt,\n                            modelSupportsImageUrls: model.supportsImageUrls,\n                            modelSupportsUrl: model.supportsUrl\n                        });\n                        const inputFormat = standardizedPrompt.type;\n                        const generateResult = await retry(()=>recordSpan({\n                                name: \"ai.generateObject.doGenerate\",\n                                attributes: selectTelemetryAttributes({\n                                    telemetry,\n                                    attributes: {\n                                        ...assembleOperationName({\n                                            operationId: \"ai.generateObject.doGenerate\",\n                                            telemetry\n                                        }),\n                                        ...baseTelemetryAttributes,\n                                        \"ai.prompt.format\": {\n                                            input: ()=>inputFormat\n                                        },\n                                        \"ai.prompt.messages\": {\n                                            input: ()=>JSON.stringify(promptMessages)\n                                        },\n                                        \"ai.settings.mode\": mode,\n                                        // standardized gen-ai llm span attributes:\n                                        \"gen_ai.system\": model.provider,\n                                        \"gen_ai.request.model\": model.modelId,\n                                        \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                        \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                        \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                        \"gen_ai.request.temperature\": settings.temperature,\n                                        \"gen_ai.request.top_k\": settings.topK,\n                                        \"gen_ai.request.top_p\": settings.topP\n                                    }\n                                }),\n                                tracer,\n                                fn: async (span2)=>{\n                                    var _a12, _b2, _c, _d, _e, _f, _g, _h;\n                                    const result2 = await model.doGenerate({\n                                        mode: {\n                                            type: \"object-tool\",\n                                            tool: {\n                                                type: \"function\",\n                                                name: schemaName != null ? schemaName : \"json\",\n                                                description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                                parameters: outputStrategy.jsonSchema\n                                            }\n                                        },\n                                        ...prepareCallSettings(settings),\n                                        inputFormat,\n                                        prompt: promptMessages,\n                                        providerMetadata,\n                                        abortSignal,\n                                        headers\n                                    });\n                                    const objectText = (_b2 = (_a12 = result2.toolCalls) == null ? void 0 : _a12[0]) == null ? void 0 : _b2.args;\n                                    if (objectText === void 0) {\n                                        throw new NoObjectGeneratedError();\n                                    }\n                                    const responseData = {\n                                        id: (_d = (_c = result2.response) == null ? void 0 : _c.id) != null ? _d : generateId3(),\n                                        timestamp: (_f = (_e = result2.response) == null ? void 0 : _e.timestamp) != null ? _f : currentDate(),\n                                        modelId: (_h = (_g = result2.response) == null ? void 0 : _g.modelId) != null ? _h : model.modelId\n                                    };\n                                    span2.setAttributes(selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            \"ai.response.finishReason\": result2.finishReason,\n                                            \"ai.response.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            \"ai.response.id\": responseData.id,\n                                            \"ai.response.model\": responseData.modelId,\n                                            \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                            \"ai.usage.promptTokens\": result2.usage.promptTokens,\n                                            \"ai.usage.completionTokens\": result2.usage.completionTokens,\n                                            // deprecated:\n                                            \"ai.finishReason\": result2.finishReason,\n                                            \"ai.result.object\": {\n                                                output: ()=>objectText\n                                            },\n                                            // standardized gen-ai llm span attributes:\n                                            \"gen_ai.response.finish_reasons\": [\n                                                result2.finishReason\n                                            ],\n                                            \"gen_ai.response.id\": responseData.id,\n                                            \"gen_ai.response.model\": responseData.modelId,\n                                            \"gen_ai.usage.input_tokens\": result2.usage.promptTokens,\n                                            \"gen_ai.usage.output_tokens\": result2.usage.completionTokens\n                                        }\n                                    }));\n                                    return {\n                                        ...result2,\n                                        objectText,\n                                        responseData\n                                    };\n                                }\n                            }));\n                        result = generateResult.objectText;\n                        finishReason = generateResult.finishReason;\n                        usage = generateResult.usage;\n                        warnings = generateResult.warnings;\n                        rawResponse = generateResult.rawResponse;\n                        logprobs = generateResult.logprobs;\n                        resultProviderMetadata = generateResult.providerMetadata;\n                        request = (_b = generateResult.request) != null ? _b : {};\n                        response = generateResult.responseData;\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const parseResult = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n                text: result\n            });\n            if (!parseResult.success) {\n                throw parseResult.error;\n            }\n            const validationResult = outputStrategy.validateFinalResult(parseResult.value);\n            if (!validationResult.success) {\n                throw validationResult.error;\n            }\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": finishReason,\n                    \"ai.response.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    },\n                    \"ai.usage.promptTokens\": usage.promptTokens,\n                    \"ai.usage.completionTokens\": usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": finishReason,\n                    \"ai.result.object\": {\n                        output: ()=>JSON.stringify(validationResult.value)\n                    }\n                }\n            }));\n            return new DefaultGenerateObjectResult({\n                object: validationResult.value,\n                finishReason,\n                usage: calculateLanguageModelUsage(usage),\n                warnings,\n                request,\n                response: {\n                    ...response,\n                    headers: rawResponse == null ? void 0 : rawResponse.headers\n                },\n                logprobs,\n                providerMetadata: resultProviderMetadata\n            });\n        }\n    });\n}\nvar DefaultGenerateObjectResult = class {\n    constructor(options){\n        this.object = options.object;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.response = options.response;\n        this.request = options.request;\n        this.rawResponse = {\n            headers: options.response.headers\n        };\n        this.logprobs = options.logprobs;\n    }\n    toJsonResponse(init) {\n        var _a11;\n        return new Response(JSON.stringify(this.object), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"application/json; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_generateObject = generateObject;\n// core/generate-object/stream-object.ts\n\n\n// util/create-resolvable-promise.ts\nfunction createResolvablePromise() {\n    let resolve;\n    let reject;\n    const promise = new Promise((res, rej)=>{\n        resolve = res;\n        reject = rej;\n    });\n    return {\n        promise,\n        resolve,\n        reject\n    };\n}\n// util/delayed-promise.ts\nvar DelayedPromise = class {\n    constructor(){\n        this.status = {\n            type: \"pending\"\n        };\n        this._resolve = void 0;\n        this._reject = void 0;\n    }\n    get value() {\n        if (this.promise) {\n            return this.promise;\n        }\n        this.promise = new Promise((resolve, reject)=>{\n            if (this.status.type === \"resolved\") {\n                resolve(this.status.value);\n            } else if (this.status.type === \"rejected\") {\n                reject(this.status.error);\n            }\n            this._resolve = resolve;\n            this._reject = reject;\n        });\n        return this.promise;\n    }\n    resolve(value) {\n        var _a11;\n        this.status = {\n            type: \"resolved\",\n            value\n        };\n        if (this.promise) {\n            (_a11 = this._resolve) == null ? void 0 : _a11.call(this, value);\n        }\n    }\n    reject(error) {\n        var _a11;\n        this.status = {\n            type: \"rejected\",\n            error\n        };\n        if (this.promise) {\n            (_a11 = this._reject) == null ? void 0 : _a11.call(this, error);\n        }\n    }\n};\n// core/util/now.ts\nfunction now() {\n    var _a11, _b;\n    return (_b = (_a11 = globalThis == null ? void 0 : globalThis.performance) == null ? void 0 : _a11.now()) != null ? _b : Date.now();\n}\n// core/util/prepare-outgoing-http-headers.ts\nfunction prepareOutgoingHttpHeaders(init, { contentType, dataStreamVersion }) {\n    const headers = {};\n    if ((init == null ? void 0 : init.headers) != null) {\n        for (const [key, value] of Object.entries(init.headers)){\n            headers[key] = value;\n        }\n    }\n    if (headers[\"Content-Type\"] == null) {\n        headers[\"Content-Type\"] = contentType;\n    }\n    if (dataStreamVersion !== void 0) {\n        headers[\"X-Vercel-AI-Data-Stream\"] = dataStreamVersion;\n    }\n    return headers;\n}\n// core/util/write-to-server-response.ts\nfunction writeToServerResponse({ response, status, statusText, headers, stream }) {\n    response.writeHead(status != null ? status : 200, statusText, headers);\n    const reader = stream.getReader();\n    const read = async ()=>{\n        try {\n            while(true){\n                const { done, value } = await reader.read();\n                if (done) break;\n                response.write(value);\n            }\n        } catch (error) {\n            throw error;\n        } finally{\n            response.end();\n        }\n    };\n    read();\n}\n// core/generate-object/stream-object.ts\nvar originalGenerateId2 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aiobj\",\n    size: 24\n});\nasync function streamObject({ model, schema: inputSchema, schemaName, schemaDescription, mode, output = \"object\", system, prompt, messages, maxRetries, abortSignal, headers, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, onFinish, _internal: { generateId: generateId3 = originalGenerateId2, currentDate = ()=>/* @__PURE__ */ new Date(), now: now2 = now } = {}, ...settings }) {\n    validateObjectGenerationInput({\n        output,\n        mode,\n        schema: inputSchema,\n        schemaName,\n        schemaDescription\n    });\n    const outputStrategy = getOutputStrategy({\n        output,\n        schema: inputSchema\n    });\n    if (outputStrategy.type === \"no-schema\" && mode === void 0) {\n        mode = \"json\";\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const retry = retryWithExponentialBackoff({\n        maxRetries\n    });\n    return recordSpan({\n        name: \"ai.streamObject\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.streamObject\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.schema\": outputStrategy.jsonSchema != null ? {\n                    input: ()=>JSON.stringify(outputStrategy.jsonSchema)\n                } : void 0,\n                \"ai.schema.name\": schemaName,\n                \"ai.schema.description\": schemaDescription,\n                \"ai.settings.output\": outputStrategy.type,\n                \"ai.settings.mode\": mode\n            }\n        }),\n        tracer,\n        endWhenDone: false,\n        fn: async (rootSpan)=>{\n            if (mode === \"auto\" || mode == null) {\n                mode = model.defaultObjectGenerationMode;\n            }\n            let callOptions;\n            let transformer;\n            switch(mode){\n                case \"json\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system: outputStrategy.jsonSchema == null ? injectJsonInstruction({\n                                    prompt: system\n                                }) : model.supportsStructuredOutputs ? system : injectJsonInstruction({\n                                    prompt: system,\n                                    schema: outputStrategy.jsonSchema\n                                }),\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        callOptions = {\n                            mode: {\n                                type: \"object-json\",\n                                schema: outputStrategy.jsonSchema,\n                                name: schemaName,\n                                description: schemaDescription\n                            },\n                            ...prepareCallSettings(settings),\n                            inputFormat: standardizedPrompt.type,\n                            prompt: await convertToLanguageModelPrompt({\n                                prompt: standardizedPrompt,\n                                modelSupportsImageUrls: model.supportsImageUrls,\n                                modelSupportsUrl: model.supportsUrl\n                            }),\n                            providerMetadata,\n                            abortSignal,\n                            headers\n                        };\n                        transformer = {\n                            transform: (chunk, controller)=>{\n                                switch(chunk.type){\n                                    case \"text-delta\":\n                                        controller.enqueue(chunk.textDelta);\n                                        break;\n                                    case \"response-metadata\":\n                                    case \"finish\":\n                                    case \"error\":\n                                        controller.enqueue(chunk);\n                                        break;\n                                }\n                            }\n                        };\n                        break;\n                    }\n                case \"tool\":\n                    {\n                        const standardizedPrompt = standardizePrompt({\n                            prompt: {\n                                system,\n                                prompt,\n                                messages\n                            },\n                            tools: void 0\n                        });\n                        callOptions = {\n                            mode: {\n                                type: \"object-tool\",\n                                tool: {\n                                    type: \"function\",\n                                    name: schemaName != null ? schemaName : \"json\",\n                                    description: schemaDescription != null ? schemaDescription : \"Respond with a JSON object.\",\n                                    parameters: outputStrategy.jsonSchema\n                                }\n                            },\n                            ...prepareCallSettings(settings),\n                            inputFormat: standardizedPrompt.type,\n                            prompt: await convertToLanguageModelPrompt({\n                                prompt: standardizedPrompt,\n                                modelSupportsImageUrls: model.supportsImageUrls,\n                                modelSupportsUrl: model.supportsUrl\n                            }),\n                            providerMetadata,\n                            abortSignal,\n                            headers\n                        };\n                        transformer = {\n                            transform (chunk, controller) {\n                                switch(chunk.type){\n                                    case \"tool-call-delta\":\n                                        controller.enqueue(chunk.argsTextDelta);\n                                        break;\n                                    case \"response-metadata\":\n                                    case \"finish\":\n                                    case \"error\":\n                                        controller.enqueue(chunk);\n                                        break;\n                                }\n                            }\n                        };\n                        break;\n                    }\n                case void 0:\n                    {\n                        throw new Error(\"Model does not have a default object generation mode.\");\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = mode;\n                        throw new Error(`Unsupported mode: ${_exhaustiveCheck}`);\n                    }\n            }\n            const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await retry(()=>recordSpan({\n                    name: \"ai.streamObject.doStream\",\n                    attributes: selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            ...assembleOperationName({\n                                operationId: \"ai.streamObject.doStream\",\n                                telemetry\n                            }),\n                            ...baseTelemetryAttributes,\n                            \"ai.prompt.format\": {\n                                input: ()=>callOptions.inputFormat\n                            },\n                            \"ai.prompt.messages\": {\n                                input: ()=>JSON.stringify(callOptions.prompt)\n                            },\n                            \"ai.settings.mode\": mode,\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.system\": model.provider,\n                            \"gen_ai.request.model\": model.modelId,\n                            \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                            \"gen_ai.request.max_tokens\": settings.maxTokens,\n                            \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                            \"gen_ai.request.temperature\": settings.temperature,\n                            \"gen_ai.request.top_k\": settings.topK,\n                            \"gen_ai.request.top_p\": settings.topP\n                        }\n                    }),\n                    tracer,\n                    endWhenDone: false,\n                    fn: async (doStreamSpan2)=>({\n                            startTimestampMs: now2(),\n                            doStreamSpan: doStreamSpan2,\n                            result: await model.doStream(callOptions)\n                        })\n                }));\n            return new DefaultStreamObjectResult({\n                outputStrategy,\n                stream: stream.pipeThrough(new TransformStream(transformer)),\n                warnings,\n                rawResponse,\n                request: request != null ? request : {},\n                onFinish,\n                rootSpan,\n                doStreamSpan,\n                telemetry,\n                startTimestampMs,\n                modelId: model.modelId,\n                now: now2,\n                currentDate,\n                generateId: generateId3\n            });\n        }\n    });\n}\nvar DefaultStreamObjectResult = class {\n    constructor({ stream, warnings, rawResponse, request, outputStrategy, onFinish, rootSpan, doStreamSpan, telemetry, startTimestampMs, modelId, now: now2, currentDate, generateId: generateId3 }){\n        this.warnings = warnings;\n        this.rawResponse = rawResponse;\n        this.outputStrategy = outputStrategy;\n        this.request = Promise.resolve(request);\n        this.objectPromise = new DelayedPromise();\n        const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n        this.usage = usagePromise;\n        const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n        this.response = responsePromise;\n        const { resolve: resolveProviderMetadata, promise: providerMetadataPromise } = createResolvablePromise();\n        this.experimental_providerMetadata = providerMetadataPromise;\n        let usage;\n        let finishReason;\n        let providerMetadata;\n        let object;\n        let error;\n        let accumulatedText = \"\";\n        let textDelta = \"\";\n        let response = {\n            id: generateId3(),\n            timestamp: currentDate(),\n            modelId\n        };\n        let latestObjectJson = void 0;\n        let latestObject = void 0;\n        let isFirstChunk = true;\n        let isFirstDelta = true;\n        const self = this;\n        this.originalStream = stream.pipeThrough(new TransformStream({\n            async transform (chunk, controller) {\n                var _a11, _b, _c;\n                if (isFirstChunk) {\n                    const msToFirstChunk = now2() - startTimestampMs;\n                    isFirstChunk = false;\n                    doStreamSpan.addEvent(\"ai.stream.firstChunk\", {\n                        \"ai.stream.msToFirstChunk\": msToFirstChunk\n                    });\n                    doStreamSpan.setAttributes({\n                        \"ai.stream.msToFirstChunk\": msToFirstChunk\n                    });\n                }\n                if (typeof chunk === \"string\") {\n                    accumulatedText += chunk;\n                    textDelta += chunk;\n                    const { value: currentObjectJson, state: parseState } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.parsePartialJson)(accumulatedText);\n                    if (currentObjectJson !== void 0 && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObjectJson, currentObjectJson)) {\n                        const validationResult = outputStrategy.validatePartialResult({\n                            value: currentObjectJson,\n                            textDelta,\n                            latestObject,\n                            isFirstDelta,\n                            isFinalDelta: parseState === \"successful-parse\"\n                        });\n                        if (validationResult.success && !(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.isDeepEqualData)(latestObject, validationResult.value.partial)) {\n                            latestObjectJson = currentObjectJson;\n                            latestObject = validationResult.value.partial;\n                            controller.enqueue({\n                                type: \"object\",\n                                object: latestObject\n                            });\n                            controller.enqueue({\n                                type: \"text-delta\",\n                                textDelta: validationResult.value.textDelta\n                            });\n                            textDelta = \"\";\n                            isFirstDelta = false;\n                        }\n                    }\n                    return;\n                }\n                switch(chunk.type){\n                    case \"response-metadata\":\n                        {\n                            response = {\n                                id: (_a11 = chunk.id) != null ? _a11 : response.id,\n                                timestamp: (_b = chunk.timestamp) != null ? _b : response.timestamp,\n                                modelId: (_c = chunk.modelId) != null ? _c : response.modelId\n                            };\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            if (textDelta !== \"\") {\n                                controller.enqueue({\n                                    type: \"text-delta\",\n                                    textDelta\n                                });\n                            }\n                            finishReason = chunk.finishReason;\n                            usage = calculateLanguageModelUsage(chunk.usage);\n                            providerMetadata = chunk.providerMetadata;\n                            controller.enqueue({\n                                ...chunk,\n                                usage,\n                                response\n                            });\n                            resolveUsage(usage);\n                            resolveProviderMetadata(providerMetadata);\n                            resolveResponse({\n                                ...response,\n                                headers: rawResponse == null ? void 0 : rawResponse.headers\n                            });\n                            const validationResult = outputStrategy.validateFinalResult(latestObjectJson);\n                            if (validationResult.success) {\n                                object = validationResult.value;\n                                self.objectPromise.resolve(object);\n                            } else {\n                                error = validationResult.error;\n                                self.objectPromise.reject(error);\n                            }\n                            break;\n                        }\n                    default:\n                        {\n                            controller.enqueue(chunk);\n                            break;\n                        }\n                }\n            },\n            // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n            async flush (controller) {\n                try {\n                    const finalUsage = usage != null ? usage : {\n                        promptTokens: NaN,\n                        completionTokens: NaN,\n                        totalTokens: NaN\n                    };\n                    doStreamSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.response.finishReason\": finishReason,\n                            \"ai.response.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            \"ai.response.id\": response.id,\n                            \"ai.response.model\": response.modelId,\n                            \"ai.response.timestamp\": response.timestamp.toISOString(),\n                            \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                            \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                            // deprecated\n                            \"ai.finishReason\": finishReason,\n                            \"ai.result.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            // standardized gen-ai llm span attributes:\n                            \"gen_ai.response.finish_reasons\": [\n                                finishReason\n                            ],\n                            \"gen_ai.response.id\": response.id,\n                            \"gen_ai.response.model\": response.modelId,\n                            \"gen_ai.usage.input_tokens\": finalUsage.promptTokens,\n                            \"gen_ai.usage.output_tokens\": finalUsage.completionTokens\n                        }\n                    }));\n                    doStreamSpan.end();\n                    rootSpan.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.usage.promptTokens\": finalUsage.promptTokens,\n                            \"ai.usage.completionTokens\": finalUsage.completionTokens,\n                            \"ai.response.object\": {\n                                output: ()=>JSON.stringify(object)\n                            },\n                            // deprecated\n                            \"ai.result.object\": {\n                                output: ()=>JSON.stringify(object)\n                            }\n                        }\n                    }));\n                    await (onFinish == null ? void 0 : onFinish({\n                        usage: finalUsage,\n                        object,\n                        error,\n                        rawResponse,\n                        response: {\n                            ...response,\n                            headers: rawResponse == null ? void 0 : rawResponse.headers\n                        },\n                        warnings,\n                        experimental_providerMetadata: providerMetadata\n                    }));\n                } catch (error2) {\n                    controller.error(error2);\n                } finally{\n                    rootSpan.end();\n                }\n            }\n        }));\n    }\n    get object() {\n        return this.objectPromise.value;\n    }\n    get partialObjectStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"object\":\n                        controller.enqueue(chunk.object);\n                        break;\n                    case \"text-delta\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n    }\n    get elementStream() {\n        return this.outputStrategy.createElementStream(this.originalStream);\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                switch(chunk.type){\n                    case \"text-delta\":\n                        controller.enqueue(chunk.textDelta);\n                        break;\n                    case \"object\":\n                    case \"finish\":\n                        break;\n                    case \"error\":\n                        controller.error(chunk.error);\n                        break;\n                    default:\n                        {\n                            const _exhaustiveCheck = chunk;\n                            throw new Error(`Unsupported chunk type: ${_exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.originalStream, {\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a11;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_streamObject = streamObject;\n// core/generate-text/generate-text.ts\n\n// errors/index.ts\n\n// errors/invalid-tool-arguments-error.ts\n\nvar name8 = \"AI_InvalidToolArgumentsError\";\nvar marker8 = `vercel.ai.error.${name8}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar InvalidToolArgumentsError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolArgs, toolName, cause, message = `Invalid arguments for tool ${toolName}: ${(0,_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.getErrorMessage)(cause)}` }){\n        super({\n            name: name8,\n            message,\n            cause\n        });\n        this[_a8] = true;\n        this.toolArgs = toolArgs;\n        this.toolName = toolName;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidToolArgumentsError(error) {\n        return error instanceof Error && error.name === name8 && typeof error.toolName === \"string\" && typeof error.toolArgs === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            toolName: this.toolName,\n            toolArgs: this.toolArgs\n        };\n    }\n};\n_a8 = symbol8;\n// errors/no-such-tool-error.ts\n\nvar name9 = \"AI_NoSuchToolError\";\nvar marker9 = `vercel.ai.error.${name9}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar NoSuchToolError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError {\n    constructor({ toolName, availableTools = void 0, message = `Model tried to call unavailable tool '${toolName}'. ${availableTools === void 0 ? \"No tools are available.\" : `Available tools: ${availableTools.join(\", \")}.`}` }){\n        super({\n            name: name9,\n            message\n        });\n        this[_a9] = true;\n        this.toolName = toolName;\n        this.availableTools = availableTools;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker9);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchToolError(error) {\n        return error instanceof Error && error.name === name9 && \"toolName\" in error && error.toolName != void 0 && typeof error.name === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            toolName: this.toolName,\n            availableTools: this.availableTools\n        };\n    }\n};\n_a9 = symbol9;\n// core/prompt/prepare-tools-and-tool-choice.ts\n\n// core/util/is-non-empty-object.ts\nfunction isNonEmptyObject(object) {\n    return object != null && Object.keys(object).length > 0;\n}\n// core/prompt/prepare-tools-and-tool-choice.ts\nfunction prepareToolsAndToolChoice({ tools, toolChoice, activeTools }) {\n    if (!isNonEmptyObject(tools)) {\n        return {\n            tools: void 0,\n            toolChoice: void 0\n        };\n    }\n    const filteredTools = activeTools != null ? Object.entries(tools).filter(([name11])=>activeTools.includes(name11)) : Object.entries(tools);\n    return {\n        tools: filteredTools.map(([name11, tool2])=>{\n            const toolType = tool2.type;\n            switch(toolType){\n                case void 0:\n                case \"function\":\n                    return {\n                        type: \"function\",\n                        name: name11,\n                        description: tool2.description,\n                        parameters: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(tool2.parameters).jsonSchema\n                    };\n                case \"provider-defined\":\n                    return {\n                        type: \"provider-defined\",\n                        name: name11,\n                        id: tool2.id,\n                        args: tool2.args\n                    };\n                default:\n                    {\n                        const exhaustiveCheck = toolType;\n                        throw new Error(`Unsupported tool type: ${exhaustiveCheck}`);\n                    }\n            }\n        }),\n        toolChoice: toolChoice == null ? {\n            type: \"auto\"\n        } : typeof toolChoice === \"string\" ? {\n            type: toolChoice\n        } : {\n            type: \"tool\",\n            toolName: toolChoice.toolName\n        }\n    };\n}\n// core/util/split-on-last-whitespace.ts\nvar lastWhitespaceRegexp = /^([\\s\\S]*?)(\\s+)(\\S*)$/;\nfunction splitOnLastWhitespace(text) {\n    const match = text.match(lastWhitespaceRegexp);\n    return match ? {\n        prefix: match[1],\n        whitespace: match[2],\n        suffix: match[3]\n    } : void 0;\n}\n// core/util/remove-text-after-last-whitespace.ts\nfunction removeTextAfterLastWhitespace(text) {\n    const match = splitOnLastWhitespace(text);\n    return match ? match.prefix + match.whitespace : text;\n}\n// core/generate-text/parse-tool-call.ts\n\n\nfunction parseToolCall({ toolCall, tools }) {\n    const toolName = toolCall.toolName;\n    if (tools == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName\n        });\n    }\n    const tool2 = tools[toolName];\n    if (tool2 == null) {\n        throw new NoSuchToolError({\n            toolName: toolCall.toolName,\n            availableTools: Object.keys(tools)\n        });\n    }\n    const schema = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.asSchema)(tool2.parameters);\n    const parseResult = toolCall.args.trim() === \"\" ? (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n        value: {},\n        schema\n    }) : (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.safeParseJSON)({\n        text: toolCall.args,\n        schema\n    });\n    if (parseResult.success === false) {\n        throw new InvalidToolArgumentsError({\n            toolName,\n            toolArgs: toolCall.args,\n            cause: parseResult.error\n        });\n    }\n    return {\n        type: \"tool-call\",\n        toolCallId: toolCall.toolCallId,\n        toolName,\n        args: parseResult.value\n    };\n}\n// core/generate-text/to-response-messages.ts\nfunction toResponseMessages({ text = \"\", tools, toolCalls, toolResults }) {\n    const responseMessages = [];\n    responseMessages.push({\n        role: \"assistant\",\n        content: [\n            {\n                type: \"text\",\n                text\n            },\n            ...toolCalls\n        ]\n    });\n    if (toolResults.length > 0) {\n        responseMessages.push({\n            role: \"tool\",\n            content: toolResults.map((toolResult)=>{\n                const tool2 = tools[toolResult.toolName];\n                return (tool2 == null ? void 0 : tool2.experimental_toToolResultContent) != null ? {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: tool2.experimental_toToolResultContent(toolResult.result),\n                    experimental_content: tool2.experimental_toToolResultContent(toolResult.result)\n                } : {\n                    type: \"tool-result\",\n                    toolCallId: toolResult.toolCallId,\n                    toolName: toolResult.toolName,\n                    result: toolResult.result\n                };\n            })\n        });\n    }\n    return responseMessages;\n}\n// core/generate-text/generate-text.ts\nvar originalGenerateId3 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function generateText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxAutomaticRoundtrips = 0, maxToolRoundtrips = maxAutomaticRoundtrips, maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1, experimental_continuationSteps, experimental_continueSteps: continueSteps = experimental_continuationSteps != null ? experimental_continuationSteps : false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_activeTools: activeTools, _internal: { generateId: generateId3 = originalGenerateId3, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, onStepFinish, ...settings }) {\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    const tracer = getTracer(telemetry);\n    return recordSpan({\n        name: \"ai.generateText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.generateText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        fn: async (span)=>{\n            var _a11, _b, _c, _d, _e, _f;\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const mode = {\n                type: \"regular\",\n                ...prepareToolsAndToolChoice({\n                    tools,\n                    toolChoice,\n                    activeTools\n                })\n            };\n            const callSettings = prepareCallSettings(settings);\n            let currentModelResponse;\n            let currentToolCalls = [];\n            let currentToolResults = [];\n            let stepCount = 0;\n            const responseMessages = [];\n            let text = \"\";\n            const steps = [];\n            const usage = {\n                completionTokens: 0,\n                promptTokens: 0,\n                totalTokens: 0\n            };\n            let stepType = \"initial\";\n            do {\n                if (stepCount === 1) {\n                    initialPrompt.type = \"messages\";\n                }\n                const promptFormat = stepCount === 0 ? initialPrompt.type : \"messages\";\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: [\n                            ...initialPrompt.messages,\n                            ...responseMessages\n                        ]\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                currentModelResponse = await retry(()=>recordSpan({\n                        name: \"ai.generateText.doGenerate\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.generateText.doGenerate\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a12;\n                                        return (_a12 = mode.tools) == null ? void 0 : _a12.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        fn: async (span2)=>{\n                            var _a12, _b2, _c2, _d2, _e2, _f2;\n                            const result = await model.doGenerate({\n                                mode,\n                                ...callSettings,\n                                inputFormat: promptFormat,\n                                prompt: promptMessages,\n                                providerMetadata,\n                                abortSignal,\n                                headers\n                            });\n                            const responseData = {\n                                id: (_b2 = (_a12 = result.response) == null ? void 0 : _a12.id) != null ? _b2 : generateId3(),\n                                timestamp: (_d2 = (_c2 = result.response) == null ? void 0 : _c2.timestamp) != null ? _d2 : currentDate(),\n                                modelId: (_f2 = (_e2 = result.response) == null ? void 0 : _e2.modelId) != null ? _f2 : model.modelId\n                            };\n                            span2.setAttributes(selectTelemetryAttributes({\n                                telemetry,\n                                attributes: {\n                                    \"ai.response.finishReason\": result.finishReason,\n                                    \"ai.response.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.response.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    \"ai.response.id\": responseData.id,\n                                    \"ai.response.model\": responseData.modelId,\n                                    \"ai.response.timestamp\": responseData.timestamp.toISOString(),\n                                    \"ai.usage.promptTokens\": result.usage.promptTokens,\n                                    \"ai.usage.completionTokens\": result.usage.completionTokens,\n                                    // deprecated:\n                                    \"ai.finishReason\": result.finishReason,\n                                    \"ai.result.text\": {\n                                        output: ()=>result.text\n                                    },\n                                    \"ai.result.toolCalls\": {\n                                        output: ()=>JSON.stringify(result.toolCalls)\n                                    },\n                                    // standardized gen-ai llm span attributes:\n                                    \"gen_ai.response.finish_reasons\": [\n                                        result.finishReason\n                                    ],\n                                    \"gen_ai.response.id\": responseData.id,\n                                    \"gen_ai.response.model\": responseData.modelId,\n                                    \"gen_ai.usage.input_tokens\": result.usage.promptTokens,\n                                    \"gen_ai.usage.output_tokens\": result.usage.completionTokens\n                                }\n                            }));\n                            return {\n                                ...result,\n                                response: responseData\n                            };\n                        }\n                    }));\n                currentToolCalls = ((_a11 = currentModelResponse.toolCalls) != null ? _a11 : []).map((modelToolCall)=>parseToolCall({\n                        toolCall: modelToolCall,\n                        tools\n                    }));\n                currentToolResults = tools == null ? [] : await executeTools({\n                    toolCalls: currentToolCalls,\n                    tools,\n                    tracer,\n                    telemetry,\n                    abortSignal\n                });\n                const currentUsage = calculateLanguageModelUsage(currentModelResponse.usage);\n                usage.completionTokens += currentUsage.completionTokens;\n                usage.promptTokens += currentUsage.promptTokens;\n                usage.totalTokens += currentUsage.totalTokens;\n                let nextStepType = \"done\";\n                if (++stepCount < maxSteps) {\n                    if (continueSteps && currentModelResponse.finishReason === \"length\" && // only use continue when there are no tool calls:\n                    currentToolCalls.length === 0) {\n                        nextStepType = \"continue\";\n                    } else if (// there are tool calls:\n                    currentToolCalls.length > 0 && // all current tool calls have results:\n                    currentToolResults.length === currentToolCalls.length) {\n                        nextStepType = \"tool-result\";\n                    }\n                }\n                const originalText = (_b = currentModelResponse.text) != null ? _b : \"\";\n                const stepTextLeadingWhitespaceTrimmed = stepType === \"continue\" && // only for continue steps\n                text.trimEnd() !== text ? originalText.trimStart() : originalText;\n                const stepText = nextStepType === \"continue\" ? removeTextAfterLastWhitespace(stepTextLeadingWhitespaceTrimmed) : stepTextLeadingWhitespaceTrimmed;\n                text = nextStepType === \"continue\" || stepType === \"continue\" ? text + stepText : stepText;\n                if (stepType === \"continue\") {\n                    const lastMessage = responseMessages[responseMessages.length - 1];\n                    if (typeof lastMessage.content === \"string\") {\n                        lastMessage.content += stepText;\n                    } else {\n                        lastMessage.content.push({\n                            text: stepText,\n                            type: \"text\"\n                        });\n                    }\n                } else {\n                    responseMessages.push(...toResponseMessages({\n                        text,\n                        tools: tools != null ? tools : {},\n                        toolCalls: currentToolCalls,\n                        toolResults: currentToolResults\n                    }));\n                }\n                const currentStepResult = {\n                    stepType,\n                    text: stepText,\n                    toolCalls: currentToolCalls,\n                    toolResults: currentToolResults,\n                    finishReason: currentModelResponse.finishReason,\n                    usage: currentUsage,\n                    warnings: currentModelResponse.warnings,\n                    logprobs: currentModelResponse.logprobs,\n                    request: (_c = currentModelResponse.request) != null ? _c : {},\n                    response: {\n                        ...currentModelResponse.response,\n                        headers: (_d = currentModelResponse.rawResponse) == null ? void 0 : _d.headers,\n                        // deep clone msgs to avoid mutating past messages in multi-step:\n                        messages: JSON.parse(JSON.stringify(responseMessages))\n                    },\n                    experimental_providerMetadata: currentModelResponse.providerMetadata,\n                    isContinued: nextStepType === \"continue\"\n                };\n                steps.push(currentStepResult);\n                await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                stepType = nextStepType;\n            }while (stepType !== \"done\");\n            span.setAttributes(selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    \"ai.response.finishReason\": currentModelResponse.finishReason,\n                    \"ai.response.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.response.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    },\n                    \"ai.usage.promptTokens\": currentModelResponse.usage.promptTokens,\n                    \"ai.usage.completionTokens\": currentModelResponse.usage.completionTokens,\n                    // deprecated:\n                    \"ai.finishReason\": currentModelResponse.finishReason,\n                    \"ai.result.text\": {\n                        output: ()=>currentModelResponse.text\n                    },\n                    \"ai.result.toolCalls\": {\n                        output: ()=>JSON.stringify(currentModelResponse.toolCalls)\n                    }\n                }\n            }));\n            return new DefaultGenerateTextResult({\n                text,\n                toolCalls: currentToolCalls,\n                toolResults: currentToolResults,\n                finishReason: currentModelResponse.finishReason,\n                usage,\n                warnings: currentModelResponse.warnings,\n                request: (_e = currentModelResponse.request) != null ? _e : {},\n                response: {\n                    ...currentModelResponse.response,\n                    headers: (_f = currentModelResponse.rawResponse) == null ? void 0 : _f.headers,\n                    messages: responseMessages\n                },\n                logprobs: currentModelResponse.logprobs,\n                responseMessages,\n                steps,\n                providerMetadata: currentModelResponse.providerMetadata\n            });\n        }\n    });\n}\nasync function executeTools({ toolCalls, tools, tracer, telemetry, abortSignal }) {\n    const toolResults = await Promise.all(toolCalls.map(async (toolCall)=>{\n        const tool2 = tools[toolCall.toolName];\n        if ((tool2 == null ? void 0 : tool2.execute) == null) {\n            return void 0;\n        }\n        const result = await recordSpan({\n            name: \"ai.toolCall\",\n            attributes: selectTelemetryAttributes({\n                telemetry,\n                attributes: {\n                    ...assembleOperationName({\n                        operationId: \"ai.toolCall\",\n                        telemetry\n                    }),\n                    \"ai.toolCall.name\": toolCall.toolName,\n                    \"ai.toolCall.id\": toolCall.toolCallId,\n                    \"ai.toolCall.args\": {\n                        output: ()=>JSON.stringify(toolCall.args)\n                    }\n                }\n            }),\n            tracer,\n            fn: async (span)=>{\n                const result2 = await tool2.execute(toolCall.args, {\n                    abortSignal\n                });\n                try {\n                    span.setAttributes(selectTelemetryAttributes({\n                        telemetry,\n                        attributes: {\n                            \"ai.toolCall.result\": {\n                                output: ()=>JSON.stringify(result2)\n                            }\n                        }\n                    }));\n                } catch (ignored) {}\n                return result2;\n            }\n        });\n        return {\n            toolCallId: toolCall.toolCallId,\n            toolName: toolCall.toolName,\n            args: toolCall.args,\n            result\n        };\n    }));\n    return toolResults.filter((result)=>result != null);\n}\nvar DefaultGenerateTextResult = class {\n    constructor(options){\n        this.text = options.text;\n        this.toolCalls = options.toolCalls;\n        this.toolResults = options.toolResults;\n        this.finishReason = options.finishReason;\n        this.usage = options.usage;\n        this.warnings = options.warnings;\n        this.request = options.request;\n        this.response = options.response;\n        this.responseMessages = options.responseMessages;\n        this.roundtrips = options.steps;\n        this.steps = options.steps;\n        this.experimental_providerMetadata = options.providerMetadata;\n        this.rawResponse = {\n            headers: options.response.headers\n        };\n        this.logprobs = options.logprobs;\n    }\n};\nvar experimental_generateText = generateText;\n// core/generate-text/stream-text.ts\n\n// core/util/create-stitchable-stream.ts\nfunction createStitchableStream() {\n    let innerStreamReaders = [];\n    let controller = null;\n    let isClosed = false;\n    const processPull = async ()=>{\n        if (isClosed && innerStreamReaders.length === 0) {\n            controller == null ? void 0 : controller.close();\n            return;\n        }\n        if (innerStreamReaders.length === 0) {\n            return;\n        }\n        try {\n            const { value, done } = await innerStreamReaders[0].read();\n            if (done) {\n                innerStreamReaders.shift();\n                if (innerStreamReaders.length > 0) {\n                    await processPull();\n                } else if (isClosed) {\n                    controller == null ? void 0 : controller.close();\n                }\n            } else {\n                controller == null ? void 0 : controller.enqueue(value);\n            }\n        } catch (error) {\n            controller == null ? void 0 : controller.error(error);\n            innerStreamReaders.shift();\n            if (isClosed && innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n    return {\n        stream: new ReadableStream({\n            start (controllerParam) {\n                controller = controllerParam;\n            },\n            pull: processPull,\n            async cancel () {\n                for (const reader of innerStreamReaders){\n                    await reader.cancel();\n                }\n                innerStreamReaders = [];\n                isClosed = true;\n            }\n        }),\n        addStream: (innerStream)=>{\n            if (isClosed) {\n                throw new Error(\"Cannot add inner stream: outer stream is closed\");\n            }\n            innerStreamReaders.push(innerStream.getReader());\n        },\n        close: ()=>{\n            isClosed = true;\n            if (innerStreamReaders.length === 0) {\n                controller == null ? void 0 : controller.close();\n            }\n        }\n    };\n}\n// core/util/merge-streams.ts\nfunction mergeStreams(stream1, stream2) {\n    const reader1 = stream1.getReader();\n    const reader2 = stream2.getReader();\n    let lastRead1 = void 0;\n    let lastRead2 = void 0;\n    let stream1Done = false;\n    let stream2Done = false;\n    async function readStream1(controller) {\n        try {\n            if (lastRead1 == null) {\n                lastRead1 = reader1.read();\n            }\n            const result = await lastRead1;\n            lastRead1 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    async function readStream2(controller) {\n        try {\n            if (lastRead2 == null) {\n                lastRead2 = reader2.read();\n            }\n            const result = await lastRead2;\n            lastRead2 = void 0;\n            if (!result.done) {\n                controller.enqueue(result.value);\n            } else {\n                controller.close();\n            }\n        } catch (error) {\n            controller.error(error);\n        }\n    }\n    return new ReadableStream({\n        async pull (controller) {\n            try {\n                if (stream1Done) {\n                    await readStream2(controller);\n                    return;\n                }\n                if (stream2Done) {\n                    await readStream1(controller);\n                    return;\n                }\n                if (lastRead1 == null) {\n                    lastRead1 = reader1.read();\n                }\n                if (lastRead2 == null) {\n                    lastRead2 = reader2.read();\n                }\n                const { result, reader } = await Promise.race([\n                    lastRead1.then((result2)=>({\n                            result: result2,\n                            reader: reader1\n                        })),\n                    lastRead2.then((result2)=>({\n                            result: result2,\n                            reader: reader2\n                        }))\n                ]);\n                if (!result.done) {\n                    controller.enqueue(result.value);\n                }\n                if (reader === reader1) {\n                    lastRead1 = void 0;\n                    if (result.done) {\n                        await readStream2(controller);\n                        stream1Done = true;\n                    }\n                } else {\n                    lastRead2 = void 0;\n                    if (result.done) {\n                        stream2Done = true;\n                        await readStream1(controller);\n                    }\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        cancel () {\n            reader1.cancel();\n            reader2.cancel();\n        }\n    });\n}\n// core/generate-text/run-tools-transformation.ts\n\nfunction runToolsTransformation({ tools, generatorStream, toolCallStreaming, tracer, telemetry, abortSignal }) {\n    let toolResultsStreamController = null;\n    const toolResultsStream = new ReadableStream({\n        start (controller) {\n            toolResultsStreamController = controller;\n        }\n    });\n    const activeToolCalls = {};\n    const outstandingToolResults = /* @__PURE__ */ new Set();\n    let canClose = false;\n    let finishChunk = void 0;\n    function attemptClose() {\n        if (canClose && outstandingToolResults.size === 0) {\n            if (finishChunk != null) {\n                toolResultsStreamController.enqueue(finishChunk);\n            }\n            toolResultsStreamController.close();\n        }\n    }\n    const forwardStream = new TransformStream({\n        transform (chunk, controller) {\n            const chunkType = chunk.type;\n            switch(chunkType){\n                case \"text-delta\":\n                case \"response-metadata\":\n                case \"error\":\n                    {\n                        controller.enqueue(chunk);\n                        break;\n                    }\n                case \"tool-call-delta\":\n                    {\n                        if (toolCallStreaming) {\n                            if (!activeToolCalls[chunk.toolCallId]) {\n                                controller.enqueue({\n                                    type: \"tool-call-streaming-start\",\n                                    toolCallId: chunk.toolCallId,\n                                    toolName: chunk.toolName\n                                });\n                                activeToolCalls[chunk.toolCallId] = true;\n                            }\n                            controller.enqueue({\n                                type: \"tool-call-delta\",\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                argsTextDelta: chunk.argsTextDelta\n                            });\n                        }\n                        break;\n                    }\n                case \"tool-call\":\n                    {\n                        const toolName = chunk.toolName;\n                        if (tools == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new NoSuchToolError({\n                                    toolName: chunk.toolName\n                                })\n                            });\n                            break;\n                        }\n                        const tool2 = tools[toolName];\n                        if (tool2 == null) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error: new NoSuchToolError({\n                                    toolName: chunk.toolName,\n                                    availableTools: Object.keys(tools)\n                                })\n                            });\n                            break;\n                        }\n                        try {\n                            const toolCall = parseToolCall({\n                                toolCall: chunk,\n                                tools\n                            });\n                            controller.enqueue(toolCall);\n                            if (tool2.execute != null) {\n                                const toolExecutionId = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId)();\n                                outstandingToolResults.add(toolExecutionId);\n                                recordSpan({\n                                    name: \"ai.toolCall\",\n                                    attributes: selectTelemetryAttributes({\n                                        telemetry,\n                                        attributes: {\n                                            ...assembleOperationName({\n                                                operationId: \"ai.toolCall\",\n                                                telemetry\n                                            }),\n                                            \"ai.toolCall.name\": toolCall.toolName,\n                                            \"ai.toolCall.id\": toolCall.toolCallId,\n                                            \"ai.toolCall.args\": {\n                                                output: ()=>JSON.stringify(toolCall.args)\n                                            }\n                                        }\n                                    }),\n                                    tracer,\n                                    fn: async (span)=>tool2.execute(toolCall.args, {\n                                            abortSignal\n                                        }).then((result)=>{\n                                            toolResultsStreamController.enqueue({\n                                                ...toolCall,\n                                                type: \"tool-result\",\n                                                result\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                            try {\n                                                span.setAttributes(selectTelemetryAttributes({\n                                                    telemetry,\n                                                    attributes: {\n                                                        \"ai.toolCall.result\": {\n                                                            output: ()=>JSON.stringify(result)\n                                                        }\n                                                    }\n                                                }));\n                                            } catch (ignored) {}\n                                        }, (error)=>{\n                                            toolResultsStreamController.enqueue({\n                                                type: \"error\",\n                                                error\n                                            });\n                                            outstandingToolResults.delete(toolExecutionId);\n                                            attemptClose();\n                                        })\n                                });\n                            }\n                        } catch (error) {\n                            toolResultsStreamController.enqueue({\n                                type: \"error\",\n                                error\n                            });\n                        }\n                        break;\n                    }\n                case \"finish\":\n                    {\n                        finishChunk = {\n                            type: \"finish\",\n                            finishReason: chunk.finishReason,\n                            logprobs: chunk.logprobs,\n                            usage: calculateLanguageModelUsage(chunk.usage),\n                            experimental_providerMetadata: chunk.providerMetadata\n                        };\n                        break;\n                    }\n                default:\n                    {\n                        const _exhaustiveCheck = chunkType;\n                        throw new Error(`Unhandled chunk type: ${_exhaustiveCheck}`);\n                    }\n            }\n        },\n        flush () {\n            canClose = true;\n            attemptClose();\n        }\n    });\n    return new ReadableStream({\n        async start (controller) {\n            return Promise.all([\n                generatorStream.pipeThrough(forwardStream).pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {}\n                })),\n                toolResultsStream.pipeTo(new WritableStream({\n                    write (chunk) {\n                        controller.enqueue(chunk);\n                    },\n                    close () {\n                        controller.close();\n                    }\n                }))\n            ]);\n        }\n    });\n}\n// core/generate-text/stream-text.ts\nvar originalGenerateId4 = (0,_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.createIdGenerator)({\n    prefix: \"aitxt\",\n    size: 24\n});\nasync function streamText({ model, tools, toolChoice, system, prompt, messages, maxRetries, abortSignal, headers, maxToolRoundtrips = 0, maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1, experimental_continueSteps: continueSteps = false, experimental_telemetry: telemetry, experimental_providerMetadata: providerMetadata, experimental_toolCallStreaming: toolCallStreaming = false, experimental_activeTools: activeTools, onChunk, onFinish, onStepFinish, _internal: { now: now2 = now, generateId: generateId3 = originalGenerateId4, currentDate = ()=>/* @__PURE__ */ new Date() } = {}, ...settings }) {\n    if (maxSteps < 1) {\n        throw new InvalidArgumentError({\n            parameter: \"maxSteps\",\n            value: maxSteps,\n            message: \"maxSteps must be at least 1\"\n        });\n    }\n    const baseTelemetryAttributes = getBaseTelemetryAttributes({\n        model,\n        telemetry,\n        headers,\n        settings: {\n            ...settings,\n            maxRetries\n        }\n    });\n    const tracer = getTracer(telemetry);\n    const initialPrompt = standardizePrompt({\n        prompt: {\n            system,\n            prompt,\n            messages\n        },\n        tools\n    });\n    return recordSpan({\n        name: \"ai.streamText\",\n        attributes: selectTelemetryAttributes({\n            telemetry,\n            attributes: {\n                ...assembleOperationName({\n                    operationId: \"ai.streamText\",\n                    telemetry\n                }),\n                ...baseTelemetryAttributes,\n                // specific settings that only make sense on the outer level:\n                \"ai.prompt\": {\n                    input: ()=>JSON.stringify({\n                            system,\n                            prompt,\n                            messages\n                        })\n                },\n                \"ai.settings.maxSteps\": maxSteps\n            }\n        }),\n        tracer,\n        endWhenDone: false,\n        fn: async (rootSpan)=>{\n            const retry = retryWithExponentialBackoff({\n                maxRetries\n            });\n            const startStep = async ({ responseMessages })=>{\n                const promptFormat = responseMessages.length === 0 ? initialPrompt.type : \"messages\";\n                const promptMessages = await convertToLanguageModelPrompt({\n                    prompt: {\n                        type: promptFormat,\n                        system: initialPrompt.system,\n                        messages: [\n                            ...initialPrompt.messages,\n                            ...responseMessages\n                        ]\n                    },\n                    modelSupportsImageUrls: model.supportsImageUrls,\n                    modelSupportsUrl: model.supportsUrl\n                });\n                const mode = {\n                    type: \"regular\",\n                    ...prepareToolsAndToolChoice({\n                        tools,\n                        toolChoice,\n                        activeTools\n                    })\n                };\n                const { result: { stream: stream2, warnings: warnings2, rawResponse: rawResponse2, request: request2 }, doStreamSpan: doStreamSpan2, startTimestampMs: startTimestampMs2 } = await retry(()=>recordSpan({\n                        name: \"ai.streamText.doStream\",\n                        attributes: selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                ...assembleOperationName({\n                                    operationId: \"ai.streamText.doStream\",\n                                    telemetry\n                                }),\n                                ...baseTelemetryAttributes,\n                                \"ai.prompt.format\": {\n                                    input: ()=>promptFormat\n                                },\n                                \"ai.prompt.messages\": {\n                                    input: ()=>JSON.stringify(promptMessages)\n                                },\n                                \"ai.prompt.tools\": {\n                                    // convert the language model level tools:\n                                    input: ()=>{\n                                        var _a11;\n                                        return (_a11 = mode.tools) == null ? void 0 : _a11.map((tool2)=>JSON.stringify(tool2));\n                                    }\n                                },\n                                \"ai.prompt.toolChoice\": {\n                                    input: ()=>mode.toolChoice != null ? JSON.stringify(mode.toolChoice) : void 0\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.system\": model.provider,\n                                \"gen_ai.request.model\": model.modelId,\n                                \"gen_ai.request.frequency_penalty\": settings.frequencyPenalty,\n                                \"gen_ai.request.max_tokens\": settings.maxTokens,\n                                \"gen_ai.request.presence_penalty\": settings.presencePenalty,\n                                \"gen_ai.request.stop_sequences\": settings.stopSequences,\n                                \"gen_ai.request.temperature\": settings.temperature,\n                                \"gen_ai.request.top_k\": settings.topK,\n                                \"gen_ai.request.top_p\": settings.topP\n                            }\n                        }),\n                        tracer,\n                        endWhenDone: false,\n                        fn: async (doStreamSpan3)=>({\n                                startTimestampMs: now2(),\n                                // get before the call\n                                doStreamSpan: doStreamSpan3,\n                                result: await model.doStream({\n                                    mode,\n                                    ...prepareCallSettings(settings),\n                                    inputFormat: promptFormat,\n                                    prompt: promptMessages,\n                                    providerMetadata,\n                                    abortSignal,\n                                    headers\n                                })\n                            })\n                    }));\n                return {\n                    result: {\n                        stream: runToolsTransformation({\n                            tools,\n                            generatorStream: stream2,\n                            toolCallStreaming,\n                            tracer,\n                            telemetry,\n                            abortSignal\n                        }),\n                        warnings: warnings2,\n                        request: request2 != null ? request2 : {},\n                        rawResponse: rawResponse2\n                    },\n                    doStreamSpan: doStreamSpan2,\n                    startTimestampMs: startTimestampMs2\n                };\n            };\n            const { result: { stream, warnings, rawResponse, request }, doStreamSpan, startTimestampMs } = await startStep({\n                responseMessages: []\n            });\n            return new DefaultStreamTextResult({\n                stream,\n                warnings,\n                rawResponse,\n                request,\n                onChunk,\n                onFinish,\n                onStepFinish,\n                rootSpan,\n                doStreamSpan,\n                telemetry,\n                startTimestampMs,\n                maxSteps,\n                continueSteps,\n                startStep,\n                modelId: model.modelId,\n                now: now2,\n                currentDate,\n                generateId: generateId3,\n                tools\n            });\n        }\n    });\n}\nvar DefaultStreamTextResult = class {\n    constructor({ stream, warnings, rawResponse, request, onChunk, onFinish, onStepFinish, rootSpan, doStreamSpan, telemetry, startTimestampMs, maxSteps, continueSteps, startStep, modelId, now: now2, currentDate, generateId: generateId3, tools }){\n        this.warnings = warnings;\n        this.rawResponse = rawResponse;\n        const { resolve: resolveUsage, promise: usagePromise } = createResolvablePromise();\n        this.usage = usagePromise;\n        const { resolve: resolveFinishReason, promise: finishReasonPromise } = createResolvablePromise();\n        this.finishReason = finishReasonPromise;\n        const { resolve: resolveText, promise: textPromise } = createResolvablePromise();\n        this.text = textPromise;\n        const { resolve: resolveToolCalls, promise: toolCallsPromise } = createResolvablePromise();\n        this.toolCalls = toolCallsPromise;\n        const { resolve: resolveToolResults, promise: toolResultsPromise } = createResolvablePromise();\n        this.toolResults = toolResultsPromise;\n        const { resolve: resolveSteps, promise: stepsPromise } = createResolvablePromise();\n        this.steps = stepsPromise;\n        const { resolve: resolveProviderMetadata, promise: providerMetadataPromise } = createResolvablePromise();\n        this.experimental_providerMetadata = providerMetadataPromise;\n        const { resolve: resolveRequest, promise: requestPromise } = createResolvablePromise();\n        this.request = requestPromise;\n        const { resolve: resolveResponse, promise: responsePromise } = createResolvablePromise();\n        this.response = responsePromise;\n        const { resolve: resolveResponseMessages, promise: responseMessagesPromise } = createResolvablePromise();\n        this.responseMessages = responseMessagesPromise;\n        const { stream: stitchableStream, addStream, close: closeStitchableStream } = createStitchableStream();\n        this.originalStream = stitchableStream;\n        const stepResults = [];\n        const self = this;\n        function addStepStream({ stream: stream2, startTimestamp, doStreamSpan: doStreamSpan2, currentStep, responseMessages, usage = {\n            promptTokens: 0,\n            completionTokens: 0,\n            totalTokens: 0\n        }, stepType, previousStepText = \"\", stepRequest, hasLeadingWhitespace }) {\n            const stepToolCalls = [];\n            const stepToolResults = [];\n            let stepFinishReason = \"unknown\";\n            let stepUsage = {\n                promptTokens: 0,\n                completionTokens: 0,\n                totalTokens: 0\n            };\n            let stepProviderMetadata;\n            let stepFirstChunk = true;\n            let stepText = \"\";\n            let fullStepText = stepType === \"continue\" ? previousStepText : \"\";\n            let stepLogProbs;\n            let stepResponse = {\n                id: generateId3(),\n                timestamp: currentDate(),\n                modelId\n            };\n            let chunkBuffer = \"\";\n            let chunkTextPublished = false;\n            let inWhitespacePrefix = true;\n            let hasWhitespaceSuffix = false;\n            async function publishTextChunk({ controller, chunk }) {\n                controller.enqueue(chunk);\n                stepText += chunk.textDelta;\n                fullStepText += chunk.textDelta;\n                chunkTextPublished = true;\n                hasWhitespaceSuffix = chunk.textDelta.trimEnd() !== chunk.textDelta;\n                await (onChunk == null ? void 0 : onChunk({\n                    chunk\n                }));\n            }\n            addStream(stream2.pipeThrough(new TransformStream({\n                async transform (chunk, controller) {\n                    var _a11, _b, _c;\n                    if (stepFirstChunk) {\n                        const msToFirstChunk = now2() - startTimestamp;\n                        stepFirstChunk = false;\n                        doStreamSpan2.addEvent(\"ai.stream.firstChunk\", {\n                            \"ai.response.msToFirstChunk\": msToFirstChunk,\n                            // deprecated:\n                            \"ai.stream.msToFirstChunk\": msToFirstChunk\n                        });\n                        doStreamSpan2.setAttributes({\n                            \"ai.response.msToFirstChunk\": msToFirstChunk,\n                            // deprecated:\n                            \"ai.stream.msToFirstChunk\": msToFirstChunk\n                        });\n                    }\n                    if (chunk.type === \"text-delta\" && chunk.textDelta.length === 0) {\n                        return;\n                    }\n                    const chunkType = chunk.type;\n                    switch(chunkType){\n                        case \"text-delta\":\n                            {\n                                if (continueSteps) {\n                                    const trimmedChunkText = inWhitespacePrefix && hasLeadingWhitespace ? chunk.textDelta.trimStart() : chunk.textDelta;\n                                    if (trimmedChunkText.length === 0) {\n                                        break;\n                                    }\n                                    inWhitespacePrefix = false;\n                                    chunkBuffer += trimmedChunkText;\n                                    const split = splitOnLastWhitespace(chunkBuffer);\n                                    if (split != null) {\n                                        chunkBuffer = split.suffix;\n                                        await publishTextChunk({\n                                            controller,\n                                            chunk: {\n                                                type: \"text-delta\",\n                                                textDelta: split.prefix + split.whitespace\n                                            }\n                                        });\n                                    }\n                                } else {\n                                    await publishTextChunk({\n                                        controller,\n                                        chunk\n                                    });\n                                }\n                                break;\n                            }\n                        case \"tool-call\":\n                            {\n                                controller.enqueue(chunk);\n                                stepToolCalls.push(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"tool-result\":\n                            {\n                                controller.enqueue(chunk);\n                                stepToolResults.push(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"response-metadata\":\n                            {\n                                stepResponse = {\n                                    id: (_a11 = chunk.id) != null ? _a11 : stepResponse.id,\n                                    timestamp: (_b = chunk.timestamp) != null ? _b : stepResponse.timestamp,\n                                    modelId: (_c = chunk.modelId) != null ? _c : stepResponse.modelId\n                                };\n                                break;\n                            }\n                        case \"finish\":\n                            {\n                                stepUsage = chunk.usage;\n                                stepFinishReason = chunk.finishReason;\n                                stepProviderMetadata = chunk.experimental_providerMetadata;\n                                stepLogProbs = chunk.logprobs;\n                                const msToFinish = now2() - startTimestamp;\n                                doStreamSpan2.addEvent(\"ai.stream.finish\");\n                                doStreamSpan2.setAttributes({\n                                    \"ai.response.msToFinish\": msToFinish,\n                                    \"ai.response.avgCompletionTokensPerSecond\": 1e3 * stepUsage.completionTokens / msToFinish\n                                });\n                                break;\n                            }\n                        case \"tool-call-streaming-start\":\n                        case \"tool-call-delta\":\n                            {\n                                controller.enqueue(chunk);\n                                await (onChunk == null ? void 0 : onChunk({\n                                    chunk\n                                }));\n                                break;\n                            }\n                        case \"error\":\n                            {\n                                controller.enqueue(chunk);\n                                stepFinishReason = \"error\";\n                                break;\n                            }\n                        default:\n                            {\n                                const exhaustiveCheck = chunkType;\n                                throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                            }\n                    }\n                },\n                // invoke onFinish callback and resolve toolResults promise when the stream is about to close:\n                async flush (controller) {\n                    var _a11;\n                    const stepToolCallsJson = stepToolCalls.length > 0 ? JSON.stringify(stepToolCalls) : void 0;\n                    let nextStepType = \"done\";\n                    if (currentStep + 1 < maxSteps) {\n                        if (continueSteps && stepFinishReason === \"length\" && // only use continue when there are no tool calls:\n                        stepToolCalls.length === 0) {\n                            nextStepType = \"continue\";\n                        } else if (// there are tool calls:\n                        stepToolCalls.length > 0 && // all current tool calls have results:\n                        stepToolResults.length === stepToolCalls.length) {\n                            nextStepType = \"tool-result\";\n                        }\n                    }\n                    if (continueSteps && chunkBuffer.length > 0 && (nextStepType !== \"continue\" || // when the next step is a regular step, publish the buffer\n                    stepType === \"continue\" && !chunkTextPublished)) {\n                        await publishTextChunk({\n                            controller,\n                            chunk: {\n                                type: \"text-delta\",\n                                textDelta: chunkBuffer\n                            }\n                        });\n                        chunkBuffer = \"\";\n                    }\n                    try {\n                        doStreamSpan2.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.response.finishReason\": stepFinishReason,\n                                \"ai.response.text\": {\n                                    output: ()=>stepText\n                                },\n                                \"ai.response.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                \"ai.response.id\": stepResponse.id,\n                                \"ai.response.model\": stepResponse.modelId,\n                                \"ai.response.timestamp\": stepResponse.timestamp.toISOString(),\n                                \"ai.usage.promptTokens\": stepUsage.promptTokens,\n                                \"ai.usage.completionTokens\": stepUsage.completionTokens,\n                                // deprecated\n                                \"ai.finishReason\": stepFinishReason,\n                                \"ai.result.text\": {\n                                    output: ()=>stepText\n                                },\n                                \"ai.result.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                // standardized gen-ai llm span attributes:\n                                \"gen_ai.response.finish_reasons\": [\n                                    stepFinishReason\n                                ],\n                                \"gen_ai.response.id\": stepResponse.id,\n                                \"gen_ai.response.model\": stepResponse.modelId,\n                                \"gen_ai.usage.input_tokens\": stepUsage.promptTokens,\n                                \"gen_ai.usage.output_tokens\": stepUsage.completionTokens\n                            }\n                        }));\n                    } catch (error) {} finally{\n                        doStreamSpan2.end();\n                    }\n                    controller.enqueue({\n                        type: \"step-finish\",\n                        finishReason: stepFinishReason,\n                        usage: stepUsage,\n                        experimental_providerMetadata: stepProviderMetadata,\n                        logprobs: stepLogProbs,\n                        response: {\n                            ...stepResponse\n                        },\n                        isContinued: nextStepType === \"continue\"\n                    });\n                    if (stepType === \"continue\") {\n                        const lastMessage = responseMessages[responseMessages.length - 1];\n                        if (typeof lastMessage.content === \"string\") {\n                            lastMessage.content += stepText;\n                        } else {\n                            lastMessage.content.push({\n                                text: stepText,\n                                type: \"text\"\n                            });\n                        }\n                    } else {\n                        responseMessages.push(...toResponseMessages({\n                            text: stepText,\n                            tools: tools != null ? tools : {},\n                            toolCalls: stepToolCalls,\n                            toolResults: stepToolResults\n                        }));\n                    }\n                    const currentStepResult = {\n                        stepType,\n                        text: stepText,\n                        toolCalls: stepToolCalls,\n                        toolResults: stepToolResults,\n                        finishReason: stepFinishReason,\n                        usage: stepUsage,\n                        warnings: self.warnings,\n                        logprobs: stepLogProbs,\n                        request: stepRequest,\n                        rawResponse: self.rawResponse,\n                        response: {\n                            ...stepResponse,\n                            headers: (_a11 = self.rawResponse) == null ? void 0 : _a11.headers,\n                            // deep clone msgs to avoid mutating past messages in multi-step:\n                            messages: JSON.parse(JSON.stringify(responseMessages))\n                        },\n                        experimental_providerMetadata: stepProviderMetadata,\n                        isContinued: nextStepType === \"continue\"\n                    };\n                    stepResults.push(currentStepResult);\n                    await (onStepFinish == null ? void 0 : onStepFinish(currentStepResult));\n                    const combinedUsage = {\n                        promptTokens: usage.promptTokens + stepUsage.promptTokens,\n                        completionTokens: usage.completionTokens + stepUsage.completionTokens,\n                        totalTokens: usage.totalTokens + stepUsage.totalTokens\n                    };\n                    if (nextStepType !== \"done\") {\n                        const { result, doStreamSpan: doStreamSpan3, startTimestampMs: startTimestamp2 } = await startStep({\n                            responseMessages\n                        });\n                        self.warnings = result.warnings;\n                        self.rawResponse = result.rawResponse;\n                        addStepStream({\n                            stream: result.stream,\n                            startTimestamp: startTimestamp2,\n                            doStreamSpan: doStreamSpan3,\n                            currentStep: currentStep + 1,\n                            responseMessages,\n                            usage: combinedUsage,\n                            stepType: nextStepType,\n                            previousStepText: fullStepText,\n                            stepRequest: result.request,\n                            hasLeadingWhitespace: hasWhitespaceSuffix\n                        });\n                        return;\n                    }\n                    try {\n                        controller.enqueue({\n                            type: \"finish\",\n                            finishReason: stepFinishReason,\n                            usage: combinedUsage,\n                            experimental_providerMetadata: stepProviderMetadata,\n                            logprobs: stepLogProbs,\n                            response: {\n                                ...stepResponse\n                            }\n                        });\n                        closeStitchableStream();\n                        rootSpan.setAttributes(selectTelemetryAttributes({\n                            telemetry,\n                            attributes: {\n                                \"ai.response.finishReason\": stepFinishReason,\n                                \"ai.response.text\": {\n                                    output: ()=>fullStepText\n                                },\n                                \"ai.response.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                },\n                                \"ai.usage.promptTokens\": combinedUsage.promptTokens,\n                                \"ai.usage.completionTokens\": combinedUsage.completionTokens,\n                                // deprecated\n                                \"ai.finishReason\": stepFinishReason,\n                                \"ai.result.text\": {\n                                    output: ()=>fullStepText\n                                },\n                                \"ai.result.toolCalls\": {\n                                    output: ()=>stepToolCallsJson\n                                }\n                            }\n                        }));\n                        resolveUsage(combinedUsage);\n                        resolveFinishReason(stepFinishReason);\n                        resolveText(fullStepText);\n                        resolveToolCalls(stepToolCalls);\n                        resolveProviderMetadata(stepProviderMetadata);\n                        resolveToolResults(stepToolResults);\n                        resolveRequest(stepRequest);\n                        resolveResponse({\n                            ...stepResponse,\n                            headers: rawResponse == null ? void 0 : rawResponse.headers,\n                            messages: responseMessages\n                        });\n                        resolveSteps(stepResults);\n                        resolveResponseMessages(responseMessages);\n                        await (onFinish == null ? void 0 : onFinish({\n                            finishReason: stepFinishReason,\n                            logprobs: stepLogProbs,\n                            usage: combinedUsage,\n                            text: fullStepText,\n                            toolCalls: stepToolCalls,\n                            // The tool results are inferred as a never[] type, because they are\n                            // optional and the execute method with an inferred result type is\n                            // optional as well. Therefore we need to cast the toolResults to any.\n                            // The type exposed to the users will be correctly inferred.\n                            toolResults: stepToolResults,\n                            request: stepRequest,\n                            rawResponse,\n                            response: {\n                                ...stepResponse,\n                                headers: rawResponse == null ? void 0 : rawResponse.headers,\n                                messages: responseMessages\n                            },\n                            warnings,\n                            experimental_providerMetadata: stepProviderMetadata,\n                            steps: stepResults,\n                            responseMessages\n                        }));\n                    } catch (error) {\n                        controller.error(error);\n                    } finally{\n                        rootSpan.end();\n                    }\n                }\n            })));\n        }\n        addStepStream({\n            stream,\n            startTimestamp: startTimestampMs,\n            doStreamSpan,\n            currentStep: 0,\n            responseMessages: [],\n            usage: void 0,\n            stepType: \"initial\",\n            stepRequest: request,\n            hasLeadingWhitespace: false\n        });\n    }\n    /**\n  Split out a new stream from the original stream.\n  The original stream is replaced to allow for further splitting,\n  since we do not know how many times the stream will be split.\n  \n  Note: this leads to buffering the stream content on the server.\n  However, the LLM results are expected to be small enough to not cause issues.\n     */ teeStream() {\n        const [stream1, stream2] = this.originalStream.tee();\n        this.originalStream = stream2;\n        return stream1;\n    }\n    get textStream() {\n        return createAsyncIterableStream(this.teeStream(), {\n            transform (chunk, controller) {\n                if (chunk.type === \"text-delta\") {\n                    controller.enqueue(chunk.textDelta);\n                } else if (chunk.type === \"error\") {\n                    controller.error(chunk.error);\n                }\n            }\n        });\n    }\n    get fullStream() {\n        return createAsyncIterableStream(this.teeStream(), {\n            transform (chunk, controller) {\n                controller.enqueue(chunk);\n            }\n        });\n    }\n    toAIStream(callbacks = {}) {\n        return this.toDataStreamInternal({\n            callbacks\n        });\n    }\n    toDataStreamInternal({ callbacks = {}, getErrorMessage: getErrorMessage3 = ()=>\"\", // mask error messages for safety by default\n    sendUsage = true } = {}) {\n        let aggregatedResponse = \"\";\n        const callbackTransformer = new TransformStream({\n            async start () {\n                if (callbacks.onStart) await callbacks.onStart();\n            },\n            async transform (chunk, controller) {\n                controller.enqueue(chunk);\n                if (chunk.type === \"text-delta\") {\n                    const textDelta = chunk.textDelta;\n                    aggregatedResponse += textDelta;\n                    if (callbacks.onToken) await callbacks.onToken(textDelta);\n                    if (callbacks.onText) await callbacks.onText(textDelta);\n                }\n            },\n            async flush () {\n                if (callbacks.onCompletion) await callbacks.onCompletion(aggregatedResponse);\n                if (callbacks.onFinal) await callbacks.onFinal(aggregatedResponse);\n            }\n        });\n        const streamPartsTransformer = new TransformStream({\n            transform: async (chunk, controller)=>{\n                const chunkType = chunk.type;\n                switch(chunkType){\n                    case \"text-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", chunk.textDelta));\n                            break;\n                        }\n                    case \"tool-call-streaming-start\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_streaming_start\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName\n                            }));\n                            break;\n                        }\n                    case \"tool-call-delta\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call_delta\", {\n                                toolCallId: chunk.toolCallId,\n                                argsTextDelta: chunk.argsTextDelta\n                            }));\n                            break;\n                        }\n                    case \"tool-call\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_call\", {\n                                toolCallId: chunk.toolCallId,\n                                toolName: chunk.toolName,\n                                args: chunk.args\n                            }));\n                            break;\n                        }\n                    case \"tool-result\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"tool_result\", {\n                                toolCallId: chunk.toolCallId,\n                                result: chunk.result\n                            }));\n                            break;\n                        }\n                    case \"error\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", getErrorMessage3(chunk.error)));\n                            break;\n                        }\n                    case \"step-finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_step\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0,\n                                isContinued: chunk.isContinued\n                            }));\n                            break;\n                        }\n                    case \"finish\":\n                        {\n                            controller.enqueue((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"finish_message\", {\n                                finishReason: chunk.finishReason,\n                                usage: sendUsage ? {\n                                    promptTokens: chunk.usage.promptTokens,\n                                    completionTokens: chunk.usage.completionTokens\n                                } : void 0\n                            }));\n                            break;\n                        }\n                    default:\n                        {\n                            const exhaustiveCheck = chunkType;\n                            throw new Error(`Unknown chunk type: ${exhaustiveCheck}`);\n                        }\n                }\n            }\n        });\n        return this.fullStream.pipeThrough(callbackTransformer).pipeThrough(streamPartsTransformer).pipeThrough(new TextEncoderStream());\n    }\n    pipeAIStreamToResponse(response, init) {\n        return this.pipeDataStreamToResponse(response, init);\n    }\n    pipeDataStreamToResponse(response, options) {\n        const init = options == null ? void 0 : \"init\" in options ? options.init : {\n            headers: \"headers\" in options ? options.headers : void 0,\n            status: \"status\" in options ? options.status : void 0,\n            statusText: \"statusText\" in options ? options.statusText : void 0\n        };\n        const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n        const getErrorMessage3 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n        const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            }),\n            stream: this.toDataStream({\n                data,\n                getErrorMessage: getErrorMessage3,\n                sendUsage\n            })\n        });\n    }\n    pipeTextStreamToResponse(response, init) {\n        writeToServerResponse({\n            response,\n            status: init == null ? void 0 : init.status,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareOutgoingHttpHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            }),\n            stream: this.textStream.pipeThrough(new TextEncoderStream())\n        });\n    }\n    toAIStreamResponse(options) {\n        return this.toDataStreamResponse(options);\n    }\n    toDataStream(options) {\n        const stream = this.toDataStreamInternal({\n            getErrorMessage: options == null ? void 0 : options.getErrorMessage,\n            sendUsage: options == null ? void 0 : options.sendUsage\n        });\n        return (options == null ? void 0 : options.data) ? mergeStreams(options == null ? void 0 : options.data.stream, stream) : stream;\n    }\n    toDataStreamResponse(options) {\n        var _a11;\n        const init = options == null ? void 0 : \"init\" in options ? options.init : {\n            headers: \"headers\" in options ? options.headers : void 0,\n            status: \"status\" in options ? options.status : void 0,\n            statusText: \"statusText\" in options ? options.statusText : void 0\n        };\n        const data = options == null ? void 0 : \"data\" in options ? options.data : void 0;\n        const getErrorMessage3 = options == null ? void 0 : \"getErrorMessage\" in options ? options.getErrorMessage : void 0;\n        const sendUsage = options == null ? void 0 : \"sendUsage\" in options ? options.sendUsage : void 0;\n        return new Response(this.toDataStream({\n            data,\n            getErrorMessage: getErrorMessage3,\n            sendUsage\n        }), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            statusText: init == null ? void 0 : init.statusText,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\",\n                dataStreamVersion: \"v1\"\n            })\n        });\n    }\n    toTextStreamResponse(init) {\n        var _a11;\n        return new Response(this.textStream.pipeThrough(new TextEncoderStream()), {\n            status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\nvar experimental_streamText = streamText;\n// core/middleware/wrap-language-model.ts\nvar experimental_wrapLanguageModel = ({ model, middleware: { transformParams, wrapGenerate, wrapStream }, modelId, providerId })=>{\n    async function doTransform({ params, type }) {\n        return transformParams ? await transformParams({\n            params,\n            type\n        }) : params;\n    }\n    return {\n        specificationVersion: \"v1\",\n        provider: providerId != null ? providerId : model.provider,\n        modelId: modelId != null ? modelId : model.modelId,\n        defaultObjectGenerationMode: model.defaultObjectGenerationMode,\n        supportsImageUrls: model.supportsImageUrls,\n        supportsUrl: model.supportsUrl,\n        supportsStructuredOutputs: model.supportsStructuredOutputs,\n        async doGenerate (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"generate\"\n            });\n            const doGenerate = async ()=>model.doGenerate(transformedParams);\n            return wrapGenerate ? wrapGenerate({\n                doGenerate,\n                params: transformedParams,\n                model\n            }) : doGenerate();\n        },\n        async doStream (params) {\n            const transformedParams = await doTransform({\n                params,\n                type: \"stream\"\n            });\n            const doStream = async ()=>model.doStream(transformedParams);\n            return wrapStream ? wrapStream({\n                doStream,\n                params: transformedParams,\n                model\n            }) : doStream();\n        }\n    };\n};\n// core/registry/custom-provider.ts\n\nfunction experimental_customProvider({ languageModels, textEmbeddingModels, fallbackProvider }) {\n    return {\n        languageModel (modelId) {\n            if (languageModels != null && modelId in languageModels) {\n                return languageModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.languageModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"languageModel\"\n            });\n        },\n        textEmbeddingModel (modelId) {\n            if (textEmbeddingModels != null && modelId in textEmbeddingModels) {\n                return textEmbeddingModels[modelId];\n            }\n            if (fallbackProvider) {\n                return fallbackProvider.textEmbeddingModel(modelId);\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n    };\n}\n// core/registry/no-such-provider-error.ts\n\nvar name10 = \"AI_NoSuchProviderError\";\nvar marker10 = `vercel.ai.error.${name10}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoSuchProviderError = class extends _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError {\n    constructor({ modelId, modelType, providerId, availableProviders, message = `No such provider: ${providerId} (available providers: ${availableProviders.join()})` }){\n        super({\n            errorName: name10,\n            modelId,\n            modelType,\n            message\n        });\n        this[_a10] = true;\n        this.providerId = providerId;\n        this.availableProviders = availableProviders;\n    }\n    static isInstance(error) {\n        return _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.AISDKError.hasMarker(error, marker10);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchProviderError(error) {\n        return error instanceof Error && error.name === name10 && typeof error.providerId === \"string\" && Array.isArray(error.availableProviders);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            modelId: this.modelId,\n            modelType: this.modelType,\n            providerId: this.providerId,\n            availableProviders: this.availableProviders\n        };\n    }\n};\n_a10 = symbol10;\n// core/registry/provider-registry.ts\n\nfunction experimental_createProviderRegistry(providers) {\n    const registry = new DefaultProviderRegistry();\n    for (const [id, provider] of Object.entries(providers)){\n        registry.registerProvider({\n            id,\n            provider\n        });\n    }\n    return registry;\n}\nvar experimental_createModelRegistry = experimental_createProviderRegistry;\nvar DefaultProviderRegistry = class {\n    constructor(){\n        this.providers = {};\n    }\n    registerProvider({ id, provider }) {\n        this.providers[id] = provider;\n    }\n    getProvider(id) {\n        const provider = this.providers[id];\n        if (provider == null) {\n            throw new NoSuchProviderError({\n                modelId: id,\n                modelType: \"languageModel\",\n                providerId: id,\n                availableProviders: Object.keys(this.providers)\n            });\n        }\n        return provider;\n    }\n    splitId(id, modelType) {\n        const index = id.indexOf(\":\");\n        if (index === -1) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType,\n                message: `Invalid ${modelType} id for registry: ${id} (must be in the format \"providerId:modelId\")`\n            });\n        }\n        return [\n            id.slice(0, index),\n            id.slice(index + 1)\n        ];\n    }\n    languageModel(id) {\n        var _a11, _b;\n        const [providerId, modelId] = this.splitId(id, \"languageModel\");\n        const model = (_b = (_a11 = this.getProvider(providerId)).languageModel) == null ? void 0 : _b.call(_a11, modelId);\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"languageModel\"\n            });\n        }\n        return model;\n    }\n    textEmbeddingModel(id) {\n        var _a11, _b, _c;\n        const [providerId, modelId] = this.splitId(id, \"textEmbeddingModel\");\n        const provider = this.getProvider(providerId);\n        const model = (_c = (_a11 = provider.textEmbeddingModel) == null ? void 0 : _a11.call(provider, modelId)) != null ? _c : \"textEmbedding\" in provider ? (_b = provider.textEmbedding) == null ? void 0 : _b.call(provider, modelId) : void 0;\n        if (model == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_0__.NoSuchModelError({\n                modelId: id,\n                modelType: \"textEmbeddingModel\"\n            });\n        }\n        return model;\n    }\n    /**\n   * @deprecated Use `textEmbeddingModel` instead.\n   */ textEmbedding(id) {\n        return this.textEmbeddingModel(id);\n    }\n};\n// core/tool/tool.ts\nfunction tool(tool2) {\n    return tool2;\n}\n// core/util/cosine-similarity.ts\nfunction cosineSimilarity(vector1, vector2) {\n    if (vector1.length !== vector2.length) {\n        throw new Error(`Vectors must have the same length (vector1: ${vector1.length} elements, vector2: ${vector2.length} elements)`);\n    }\n    return dotProduct(vector1, vector2) / (magnitude(vector1) * magnitude(vector2));\n}\nfunction dotProduct(vector1, vector2) {\n    return vector1.reduce((accumulator, value, index)=>accumulator + value * vector2[index], 0);\n}\nfunction magnitude(vector) {\n    return Math.sqrt(dotProduct(vector, vector));\n}\n// streams/ai-stream.ts\n\nfunction createEventStreamTransformer(customParser) {\n    const textDecoder = new TextDecoder();\n    let eventSourceParser;\n    return new TransformStream({\n        async start (controller) {\n            eventSourceParser = (0,eventsource_parser__WEBPACK_IMPORTED_MODULE_5__.createParser)((event)=>{\n                if (\"data\" in event && event.type === \"event\" && event.data === \"[DONE]\" || // Replicate doesn't send [DONE] but does send a 'done' event\n                // @see https://replicate.com/docs/streaming\n                event.event === \"done\") {\n                    controller.terminate();\n                    return;\n                }\n                if (\"data\" in event) {\n                    const parsedMessage = customParser ? customParser(event.data, {\n                        event: event.event\n                    }) : event.data;\n                    if (parsedMessage) controller.enqueue(parsedMessage);\n                }\n            });\n        },\n        transform (chunk) {\n            eventSourceParser.feed(textDecoder.decode(chunk));\n        }\n    });\n}\nfunction createCallbacksTransformer(cb) {\n    const textEncoder = new TextEncoder();\n    let aggregatedResponse = \"\";\n    const callbacks = cb || {};\n    return new TransformStream({\n        async start () {\n            if (callbacks.onStart) await callbacks.onStart();\n        },\n        async transform (message, controller) {\n            const content = typeof message === \"string\" ? message : message.content;\n            controller.enqueue(textEncoder.encode(content));\n            aggregatedResponse += content;\n            if (callbacks.onToken) await callbacks.onToken(content);\n            if (callbacks.onText && typeof message === \"string\") {\n                await callbacks.onText(message);\n            }\n        },\n        async flush () {\n            const isOpenAICallbacks = isOfTypeOpenAIStreamCallbacks(callbacks);\n            if (callbacks.onCompletion) {\n                await callbacks.onCompletion(aggregatedResponse);\n            }\n            if (callbacks.onFinal && !isOpenAICallbacks) {\n                await callbacks.onFinal(aggregatedResponse);\n            }\n        }\n    });\n}\nfunction isOfTypeOpenAIStreamCallbacks(callbacks) {\n    return \"experimental_onFunctionCall\" in callbacks;\n}\nfunction trimStartOfStreamHelper() {\n    let isStreamStart = true;\n    return (text)=>{\n        if (isStreamStart) {\n            text = text.trimStart();\n            if (text) isStreamStart = false;\n        }\n        return text;\n    };\n}\nfunction AIStream(response, customParser, callbacks) {\n    if (!response.ok) {\n        if (response.body) {\n            const reader = response.body.getReader();\n            return new ReadableStream({\n                async start (controller) {\n                    const { done, value } = await reader.read();\n                    if (!done) {\n                        const errorText = new TextDecoder().decode(value);\n                        controller.error(new Error(`Response error: ${errorText}`));\n                    }\n                }\n            });\n        } else {\n            return new ReadableStream({\n                start (controller) {\n                    controller.error(new Error(\"Response error: No response body\"));\n                }\n            });\n        }\n    }\n    const responseBodyStream = response.body || createEmptyReadableStream();\n    return responseBodyStream.pipeThrough(createEventStreamTransformer(customParser)).pipeThrough(createCallbacksTransformer(callbacks));\n}\nfunction createEmptyReadableStream() {\n    return new ReadableStream({\n        start (controller) {\n            controller.close();\n        }\n    });\n}\nfunction readableFromAsyncIterable(iterable) {\n    let it = iterable[Symbol.asyncIterator]();\n    return new ReadableStream({\n        async pull (controller) {\n            const { done, value } = await it.next();\n            if (done) controller.close();\n            else controller.enqueue(value);\n        },\n        async cancel (reason) {\n            var _a11;\n            await ((_a11 = it.return) == null ? void 0 : _a11.call(it, reason));\n        }\n    });\n}\n// streams/stream-data.ts\n\n// util/constants.ts\nvar HANGING_STREAM_WARNING_TIME_MS = 15 * 1e3;\n// streams/stream-data.ts\nvar StreamData2 = class {\n    constructor(){\n        this.encoder = new TextEncoder();\n        this.controller = null;\n        this.isClosed = false;\n        this.warningTimeout = null;\n        const self = this;\n        this.stream = new ReadableStream({\n            start: async (controller)=>{\n                self.controller = controller;\n                if (true) {\n                    self.warningTimeout = setTimeout(()=>{\n                        console.warn(\"The data stream is hanging. Did you forget to close it with `data.close()`?\");\n                    }, HANGING_STREAM_WARNING_TIME_MS);\n                }\n            },\n            pull: (controller)=>{},\n            cancel: (reason)=>{\n                this.isClosed = true;\n            }\n        });\n    }\n    async close() {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.close();\n        this.isClosed = true;\n        if (this.warningTimeout) {\n            clearTimeout(this.warningTimeout);\n        }\n    }\n    append(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data\", [\n            value\n        ])));\n    }\n    appendMessageAnnotation(value) {\n        if (this.isClosed) {\n            throw new Error(\"Data Stream has already been closed.\");\n        }\n        if (!this.controller) {\n            throw new Error(\"Stream controller is not initialized.\");\n        }\n        this.controller.enqueue(this.encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"message_annotations\", [\n            value\n        ])));\n    }\n};\nfunction createStreamDataTransformer() {\n    const encoder = new TextEncoder();\n    const decoder = new TextDecoder();\n    return new TransformStream({\n        transform: async (chunk, controller)=>{\n            const message = decoder.decode(chunk);\n            controller.enqueue(encoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n        }\n    });\n}\nvar experimental_StreamData = class extends StreamData2 {\n};\n// streams/anthropic-stream.ts\nfunction parseAnthropicStream() {\n    let previous = \"\";\n    return (data)=>{\n        const json = JSON.parse(data);\n        if (\"error\" in json) {\n            throw new Error(`${json.error.type}: ${json.error.message}`);\n        }\n        if (!(\"completion\" in json)) {\n            return;\n        }\n        const text = json.completion;\n        if (!previous || text.length > previous.length && text.startsWith(previous)) {\n            const delta = text.slice(previous.length);\n            previous = text;\n            return delta;\n        }\n        return text;\n    };\n}\nasync function* streamable(stream) {\n    for await (const chunk of stream){\n        if (\"completion\" in chunk) {\n            const text = chunk.completion;\n            if (text) yield text;\n        } else if (\"delta\" in chunk) {\n            const { delta } = chunk;\n            if (\"text\" in delta) {\n                const text = delta.text;\n                if (text) yield text;\n            }\n        }\n    }\n}\nfunction AnthropicStream(res, cb) {\n    if (Symbol.asyncIterator in res) {\n        return readableFromAsyncIterable(streamable(res)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n    } else {\n        return AIStream(res, parseAnthropicStream(), cb).pipeThrough(createStreamDataTransformer());\n    }\n}\n// streams/assistant-response.ts\n\nfunction AssistantResponse({ threadId, messageId }, process2) {\n    const stream = new ReadableStream({\n        async start (controller) {\n            var _a11;\n            const textEncoder = new TextEncoder();\n            const sendMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", message)));\n            };\n            const sendDataMessage = (message)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"data_message\", message)));\n            };\n            const sendError = (errorMessage)=>{\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"error\", errorMessage)));\n            };\n            const forwardStream = async (stream2)=>{\n                var _a12, _b;\n                let result = void 0;\n                for await (const value of stream2){\n                    switch(value.event){\n                        case \"thread.message.created\":\n                            {\n                                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_message\", {\n                                    id: value.data.id,\n                                    role: \"assistant\",\n                                    content: [\n                                        {\n                                            type: \"text\",\n                                            text: {\n                                                value: \"\"\n                                            }\n                                        }\n                                    ]\n                                })));\n                                break;\n                            }\n                        case \"thread.message.delta\":\n                            {\n                                const content = (_a12 = value.data.delta.content) == null ? void 0 : _a12[0];\n                                if ((content == null ? void 0 : content.type) === \"text\" && ((_b = content.text) == null ? void 0 : _b.value) != null) {\n                                    controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", content.text.value)));\n                                }\n                                break;\n                            }\n                        case \"thread.run.completed\":\n                        case \"thread.run.requires_action\":\n                            {\n                                result = value.data;\n                                break;\n                            }\n                    }\n                }\n                return result;\n            };\n            controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"assistant_control_data\", {\n                threadId,\n                messageId\n            })));\n            try {\n                await process2({\n                    threadId,\n                    messageId,\n                    sendMessage,\n                    sendDataMessage,\n                    forwardStream\n                });\n            } catch (error) {\n                sendError((_a11 = error.message) != null ? _a11 : `${error}`);\n            } finally{\n                controller.close();\n            }\n        },\n        pull (controller) {},\n        cancel () {}\n    });\n    return new Response(stream, {\n        status: 200,\n        headers: {\n            \"Content-Type\": \"text/plain; charset=utf-8\"\n        }\n    });\n}\nvar experimental_AssistantResponse = AssistantResponse;\n// streams/aws-bedrock-stream.ts\nasync function* asDeltaIterable(response, extractTextDeltaFromChunk) {\n    var _a11, _b;\n    const decoder = new TextDecoder();\n    for await (const chunk of (_a11 = response.body) != null ? _a11 : []){\n        const bytes = (_b = chunk.chunk) == null ? void 0 : _b.bytes;\n        if (bytes != null) {\n            const chunkText = decoder.decode(bytes);\n            const chunkJSON = JSON.parse(chunkText);\n            const delta = extractTextDeltaFromChunk(chunkJSON);\n            if (delta != null) {\n                yield delta;\n            }\n        }\n    }\n}\nfunction AWSBedrockAnthropicMessagesStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>{\n        var _a11;\n        return (_a11 = chunk.delta) == null ? void 0 : _a11.text;\n    });\n}\nfunction AWSBedrockAnthropicStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.completion);\n}\nfunction AWSBedrockCohereStream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk == null ? void 0 : chunk.text);\n}\nfunction AWSBedrockLlama2Stream(response, callbacks) {\n    return AWSBedrockStream(response, callbacks, (chunk)=>chunk.generation);\n}\nfunction AWSBedrockStream(response, callbacks, extractTextDeltaFromChunk) {\n    return readableFromAsyncIterable(asDeltaIterable(response, extractTextDeltaFromChunk)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/cohere-stream.ts\nvar utf8Decoder = new TextDecoder(\"utf-8\");\nasync function processLines(lines, controller) {\n    for (const line of lines){\n        const { text, is_finished } = JSON.parse(line);\n        if (!is_finished) {\n            controller.enqueue(text);\n        }\n    }\n}\nasync function readAndProcessLines(reader, controller) {\n    let segment = \"\";\n    while(true){\n        const { value: chunk, done } = await reader.read();\n        if (done) {\n            break;\n        }\n        segment += utf8Decoder.decode(chunk, {\n            stream: true\n        });\n        const linesArray = segment.split(/\\r\\n|\\n|\\r/g);\n        segment = linesArray.pop() || \"\";\n        await processLines(linesArray, controller);\n    }\n    if (segment) {\n        const linesArray = [\n            segment\n        ];\n        await processLines(linesArray, controller);\n    }\n    controller.close();\n}\nfunction createParser2(res) {\n    var _a11;\n    const reader = (_a11 = res.body) == null ? void 0 : _a11.getReader();\n    return new ReadableStream({\n        async start (controller) {\n            if (!reader) {\n                controller.close();\n                return;\n            }\n            await readAndProcessLines(reader, controller);\n        }\n    });\n}\nasync function* streamable2(stream) {\n    for await (const chunk of stream){\n        if (chunk.eventType === \"text-generation\") {\n            const text = chunk.text;\n            if (text) yield text;\n        }\n    }\n}\nfunction CohereStream(reader, callbacks) {\n    if (Symbol.asyncIterator in reader) {\n        return readableFromAsyncIterable(streamable2(reader)).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n    } else {\n        return createParser2(reader).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n    }\n}\n// streams/google-generative-ai-stream.ts\nasync function* streamable3(response) {\n    var _a11, _b, _c;\n    for await (const chunk of response.stream){\n        const parts = (_c = (_b = (_a11 = chunk.candidates) == null ? void 0 : _a11[0]) == null ? void 0 : _b.content) == null ? void 0 : _c.parts;\n        if (parts === void 0) {\n            continue;\n        }\n        const firstPart = parts[0];\n        if (typeof firstPart.text === \"string\") {\n            yield firstPart.text;\n        }\n    }\n}\nfunction GoogleGenerativeAIStream(response, cb) {\n    return readableFromAsyncIterable(streamable3(response)).pipeThrough(createCallbacksTransformer(cb)).pipeThrough(createStreamDataTransformer());\n}\n// streams/huggingface-stream.ts\nfunction createParser3(res) {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a11, _b;\n            const { value, done } = await res.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_b = (_a11 = value.token) == null ? void 0 : _a11.text) != null ? _b : \"\");\n            if (!text) return;\n            if (value.generated_text != null && value.generated_text.length > 0) {\n                return;\n            }\n            if (text === \"</s>\" || text === \"<|endoftext|>\" || text === \"<|end|>\") {\n                return;\n            }\n            controller.enqueue(text);\n        }\n    });\n}\nfunction HuggingFaceStream(res, callbacks) {\n    return createParser3(res).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/inkeep-stream.ts\nfunction InkeepStream(res, callbacks) {\n    if (!res.body) {\n        throw new Error(\"Response body is null\");\n    }\n    let chat_session_id = \"\";\n    let records_cited;\n    const inkeepEventParser = (data, options)=>{\n        var _a11, _b;\n        const { event } = options;\n        if (event === \"records_cited\") {\n            records_cited = JSON.parse(data);\n            (_a11 = callbacks == null ? void 0 : callbacks.onRecordsCited) == null ? void 0 : _a11.call(callbacks, records_cited);\n        }\n        if (event === \"message_chunk\") {\n            const inkeepMessageChunk = JSON.parse(data);\n            chat_session_id = (_b = inkeepMessageChunk.chat_session_id) != null ? _b : chat_session_id;\n            return inkeepMessageChunk.content_chunk;\n        }\n        return;\n    };\n    let { onRecordsCited, ...passThroughCallbacks } = callbacks || {};\n    passThroughCallbacks = {\n        ...passThroughCallbacks,\n        onFinal: (completion)=>{\n            var _a11;\n            const inkeepOnFinalMetadata = {\n                chat_session_id,\n                records_cited\n            };\n            (_a11 = callbacks == null ? void 0 : callbacks.onFinal) == null ? void 0 : _a11.call(callbacks, completion, inkeepOnFinalMetadata);\n        }\n    };\n    return AIStream(res, inkeepEventParser, passThroughCallbacks).pipeThrough(createStreamDataTransformer());\n}\n// streams/langchain-adapter.ts\nvar langchain_adapter_exports = {};\n__export(langchain_adapter_exports, {\n    toAIStream: ()=>toAIStream,\n    toDataStream: ()=>toDataStream,\n    toDataStreamResponse: ()=>toDataStreamResponse\n});\nfunction toAIStream(stream, callbacks) {\n    return toDataStream(stream, callbacks);\n}\nfunction toDataStream(stream, callbacks) {\n    return stream.pipeThrough(new TransformStream({\n        transform: async (value, controller)=>{\n            var _a11;\n            if (typeof value === \"string\") {\n                controller.enqueue(value);\n                return;\n            }\n            if (\"event\" in value) {\n                if (value.event === \"on_chat_model_stream\") {\n                    forwardAIMessageChunk((_a11 = value.data) == null ? void 0 : _a11.chunk, controller);\n                }\n                return;\n            }\n            forwardAIMessageChunk(value, controller);\n        }\n    })).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse(stream, options) {\n    var _a11;\n    const dataStream = toDataStream(stream, options == null ? void 0 : options.callbacks);\n    const data = options == null ? void 0 : options.data;\n    const init = options == null ? void 0 : options.init;\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction forwardAIMessageChunk(chunk, controller) {\n    if (typeof chunk.content === \"string\") {\n        controller.enqueue(chunk.content);\n    } else {\n        const content = chunk.content;\n        for (const item of content){\n            if (item.type === \"text\") {\n                controller.enqueue(item.text);\n            }\n        }\n    }\n}\n// streams/llamaindex-adapter.ts\nvar llamaindex_adapter_exports = {};\n__export(llamaindex_adapter_exports, {\n    toDataStream: ()=>toDataStream2,\n    toDataStreamResponse: ()=>toDataStreamResponse2\n});\nfunction toDataStream2(stream, callbacks) {\n    return toReadableStream(stream).pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\nfunction toDataStreamResponse2(stream, options = {}) {\n    var _a11;\n    const { init, data, callbacks } = options;\n    const dataStream = toDataStream2(stream, callbacks);\n    const responseStream = data ? mergeStreams(data.stream, dataStream) : dataStream;\n    return new Response(responseStream, {\n        status: (_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200,\n        statusText: init == null ? void 0 : init.statusText,\n        headers: prepareResponseHeaders(init, {\n            contentType: \"text/plain; charset=utf-8\",\n            dataStreamVersion: \"v1\"\n        })\n    });\n}\nfunction toReadableStream(res) {\n    const it = res[Symbol.asyncIterator]();\n    const trimStartOfStream = trimStartOfStreamHelper();\n    return new ReadableStream({\n        async pull (controller) {\n            var _a11;\n            const { value, done } = await it.next();\n            if (done) {\n                controller.close();\n                return;\n            }\n            const text = trimStartOfStream((_a11 = value.delta) != null ? _a11 : \"\");\n            if (text) {\n                controller.enqueue(text);\n            }\n        }\n    });\n}\n// streams/langchain-stream.ts\nfunction LangChainStream(callbacks) {\n    const stream = new TransformStream();\n    const writer = stream.writable.getWriter();\n    const runs = /* @__PURE__ */ new Set();\n    const handleError = async (e, runId)=>{\n        runs.delete(runId);\n        await writer.ready;\n        await writer.abort(e);\n    };\n    const handleStart = async (runId)=>{\n        runs.add(runId);\n    };\n    const handleEnd = async (runId)=>{\n        runs.delete(runId);\n        if (runs.size === 0) {\n            await writer.ready;\n            await writer.close();\n        }\n    };\n    return {\n        stream: stream.readable.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer()),\n        writer,\n        handlers: {\n            handleLLMNewToken: async (token)=>{\n                await writer.ready;\n                await writer.write(token);\n            },\n            handleLLMStart: async (_llm, _prompts, runId)=>{\n                handleStart(runId);\n            },\n            handleLLMEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleLLMError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleChainStart: async (_chain, _inputs, runId)=>{\n                handleStart(runId);\n            },\n            handleChainEnd: async (_outputs, runId)=>{\n                await handleEnd(runId);\n            },\n            handleChainError: async (e, runId)=>{\n                await handleError(e, runId);\n            },\n            handleToolStart: async (_tool, _input, runId)=>{\n                handleStart(runId);\n            },\n            handleToolEnd: async (_output, runId)=>{\n                await handleEnd(runId);\n            },\n            handleToolError: async (e, runId)=>{\n                await handleError(e, runId);\n            }\n        }\n    };\n}\n// streams/mistral-stream.ts\nasync function* streamable4(stream) {\n    var _a11, _b;\n    for await (const chunk of stream){\n        const content = (_b = (_a11 = chunk.choices[0]) == null ? void 0 : _a11.delta) == null ? void 0 : _b.content;\n        if (content === void 0 || content === \"\") {\n            continue;\n        }\n        yield content;\n    }\n}\nfunction MistralStream(response, callbacks) {\n    const stream = readableFromAsyncIterable(streamable4(response));\n    return stream.pipeThrough(createCallbacksTransformer(callbacks)).pipeThrough(createStreamDataTransformer());\n}\n// streams/openai-stream.ts\n\nfunction parseOpenAIStream() {\n    const extract = chunkToText();\n    return (data)=>extract(JSON.parse(data));\n}\nasync function* streamable5(stream) {\n    const extract = chunkToText();\n    for await (let chunk of stream){\n        if (\"promptFilterResults\" in chunk) {\n            chunk = {\n                id: chunk.id,\n                created: chunk.created.getDate(),\n                object: chunk.object,\n                // not exposed by Azure API\n                model: chunk.model,\n                // not exposed by Azure API\n                choices: chunk.choices.map((choice)=>{\n                    var _a11, _b, _c, _d, _e, _f, _g;\n                    return {\n                        delta: {\n                            content: (_a11 = choice.delta) == null ? void 0 : _a11.content,\n                            function_call: (_b = choice.delta) == null ? void 0 : _b.functionCall,\n                            role: (_c = choice.delta) == null ? void 0 : _c.role,\n                            tool_calls: ((_e = (_d = choice.delta) == null ? void 0 : _d.toolCalls) == null ? void 0 : _e.length) ? (_g = (_f = choice.delta) == null ? void 0 : _f.toolCalls) == null ? void 0 : _g.map((toolCall, index)=>({\n                                    index,\n                                    id: toolCall.id,\n                                    function: toolCall.function,\n                                    type: toolCall.type\n                                })) : void 0\n                        },\n                        finish_reason: choice.finishReason,\n                        index: choice.index\n                    };\n                })\n            };\n        }\n        const text = extract(chunk);\n        if (text) yield text;\n    }\n}\nfunction chunkToText() {\n    const trimStartOfStream = trimStartOfStreamHelper();\n    let isFunctionStreamingIn;\n    return (json)=>{\n        var _a11, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l, _m, _n, _o, _p, _q, _r;\n        if (isChatCompletionChunk(json)) {\n            const delta = (_a11 = json.choices[0]) == null ? void 0 : _a11.delta;\n            if ((_b = delta.function_call) == null ? void 0 : _b.name) {\n                isFunctionStreamingIn = true;\n                return {\n                    isText: false,\n                    content: `{\"function_call\": {\"name\": \"${delta.function_call.name}\", \"arguments\": \"`\n                };\n            } else if ((_e = (_d = (_c = delta.tool_calls) == null ? void 0 : _c[0]) == null ? void 0 : _d.function) == null ? void 0 : _e.name) {\n                isFunctionStreamingIn = true;\n                const toolCall = delta.tool_calls[0];\n                if (toolCall.index === 0) {\n                    return {\n                        isText: false,\n                        content: `{\"tool_calls\":[ {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_f = toolCall.function) == null ? void 0 : _f.name}\", \"arguments\": \"`\n                    };\n                } else {\n                    return {\n                        isText: false,\n                        content: `\"}}, {\"id\": \"${toolCall.id}\", \"type\": \"function\", \"function\": {\"name\": \"${(_g = toolCall.function) == null ? void 0 : _g.name}\", \"arguments\": \"`\n                    };\n                }\n            } else if ((_h = delta.function_call) == null ? void 0 : _h.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_i = delta.function_call) == null ? void 0 : _i.arguments)\n                };\n            } else if ((_l = (_k = (_j = delta.tool_calls) == null ? void 0 : _j[0]) == null ? void 0 : _k.function) == null ? void 0 : _l.arguments) {\n                return {\n                    isText: false,\n                    content: cleanupArguments((_o = (_n = (_m = delta.tool_calls) == null ? void 0 : _m[0]) == null ? void 0 : _n.function) == null ? void 0 : _o.arguments)\n                };\n            } else if (isFunctionStreamingIn && (((_p = json.choices[0]) == null ? void 0 : _p.finish_reason) === \"function_call\" || ((_q = json.choices[0]) == null ? void 0 : _q.finish_reason) === \"stop\")) {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}'\n                };\n            } else if (isFunctionStreamingIn && ((_r = json.choices[0]) == null ? void 0 : _r.finish_reason) === \"tool_calls\") {\n                isFunctionStreamingIn = false;\n                return {\n                    isText: false,\n                    content: '\"}}]}'\n                };\n            }\n        }\n        const text = trimStartOfStream(isChatCompletionChunk(json) && json.choices[0].delta.content ? json.choices[0].delta.content : isCompletion(json) ? json.choices[0].text : \"\");\n        return text;\n    };\n    function cleanupArguments(argumentChunk) {\n        let escapedPartialJson = argumentChunk.replace(/\\\\/g, \"\\\\\\\\\").replace(/\\//g, \"\\\\/\").replace(/\"/g, '\\\\\"').replace(/\\n/g, \"\\\\n\").replace(/\\r/g, \"\\\\r\").replace(/\\t/g, \"\\\\t\").replace(/\\f/g, \"\\\\f\");\n        return `${escapedPartialJson}`;\n    }\n}\nvar __internal__OpenAIFnMessagesSymbol = Symbol(\"internal_openai_fn_messages\");\nfunction isChatCompletionChunk(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"delta\" in data.choices[0];\n}\nfunction isCompletion(data) {\n    return \"choices\" in data && data.choices && data.choices[0] && \"text\" in data.choices[0];\n}\nfunction OpenAIStream(res, callbacks) {\n    const cb = callbacks;\n    let stream;\n    if (Symbol.asyncIterator in res) {\n        stream = readableFromAsyncIterable(streamable5(res)).pipeThrough(createCallbacksTransformer((cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        }));\n    } else {\n        stream = AIStream(res, parseOpenAIStream(), (cb == null ? void 0 : cb.experimental_onFunctionCall) || (cb == null ? void 0 : cb.experimental_onToolCall) ? {\n            ...cb,\n            onFinal: void 0\n        } : {\n            ...cb\n        });\n    }\n    if (cb && (cb.experimental_onFunctionCall || cb.experimental_onToolCall)) {\n        const functionCallTransformer = createFunctionCallTransformer(cb);\n        return stream.pipeThrough(functionCallTransformer);\n    } else {\n        return stream.pipeThrough(createStreamDataTransformer());\n    }\n}\nfunction createFunctionCallTransformer(callbacks) {\n    const textEncoder = new TextEncoder();\n    let isFirstChunk = true;\n    let aggregatedResponse = \"\";\n    let aggregatedFinalCompletionResponse = \"\";\n    let isFunctionStreamingIn = false;\n    let functionCallMessages = callbacks[__internal__OpenAIFnMessagesSymbol] || [];\n    const decode = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.createChunkDecoder)();\n    return new TransformStream({\n        async transform (chunk, controller) {\n            const message = decode(chunk);\n            aggregatedFinalCompletionResponse += message;\n            const shouldHandleAsFunction = isFirstChunk && (message.startsWith('{\"function_call\":') || message.startsWith('{\"tool_calls\":'));\n            if (shouldHandleAsFunction) {\n                isFunctionStreamingIn = true;\n                aggregatedResponse += message;\n                isFirstChunk = false;\n                return;\n            }\n            if (!isFunctionStreamingIn) {\n                controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", message)));\n                return;\n            } else {\n                aggregatedResponse += message;\n            }\n        },\n        async flush (controller) {\n            try {\n                if (!isFirstChunk && isFunctionStreamingIn && (callbacks.experimental_onFunctionCall || callbacks.experimental_onToolCall)) {\n                    isFunctionStreamingIn = false;\n                    const payload = JSON.parse(aggregatedResponse);\n                    let newFunctionCallMessages = [\n                        ...functionCallMessages\n                    ];\n                    let functionResponse = void 0;\n                    if (callbacks.experimental_onFunctionCall) {\n                        if (payload.function_call === void 0) {\n                            console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        }\n                        const argumentsPayload = JSON.parse(payload.function_call.arguments);\n                        functionResponse = await callbacks.experimental_onFunctionCall({\n                            name: payload.function_call.name,\n                            arguments: argumentsPayload\n                        }, (result)=>{\n                            newFunctionCallMessages = [\n                                ...functionCallMessages,\n                                {\n                                    role: \"assistant\",\n                                    content: \"\",\n                                    function_call: payload.function_call\n                                },\n                                {\n                                    role: \"function\",\n                                    name: payload.function_call.name,\n                                    content: JSON.stringify(result)\n                                }\n                            ];\n                            return newFunctionCallMessages;\n                        });\n                    }\n                    if (callbacks.experimental_onToolCall) {\n                        const toolCalls = {\n                            tools: []\n                        };\n                        for (const tool2 of payload.tool_calls){\n                            toolCalls.tools.push({\n                                id: tool2.id,\n                                type: \"function\",\n                                func: {\n                                    name: tool2.function.name,\n                                    arguments: JSON.parse(tool2.function.arguments)\n                                }\n                            });\n                        }\n                        let responseIndex = 0;\n                        try {\n                            functionResponse = await callbacks.experimental_onToolCall(toolCalls, (result)=>{\n                                if (result) {\n                                    const { tool_call_id, function_name, tool_call_result } = result;\n                                    newFunctionCallMessages = [\n                                        ...newFunctionCallMessages,\n                                        // Only append the assistant message if it's the first response\n                                        ...responseIndex === 0 ? [\n                                            {\n                                                role: \"assistant\",\n                                                content: \"\",\n                                                tool_calls: payload.tool_calls.map((tc)=>({\n                                                        id: tc.id,\n                                                        type: \"function\",\n                                                        function: {\n                                                            name: tc.function.name,\n                                                            // we send the arguments an object to the user, but as the API expects a string, we need to stringify it\n                                                            arguments: JSON.stringify(tc.function.arguments)\n                                                        }\n                                                    }))\n                                            }\n                                        ] : [],\n                                        // Append the function call result message\n                                        {\n                                            role: \"tool\",\n                                            tool_call_id,\n                                            name: function_name,\n                                            content: JSON.stringify(tool_call_result)\n                                        }\n                                    ];\n                                    responseIndex++;\n                                }\n                                return newFunctionCallMessages;\n                            });\n                        } catch (e) {\n                            console.error(\"Error calling experimental_onToolCall:\", e);\n                        }\n                    }\n                    if (!functionResponse) {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(payload.function_call ? \"function_call\" : \"tool_calls\", // parse to prevent double-encoding:\n                        JSON.parse(aggregatedResponse))));\n                        return;\n                    } else if (typeof functionResponse === \"string\") {\n                        controller.enqueue(textEncoder.encode((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_4__.formatStreamPart)(\"text\", functionResponse)));\n                        aggregatedFinalCompletionResponse = functionResponse;\n                        return;\n                    }\n                    const filteredCallbacks = {\n                        ...callbacks,\n                        onStart: void 0\n                    };\n                    callbacks.onFinal = void 0;\n                    const openAIStream = OpenAIStream(functionResponse, {\n                        ...filteredCallbacks,\n                        [__internal__OpenAIFnMessagesSymbol]: newFunctionCallMessages\n                    });\n                    const reader = openAIStream.getReader();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        controller.enqueue(value);\n                    }\n                }\n            } finally{\n                if (callbacks.onFinal && aggregatedFinalCompletionResponse) {\n                    await callbacks.onFinal(aggregatedFinalCompletionResponse);\n                }\n            }\n        }\n    });\n}\n// streams/replicate-stream.ts\nasync function ReplicateStream(res, cb, options) {\n    var _a11;\n    const url = (_a11 = res.urls) == null ? void 0 : _a11.stream;\n    if (!url) {\n        if (res.error) throw new Error(res.error);\n        else throw new Error(\"Missing stream URL in Replicate response\");\n    }\n    const eventStream = await fetch(url, {\n        method: \"GET\",\n        headers: {\n            Accept: \"text/event-stream\",\n            ...options == null ? void 0 : options.headers\n        }\n    });\n    return AIStream(eventStream, void 0, cb).pipeThrough(createStreamDataTransformer());\n}\n// streams/stream-to-response.ts\nfunction streamToResponse(res, response, init, data) {\n    var _a11;\n    response.writeHead((_a11 = init == null ? void 0 : init.status) != null ? _a11 : 200, {\n        \"Content-Type\": \"text/plain; charset=utf-8\",\n        ...init == null ? void 0 : init.headers\n    });\n    let processedStream = res;\n    if (data) {\n        processedStream = mergeStreams(data.stream, res);\n    }\n    const reader = processedStream.getReader();\n    function read() {\n        reader.read().then(({ done, value })=>{\n            if (done) {\n                response.end();\n                return;\n            }\n            response.write(value);\n            read();\n        });\n    }\n    read();\n}\n// streams/streaming-text-response.ts\nvar StreamingTextResponse = class extends Response {\n    constructor(res, init, data){\n        let processedStream = res;\n        if (data) {\n            processedStream = mergeStreams(data.stream, res);\n        }\n        super(processedStream, {\n            ...init,\n            status: 200,\n            headers: prepareResponseHeaders(init, {\n                contentType: \"text/plain; charset=utf-8\"\n            })\n        });\n    }\n};\n// streams/index.ts\nvar generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\nvar nanoid = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId;\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYWkvZGlzdC9pbmRleC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUFBLElBQUlBLFlBQVlDLE9BQU9DLGNBQWM7QUFDckMsSUFBSUMsV0FBVyxDQUFDQyxRQUFRQztJQUN0QixJQUFLLElBQUlDLFVBQVVELElBQ2pCTCxVQUFVSSxRQUFRRSxRQUFRO1FBQUVDLEtBQUtGLEdBQUcsQ0FBQ0MsT0FBTztRQUFFRSxZQUFZO0lBQUs7QUFDbkU7QUFFQSxtQkFBbUI7QUFNTztBQUM0QztBQUV0RSxnQkFBZ0I7QUFDOEI7QUFFOUMseUNBQXlDO0FBQ087QUFDdUI7QUFFdkUsZ0JBQWdCO0FBQ2hCLGVBQWVXLE1BQU1DLFNBQVM7SUFDNUIsT0FBT0EsY0FBYyxLQUFLLElBQUlDLFFBQVFDLE9BQU8sS0FBSyxJQUFJRCxRQUFRLENBQUNDLFVBQVlDLFdBQVdELFNBQVNGO0FBQ2pHO0FBRUEsc0JBQXNCO0FBQ3dCO0FBQzlDLElBQUlLLE9BQU87QUFDWCxJQUFJQyxTQUFTLENBQUMsZ0JBQWdCLEVBQUVELEtBQUssQ0FBQztBQUN0QyxJQUFJRSxTQUFTQyxPQUFPQyxHQUFHLENBQUNIO0FBQ3hCLElBQUlJO0FBQ0osSUFBSUMsYUFBYSxjQUFjUCx3REFBVUE7SUFDdkNRLFlBQVksRUFDVkMsT0FBTyxFQUNQQyxNQUFNLEVBQ05DLE1BQU0sRUFDUCxDQUFFO1FBQ0QsS0FBSyxDQUFDO1lBQUVWO1lBQU1RO1FBQVE7UUFDdEIsSUFBSSxDQUFDSCxHQUFHLEdBQUc7UUFDWCxJQUFJLENBQUNJLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLE1BQU0sR0FBR0E7UUFDZCxJQUFJLENBQUNDLFNBQVMsR0FBR0QsTUFBTSxDQUFDQSxPQUFPRSxNQUFNLEdBQUcsRUFBRTtJQUM1QztJQUNBLE9BQU9DLFdBQVdD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azovL25leHRqcy1maXJzdF9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL2FpL2Rpc3QvaW5kZXgubWpzPzgxZWIiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIF9fZGVmUHJvcCA9IE9iamVjdC5kZWZpbmVQcm9wZXJ0eTtcbnZhciBfX2V4cG9ydCA9ICh0YXJnZXQsIGFsbCkgPT4ge1xuICBmb3IgKHZhciBuYW1lMTEgaW4gYWxsKVxuICAgIF9fZGVmUHJvcCh0YXJnZXQsIG5hbWUxMSwgeyBnZXQ6IGFsbFtuYW1lMTFdLCBlbnVtZXJhYmxlOiB0cnVlIH0pO1xufTtcblxuLy8gc3RyZWFtcy9pbmRleC50c1xuaW1wb3J0IHtcbiAgZm9ybWF0U3RyZWFtUGFydCxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICByZWFkRGF0YVN0cmVhbSxcbiAgcHJvY2Vzc0RhdGFQcm90b2NvbFJlc3BvbnNlXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRJbXBsIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gY29yZS9pbmRleC50c1xuaW1wb3J0IHsganNvblNjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIHV0aWwvcmV0cnktd2l0aC1leHBvbmVudGlhbC1iYWNrb2ZmLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgZ2V0RXJyb3JNZXNzYWdlLCBpc0Fib3J0RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyB1dGlsL2RlbGF5LnRzXG5hc3luYyBmdW5jdGlvbiBkZWxheShkZWxheUluTXMpIHtcbiAgcmV0dXJuIGRlbGF5SW5NcyA9PT0gdm9pZCAwID8gUHJvbWlzZS5yZXNvbHZlKCkgOiBuZXcgUHJvbWlzZSgocmVzb2x2ZSkgPT4gc2V0VGltZW91dChyZXNvbHZlLCBkZWxheUluTXMpKTtcbn1cblxuLy8gdXRpbC9yZXRyeS1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZSA9IFwiQUlfUmV0cnlFcnJvclwiO1xudmFyIG1hcmtlciA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lfWA7XG52YXIgc3ltYm9sID0gU3ltYm9sLmZvcihtYXJrZXIpO1xudmFyIF9hO1xudmFyIFJldHJ5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgbWVzc2FnZSxcbiAgICByZWFzb24sXG4gICAgZXJyb3JzXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIHRoaXMuZXJyb3JzID0gZXJyb3JzO1xuICAgIHRoaXMubGFzdEVycm9yID0gZXJyb3JzW2Vycm9ycy5sZW5ndGggLSAxXTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNSZXRyeUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZSAmJiB0eXBlb2YgZXJyb3IucmVhc29uID09PSBcInN0cmluZ1wiICYmIEFycmF5LmlzQXJyYXkoZXJyb3IuZXJyb3JzKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHJlYXNvbjogdGhpcy5yZWFzb24sXG4gICAgICBsYXN0RXJyb3I6IHRoaXMubGFzdEVycm9yLFxuICAgICAgZXJyb3JzOiB0aGlzLmVycm9yc1xuICAgIH07XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcblxuLy8gdXRpbC9yZXRyeS13aXRoLWV4cG9uZW50aWFsLWJhY2tvZmYudHNcbnZhciByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYgPSAoe1xuICBtYXhSZXRyaWVzID0gMixcbiAgaW5pdGlhbERlbGF5SW5NcyA9IDJlMyxcbiAgYmFja29mZkZhY3RvciA9IDJcbn0gPSB7fSkgPT4gYXN5bmMgKGYpID0+IF9yZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoZiwge1xuICBtYXhSZXRyaWVzLFxuICBkZWxheUluTXM6IGluaXRpYWxEZWxheUluTXMsXG4gIGJhY2tvZmZGYWN0b3Jcbn0pO1xuYXN5bmMgZnVuY3Rpb24gX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZihmLCB7XG4gIG1heFJldHJpZXMsXG4gIGRlbGF5SW5NcyxcbiAgYmFja29mZkZhY3RvclxufSwgZXJyb3JzID0gW10pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gYXdhaXQgZigpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKG1heFJldHJpZXMgPT09IDApIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBjb25zdCBlcnJvck1lc3NhZ2UgPSBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpO1xuICAgIGNvbnN0IG5ld0Vycm9ycyA9IFsuLi5lcnJvcnMsIGVycm9yXTtcbiAgICBjb25zdCB0cnlOdW1iZXIgPSBuZXdFcnJvcnMubGVuZ3RoO1xuICAgIGlmICh0cnlOdW1iZXIgPiBtYXhSZXRyaWVzKSB7XG4gICAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IGBGYWlsZWQgYWZ0ZXIgJHt0cnlOdW1iZXJ9IGF0dGVtcHRzLiBMYXN0IGVycm9yOiAke2Vycm9yTWVzc2FnZX1gLFxuICAgICAgICByZWFzb246IFwibWF4UmV0cmllc0V4Y2VlZGVkXCIsXG4gICAgICAgIGVycm9yczogbmV3RXJyb3JzXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSAmJiBlcnJvci5pc1JldHJ5YWJsZSA9PT0gdHJ1ZSAmJiB0cnlOdW1iZXIgPD0gbWF4UmV0cmllcykge1xuICAgICAgYXdhaXQgZGVsYXkoZGVsYXlJbk1zKTtcbiAgICAgIHJldHVybiBfcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKFxuICAgICAgICBmLFxuICAgICAgICB7IG1heFJldHJpZXMsIGRlbGF5SW5NczogYmFja29mZkZhY3RvciAqIGRlbGF5SW5NcywgYmFja29mZkZhY3RvciB9LFxuICAgICAgICBuZXdFcnJvcnNcbiAgICAgICk7XG4gICAgfVxuICAgIGlmICh0cnlOdW1iZXIgPT09IDEpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgUmV0cnlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgRmFpbGVkIGFmdGVyICR7dHJ5TnVtYmVyfSBhdHRlbXB0cyB3aXRoIG5vbi1yZXRyeWFibGUgZXJyb3I6ICcke2Vycm9yTWVzc2FnZX0nYCxcbiAgICAgIHJlYXNvbjogXCJlcnJvck5vdFJldHJ5YWJsZVwiLFxuICAgICAgZXJyb3JzOiBuZXdFcnJvcnNcbiAgICB9KTtcbiAgfVxufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9hc3NlbWJsZS1vcGVyYXRpb24tbmFtZS50c1xuZnVuY3Rpb24gYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgb3BlcmF0aW9uSWQsXG4gIHRlbGVtZXRyeVxufSkge1xuICByZXR1cm4ge1xuICAgIC8vIHN0YW5kYXJkaXplZCBvcGVyYXRpb24gYW5kIHJlc291cmNlIG5hbWU6XG4gICAgXCJvcGVyYXRpb24ubmFtZVwiOiBgJHtvcGVyYXRpb25JZH0keyh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkKSAhPSBudWxsID8gYCAke3RlbGVtZXRyeS5mdW5jdGlvbklkfWAgOiBcIlwifWAsXG4gICAgXCJyZXNvdXJjZS5uYW1lXCI6IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5LmZ1bmN0aW9uSWQsXG4gICAgLy8gZGV0YWlsZWQsIEFJIFNESyBzcGVjaWZpYyBkYXRhOlxuICAgIFwiYWkub3BlcmF0aW9uSWRcIjogb3BlcmF0aW9uSWQsXG4gICAgXCJhaS50ZWxlbWV0cnkuZnVuY3Rpb25JZFwiOiB0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5mdW5jdGlvbklkXG4gIH07XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L2dldC1iYXNlLXRlbGVtZXRyeS1hdHRyaWJ1dGVzLnRzXG5mdW5jdGlvbiBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gIG1vZGVsLFxuICBzZXR0aW5ncyxcbiAgdGVsZW1ldHJ5LFxuICBoZWFkZXJzXG59KSB7XG4gIHZhciBfYTExO1xuICByZXR1cm4ge1xuICAgIFwiYWkubW9kZWwucHJvdmlkZXJcIjogbW9kZWwucHJvdmlkZXIsXG4gICAgXCJhaS5tb2RlbC5pZFwiOiBtb2RlbC5tb2RlbElkLFxuICAgIC8vIHNldHRpbmdzOlxuICAgIC4uLk9iamVjdC5lbnRyaWVzKHNldHRpbmdzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgYXR0cmlidXRlc1tgYWkuc2V0dGluZ3MuJHtrZXl9YF0gPSB2YWx1ZTtcbiAgICAgIHJldHVybiBhdHRyaWJ1dGVzO1xuICAgIH0sIHt9KSxcbiAgICAvLyBhZGQgbWV0YWRhdGEgYXMgYXR0cmlidXRlczpcbiAgICAuLi5PYmplY3QuZW50cmllcygoX2ExMSA9IHRlbGVtZXRyeSA9PSBudWxsID8gdm9pZCAwIDogdGVsZW1ldHJ5Lm1ldGFkYXRhKSAhPSBudWxsID8gX2ExMSA6IHt9KS5yZWR1Y2UoXG4gICAgICAoYXR0cmlidXRlcywgW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGF0dHJpYnV0ZXNbYGFpLnRlbGVtZXRyeS5tZXRhZGF0YS4ke2tleX1gXSA9IHZhbHVlO1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICAgIH0sXG4gICAgICB7fVxuICAgICksXG4gICAgLy8gcmVxdWVzdCBoZWFkZXJzXG4gICAgLi4uT2JqZWN0LmVudHJpZXMoaGVhZGVycyAhPSBudWxsID8gaGVhZGVycyA6IHt9KS5yZWR1Y2UoKGF0dHJpYnV0ZXMsIFtrZXksIHZhbHVlXSkgPT4ge1xuICAgICAgaWYgKHZhbHVlICE9PSB2b2lkIDApIHtcbiAgICAgICAgYXR0cmlidXRlc1tgYWkucmVxdWVzdC5oZWFkZXJzLiR7a2V5fWBdID0gdmFsdWU7XG4gICAgICB9XG4gICAgICByZXR1cm4gYXR0cmlidXRlcztcbiAgICB9LCB7fSlcbiAgfTtcbn1cblxuLy8gY29yZS90ZWxlbWV0cnkvZ2V0LXRyYWNlci50c1xuaW1wb3J0IHsgdHJhY2UgfSBmcm9tIFwiQG9wZW50ZWxlbWV0cnkvYXBpXCI7XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L25vb3AtdHJhY2VyLnRzXG52YXIgbm9vcFRyYWNlciA9IHtcbiAgc3RhcnRTcGFuKCkge1xuICAgIHJldHVybiBub29wU3BhbjtcbiAgfSxcbiAgc3RhcnRBY3RpdmVTcGFuKG5hbWUxMSwgYXJnMSwgYXJnMiwgYXJnMykge1xuICAgIGlmICh0eXBlb2YgYXJnMSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMShub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMihub29wU3Bhbik7XG4gICAgfVxuICAgIGlmICh0eXBlb2YgYXJnMyA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICByZXR1cm4gYXJnMyhub29wU3Bhbik7XG4gICAgfVxuICB9XG59O1xudmFyIG5vb3BTcGFuID0ge1xuICBzcGFuQ29udGV4dCgpIHtcbiAgICByZXR1cm4gbm9vcFNwYW5Db250ZXh0O1xuICB9LFxuICBzZXRBdHRyaWJ1dGUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIHNldEF0dHJpYnV0ZXMoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGFkZEV2ZW50KCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBhZGRMaW5rcygpIHtcbiAgICByZXR1cm4gdGhpcztcbiAgfSxcbiAgc2V0U3RhdHVzKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICB1cGRhdGVOYW1lKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9LFxuICBlbmQoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG4gIGlzUmVjb3JkaW5nKCkge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcbiAgcmVjb3JkRXhjZXB0aW9uKCkge1xuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xudmFyIG5vb3BTcGFuQ29udGV4dCA9IHtcbiAgdHJhY2VJZDogXCJcIixcbiAgc3BhbklkOiBcIlwiLFxuICB0cmFjZUZsYWdzOiAwXG59O1xuXG4vLyBjb3JlL3RlbGVtZXRyeS9nZXQtdHJhY2VyLnRzXG5mdW5jdGlvbiBnZXRUcmFjZXIoe1xuICBpc0VuYWJsZWQgPSBmYWxzZSxcbiAgdHJhY2VyXG59ID0ge30pIHtcbiAgaWYgKCFpc0VuYWJsZWQpIHtcbiAgICByZXR1cm4gbm9vcFRyYWNlcjtcbiAgfVxuICBpZiAodHJhY2VyKSB7XG4gICAgcmV0dXJuIHRyYWNlcjtcbiAgfVxuICByZXR1cm4gdHJhY2UuZ2V0VHJhY2VyKFwiYWlcIik7XG59XG5cbi8vIGNvcmUvdGVsZW1ldHJ5L3JlY29yZC1zcGFuLnRzXG5pbXBvcnQgeyBTcGFuU3RhdHVzQ29kZSB9IGZyb20gXCJAb3BlbnRlbGVtZXRyeS9hcGlcIjtcbmZ1bmN0aW9uIHJlY29yZFNwYW4oe1xuICBuYW1lOiBuYW1lMTEsXG4gIHRyYWNlcixcbiAgYXR0cmlidXRlcyxcbiAgZm4sXG4gIGVuZFdoZW5Eb25lID0gdHJ1ZVxufSkge1xuICByZXR1cm4gdHJhY2VyLnN0YXJ0QWN0aXZlU3BhbihuYW1lMTEsIHsgYXR0cmlidXRlcyB9LCBhc3luYyAoc3BhbikgPT4ge1xuICAgIHRyeSB7XG4gICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBmbihzcGFuKTtcbiAgICAgIGlmIChlbmRXaGVuRG9uZSkge1xuICAgICAgICBzcGFuLmVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgICBzcGFuLnJlY29yZEV4Y2VwdGlvbih7XG4gICAgICAgICAgICBuYW1lOiBlcnJvci5uYW1lLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZSxcbiAgICAgICAgICAgIHN0YWNrOiBlcnJvci5zdGFja1xuICAgICAgICAgIH0pO1xuICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHtcbiAgICAgICAgICAgIGNvZGU6IFNwYW5TdGF0dXNDb2RlLkVSUk9SLFxuICAgICAgICAgICAgbWVzc2FnZTogZXJyb3IubWVzc2FnZVxuICAgICAgICAgIH0pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHNwYW4uc2V0U3RhdHVzKHsgY29kZTogU3BhblN0YXR1c0NvZGUuRVJST1IgfSk7XG4gICAgICAgIH1cbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIHNwYW4uZW5kKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL3RlbGVtZXRyeS9zZWxlY3QtdGVsZW1ldHJ5LWF0dHJpYnV0ZXMudHNcbmZ1bmN0aW9uIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICB0ZWxlbWV0cnksXG4gIGF0dHJpYnV0ZXNcbn0pIHtcbiAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5pc0VuYWJsZWQpICE9PSB0cnVlKSB7XG4gICAgcmV0dXJuIHt9O1xuICB9XG4gIHJldHVybiBPYmplY3QuZW50cmllcyhhdHRyaWJ1dGVzKS5yZWR1Y2UoKGF0dHJpYnV0ZXMyLCBba2V5LCB2YWx1ZV0pID0+IHtcbiAgICBpZiAodmFsdWUgPT09IHZvaWQgMCkge1xuICAgICAgcmV0dXJuIGF0dHJpYnV0ZXMyO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIFwiaW5wdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUuaW5wdXQgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgaWYgKCh0ZWxlbWV0cnkgPT0gbnVsbCA/IHZvaWQgMCA6IHRlbGVtZXRyeS5yZWNvcmRJbnB1dHMpID09PSBmYWxzZSkge1xuICAgICAgICByZXR1cm4gYXR0cmlidXRlczI7XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5pbnB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgXCJvdXRwdXRcIiBpbiB2YWx1ZSAmJiB0eXBlb2YgdmFsdWUub3V0cHV0ID09PSBcImZ1bmN0aW9uXCIpIHtcbiAgICAgIGlmICgodGVsZW1ldHJ5ID09IG51bGwgPyB2b2lkIDAgOiB0ZWxlbWV0cnkucmVjb3JkT3V0cHV0cykgPT09IGZhbHNlKSB7XG4gICAgICAgIHJldHVybiBhdHRyaWJ1dGVzMjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IHZhbHVlLm91dHB1dCgpO1xuICAgICAgcmV0dXJuIHJlc3VsdCA9PT0gdm9pZCAwID8gYXR0cmlidXRlczIgOiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogcmVzdWx0IH07XG4gICAgfVxuICAgIHJldHVybiB7IC4uLmF0dHJpYnV0ZXMyLCBba2V5XTogdmFsdWUgfTtcbiAgfSwge30pO1xufVxuXG4vLyBjb3JlL2VtYmVkL2VtYmVkLnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZCh7XG4gIG1vZGVsLFxuICB2YWx1ZSxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeVxufSkge1xuICBjb25zdCBiYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyA9IGdldEJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICBtb2RlbCxcbiAgICB0ZWxlbWV0cnksXG4gICAgaGVhZGVycyxcbiAgICBzZXR0aW5nczogeyBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5lbWJlZFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZFwiLCB0ZWxlbWV0cnkgfSksXG4gICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICBcImFpLnZhbHVlXCI6IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbHVlKSB9XG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgeyBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICgpID0+IChcbiAgICAgICAgICAvLyBuZXN0ZWQgc3BhbnMgdG8gYWxpZ24gd2l0aCB0aGUgZW1iZWRNYW55IHRlbGVtZXRyeSBkYXRhOlxuICAgICAgICAgIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZC5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkLmRvRW1iZWRcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIC8vIHNwZWNpZmljIHNldHRpbmdzIHRoYXQgb25seSBtYWtlIHNlbnNlIG9uIHRoZSBvdXRlciBsZXZlbDpcbiAgICAgICAgICAgICAgICBcImFpLnZhbHVlc1wiOiB7IGlucHV0OiAoKSA9PiBbSlNPTi5zdHJpbmdpZnkodmFsdWUpXSB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgZm46IGFzeW5jIChkb0VtYmVkU3BhbikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2ExMTtcbiAgICAgICAgICAgICAgY29uc3QgbW9kZWxSZXNwb25zZSA9IGF3YWl0IG1vZGVsLmRvRW1iZWQoe1xuICAgICAgICAgICAgICAgIHZhbHVlczogW3ZhbHVlXSxcbiAgICAgICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBjb25zdCBlbWJlZGRpbmcyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzWzBdO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMSA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTExIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzLm1hcChcbiAgICAgICAgICAgICAgICAgICAgICAgIChlbWJlZGRpbmczKSA9PiBKU09OLnN0cmluZ2lmeShlbWJlZGRpbmczKVxuICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgZW1iZWRkaW5nOiBlbWJlZGRpbmcyLFxuICAgICAgICAgICAgICAgIHVzYWdlOiB1c2FnZTIsXG4gICAgICAgICAgICAgICAgcmF3UmVzcG9uc2U6IG1vZGVsUmVzcG9uc2UucmF3UmVzcG9uc2VcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICApO1xuICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgXCJhaS5lbWJlZGRpbmdcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykgfSxcbiAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlLnRva2Vuc1xuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRFbWJlZFJlc3VsdCh7IHZhbHVlLCBlbWJlZGRpbmcsIHVzYWdlLCByYXdSZXNwb25zZSB9KTtcbiAgICB9XG4gIH0pO1xufVxudmFyIERlZmF1bHRFbWJlZFJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWUgPSBvcHRpb25zLnZhbHVlO1xuICAgIHRoaXMuZW1iZWRkaW5nID0gb3B0aW9ucy5lbWJlZGRpbmc7XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IG9wdGlvbnMucmF3UmVzcG9uc2U7XG4gIH1cbn07XG5cbi8vIGNvcmUvdXRpbC9zcGxpdC1hcnJheS50c1xuZnVuY3Rpb24gc3BsaXRBcnJheShhcnJheSwgY2h1bmtTaXplKSB7XG4gIGlmIChjaHVua1NpemUgPD0gMCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcImNodW5rU2l6ZSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAwXCIpO1xuICB9XG4gIGNvbnN0IHJlc3VsdCA9IFtdO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGFycmF5Lmxlbmd0aDsgaSArPSBjaHVua1NpemUpIHtcbiAgICByZXN1bHQucHVzaChhcnJheS5zbGljZShpLCBpICsgY2h1bmtTaXplKSk7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gY29yZS9lbWJlZC9lbWJlZC1tYW55LnRzXG5hc3luYyBmdW5jdGlvbiBlbWJlZE1hbnkoe1xuICBtb2RlbCxcbiAgdmFsdWVzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5XG59KSB7XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIHJldHVybiByZWNvcmRTcGFuKHtcbiAgICBuYW1lOiBcImFpLmVtYmVkTWFueVwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoeyBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnlcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnZhbHVlc1wiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICBjb25zdCByZXRyeSA9IHJldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZih7IG1heFJldHJpZXMgfSk7XG4gICAgICBjb25zdCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG1vZGVsLm1heEVtYmVkZGluZ3NQZXJDYWxsO1xuICAgICAgaWYgKG1heEVtYmVkZGluZ3NQZXJDYWxsID09IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSA9IGF3YWl0IHJldHJ5KCgpID0+IHtcbiAgICAgICAgICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgICAgICAgICBuYW1lOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmVtYmVkTWFueS5kb0VtYmVkXCIsXG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAvLyBzcGVjaWZpYyBzZXR0aW5ncyB0aGF0IG9ubHkgbWFrZSBzZW5zZSBvbiB0aGUgb3V0ZXIgbGV2ZWw6XG4gICAgICAgICAgICAgICAgXCJhaS52YWx1ZXNcIjoge1xuICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHZhbHVlcy5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXMsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgZW1iZWRkaW5nczMgPSBtb2RlbFJlc3BvbnNlLmVtYmVkZGluZ3M7XG4gICAgICAgICAgICAgIGNvbnN0IHVzYWdlMiA9IChfYTExID0gbW9kZWxSZXNwb25zZS51c2FnZSkgIT0gbnVsbCA/IF9hMTEgOiB7IHRva2VuczogTmFOIH07XG4gICAgICAgICAgICAgIGRvRW1iZWRTcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMy5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UyLnRva2Vuc1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIHJldHVybiB7IGVtYmVkZGluZ3M6IGVtYmVkZGluZ3MzLCB1c2FnZTogdXNhZ2UyIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgIFwiYWkuZW1iZWRkaW5nc1wiOiB7XG4gICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBlbWJlZGRpbmdzMi5tYXAoKGVtYmVkZGluZykgPT4gSlNPTi5zdHJpbmdpZnkoZW1iZWRkaW5nKSlcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdXNhZ2UudG9rZW5zXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuIG5ldyBEZWZhdWx0RW1iZWRNYW55UmVzdWx0KHsgdmFsdWVzLCBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2UgfSk7XG4gICAgICB9XG4gICAgICBjb25zdCB2YWx1ZUNodW5rcyA9IHNwbGl0QXJyYXkodmFsdWVzLCBtYXhFbWJlZGRpbmdzUGVyQ2FsbCk7XG4gICAgICBjb25zdCBlbWJlZGRpbmdzID0gW107XG4gICAgICBsZXQgdG9rZW5zID0gMDtcbiAgICAgIGZvciAoY29uc3QgY2h1bmsgb2YgdmFsdWVDaHVua3MpIHtcbiAgICAgICAgY29uc3QgeyBlbWJlZGRpbmdzOiByZXNwb25zZUVtYmVkZGluZ3MsIHVzYWdlIH0gPSBhd2FpdCByZXRyeSgoKSA9PiB7XG4gICAgICAgICAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5lbWJlZE1hbnkuZG9FbWJlZFwiLFxuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICAgICAgICAgIFwiYWkudmFsdWVzXCI6IHtcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBjaHVuay5tYXAoKHZhbHVlKSA9PiBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgIGZuOiBhc3luYyAoZG9FbWJlZFNwYW4pID0+IHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IG1vZGVsUmVzcG9uc2UgPSBhd2FpdCBtb2RlbC5kb0VtYmVkKHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IGNodW5rLFxuICAgICAgICAgICAgICAgIGFib3J0U2lnbmFsLFxuICAgICAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIGNvbnN0IGVtYmVkZGluZ3MyID0gbW9kZWxSZXNwb25zZS5lbWJlZGRpbmdzO1xuICAgICAgICAgICAgICBjb25zdCB1c2FnZTIgPSAoX2ExMSA9IG1vZGVsUmVzcG9uc2UudXNhZ2UpICE9IG51bGwgPyBfYTExIDogeyB0b2tlbnM6IE5hTiB9O1xuICAgICAgICAgICAgICBkb0VtYmVkU3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gZW1iZWRkaW5nczIubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UudG9rZW5zXCI6IHVzYWdlMi50b2tlbnNcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICByZXR1cm4geyBlbWJlZGRpbmdzOiBlbWJlZGRpbmdzMiwgdXNhZ2U6IHVzYWdlMiB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgZW1iZWRkaW5ncy5wdXNoKC4uLnJlc3BvbnNlRW1iZWRkaW5ncyk7XG4gICAgICAgIHRva2VucyArPSB1c2FnZS50b2tlbnM7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLmVtYmVkZGluZ3NcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IGVtYmVkZGluZ3MubWFwKChlbWJlZGRpbmcpID0+IEpTT04uc3RyaW5naWZ5KGVtYmVkZGluZykpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS50b2tlbnNcIjogdG9rZW5zXG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCh7XG4gICAgICAgIHZhbHVlcyxcbiAgICAgICAgZW1iZWRkaW5ncyxcbiAgICAgICAgdXNhZ2U6IHsgdG9rZW5zIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdEVtYmVkTWFueVJlc3VsdCA9IGNsYXNzIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudmFsdWVzID0gb3B0aW9ucy52YWx1ZXM7XG4gICAgdGhpcy5lbWJlZGRpbmdzID0gb3B0aW9ucy5lbWJlZGRpbmdzO1xuICAgIHRoaXMudXNhZ2UgPSBvcHRpb25zLnVzYWdlO1xuICB9XG59O1xuXG4vLyBjb3JlL2dlbmVyYXRlLW9iamVjdC9nZW5lcmF0ZS1vYmplY3QudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yLCBzYWZlUGFyc2VKU09OIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gdXRpbC9kb3dubG9hZC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTIgPSBcIkFJX0Rvd25sb2FkRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUyfWA7XG52YXIgc3ltYm9sMiA9IFN5bWJvbC5mb3IobWFya2VyMik7XG52YXIgX2EyO1xudmFyIERvd25sb2FkRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3IyIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHVybCxcbiAgICBzdGF0dXNDb2RlLFxuICAgIHN0YXR1c1RleHQsXG4gICAgY2F1c2UsXG4gICAgbWVzc2FnZSA9IGNhdXNlID09IG51bGwgPyBgRmFpbGVkIHRvIGRvd25sb2FkICR7dXJsfTogJHtzdGF0dXNDb2RlfSAke3N0YXR1c1RleHR9YCA6IGBGYWlsZWQgdG8gZG93bmxvYWQgJHt1cmx9OiAke2NhdXNlfWBcbiAgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTIsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICB0aGlzLnN0YXR1c1RleHQgPSBzdGF0dXNUZXh0O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IyLmhhc01hcmtlcihlcnJvciwgbWFya2VyMik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzRG93bmxvYWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUyICYmIHR5cGVvZiBlcnJvci51cmwgPT09IFwic3RyaW5nXCIgJiYgKGVycm9yLnN0YXR1c0NvZGUgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzQ29kZSA9PT0gXCJudW1iZXJcIikgJiYgKGVycm9yLnN0YXR1c1RleHQgPT0gbnVsbCB8fCB0eXBlb2YgZXJyb3Iuc3RhdHVzVGV4dCA9PT0gXCJzdHJpbmdcIik7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICB1cmw6IHRoaXMudXJsLFxuICAgICAgc3RhdHVzQ29kZTogdGhpcy5zdGF0dXNDb2RlLFxuICAgICAgc3RhdHVzVGV4dDogdGhpcy5zdGF0dXNUZXh0LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2VcbiAgICB9O1xuICB9XG59O1xuX2EyID0gc3ltYm9sMjtcblxuLy8gdXRpbC9kb3dubG9hZC50c1xuYXN5bmMgZnVuY3Rpb24gZG93bmxvYWQoe1xuICB1cmwsXG4gIGZldGNoSW1wbGVtZW50YXRpb24gPSBmZXRjaFxufSkge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgdXJsVGV4dCA9IHVybC50b1N0cmluZygpO1xuICB0cnkge1xuICAgIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2hJbXBsZW1lbnRhdGlvbih1cmxUZXh0KTtcbiAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICB0aHJvdyBuZXcgRG93bmxvYWRFcnJvcih7XG4gICAgICAgIHVybDogdXJsVGV4dCxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICBzdGF0dXNUZXh0OiByZXNwb25zZS5zdGF0dXNUZXh0XG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIGRhdGE6IG5ldyBVaW50OEFycmF5KGF3YWl0IHJlc3BvbnNlLmFycmF5QnVmZmVyKCkpLFxuICAgICAgbWltZVR5cGU6IChfYTExID0gcmVzcG9uc2UuaGVhZGVycy5nZXQoXCJjb250ZW50LXR5cGVcIikpICE9IG51bGwgPyBfYTExIDogdm9pZCAwXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBpZiAoRG93bmxvYWRFcnJvci5pc0luc3RhbmNlKGVycm9yKSkge1xuICAgICAgdGhyb3cgZXJyb3I7XG4gICAgfVxuICAgIHRocm93IG5ldyBEb3dubG9hZEVycm9yKHsgdXJsOiB1cmxUZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cblxuLy8gY29yZS91dGlsL2RldGVjdC1pbWFnZS1taW1ldHlwZS50c1xudmFyIG1pbWVUeXBlU2lnbmF0dXJlcyA9IFtcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9naWZcIiwgYnl0ZXM6IFs3MSwgNzMsIDcwXSB9LFxuICB7IG1pbWVUeXBlOiBcImltYWdlL3BuZ1wiLCBieXRlczogWzEzNywgODAsIDc4LCA3MV0gfSxcbiAgeyBtaW1lVHlwZTogXCJpbWFnZS9qcGVnXCIsIGJ5dGVzOiBbMjU1LCAyMTZdIH0sXG4gIHsgbWltZVR5cGU6IFwiaW1hZ2Uvd2VicFwiLCBieXRlczogWzgyLCA3MywgNzAsIDcwXSB9XG5dO1xuZnVuY3Rpb24gZGV0ZWN0SW1hZ2VNaW1lVHlwZShpbWFnZSkge1xuICBmb3IgKGNvbnN0IHsgYnl0ZXMsIG1pbWVUeXBlIH0gb2YgbWltZVR5cGVTaWduYXR1cmVzKSB7XG4gICAgaWYgKGltYWdlLmxlbmd0aCA+PSBieXRlcy5sZW5ndGggJiYgYnl0ZXMuZXZlcnkoKGJ5dGUsIGluZGV4KSA9PiBpbWFnZVtpbmRleF0gPT09IGJ5dGUpKSB7XG4gICAgICByZXR1cm4gbWltZVR5cGU7XG4gICAgfVxuICB9XG4gIHJldHVybiB2b2lkIDA7XG59XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHtcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NFxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBjb3JlL3Byb21wdC9pbnZhbGlkLWRhdGEtY29udGVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWREYXRhQ29udGVudEVycm9yXCI7XG52YXIgbWFya2VyMyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDMgPSBTeW1ib2wuZm9yKG1hcmtlcjMpO1xudmFyIF9hMztcbnZhciBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjMge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgY29udGVudCxcbiAgICBjYXVzZSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgZGF0YSBjb250ZW50LiBFeHBlY3RlZCBhIGJhc2U2NCBzdHJpbmcsIFVpbnQ4QXJyYXksIEFycmF5QnVmZmVyLCBvciBCdWZmZXIsIGJ1dCBnb3QgJHt0eXBlb2YgY29udGVudH0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lMywgbWVzc2FnZSwgY2F1c2UgfSk7XG4gICAgdGhpc1tfYTNdID0gdHJ1ZTtcbiAgICB0aGlzLmNvbnRlbnQgPSBjb250ZW50O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IzLmhhc01hcmtlcihlcnJvciwgbWFya2VyMyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZERhdGFDb250ZW50RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMyAmJiBlcnJvci5jb250ZW50ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgY29udGVudDogdGhpcy5jb250ZW50XG4gICAgfTtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIGNvcmUvcHJvbXB0L2RhdGEtY29udGVudC50c1xuaW1wb3J0IHsgeiB9IGZyb20gXCJ6b2RcIjtcbnZhciBkYXRhQ29udGVudFNjaGVtYSA9IHoudW5pb24oW1xuICB6LnN0cmluZygpLFxuICB6Lmluc3RhbmNlb2YoVWludDhBcnJheSksXG4gIHouaW5zdGFuY2VvZihBcnJheUJ1ZmZlciksXG4gIHouY3VzdG9tKFxuICAgIC8vIEJ1ZmZlciBtaWdodCBub3QgYmUgYXZhaWxhYmxlIGluIHNvbWUgZW52aXJvbm1lbnRzIHN1Y2ggYXMgQ2xvdWRGbGFyZTpcbiAgICAodmFsdWUpID0+IHtcbiAgICAgIHZhciBfYTExLCBfYjtcbiAgICAgIHJldHVybiAoX2IgPSAoX2ExMSA9IGdsb2JhbFRoaXMuQnVmZmVyKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5pc0J1ZmZlcih2YWx1ZSkpICE9IG51bGwgPyBfYiA6IGZhbHNlO1xuICAgIH0sXG4gICAgeyBtZXNzYWdlOiBcIk11c3QgYmUgYSBCdWZmZXJcIiB9XG4gIClcbl0pO1xuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9CYXNlNjRTdHJpbmcoY29udGVudCkge1xuICBpZiAodHlwZW9mIGNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gY29udGVudDtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgcmV0dXJuIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQobmV3IFVpbnQ4QXJyYXkoY29udGVudCkpO1xuICB9XG4gIHJldHVybiBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0KGNvbnRlbnQpO1xufVxuZnVuY3Rpb24gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpIHtcbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgcmV0dXJuIGNvbnRlbnQ7XG4gIH1cbiAgaWYgKHR5cGVvZiBjb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3Ioe1xuICAgICAgICBtZXNzYWdlOiBcIkludmFsaWQgZGF0YSBjb250ZW50LiBDb250ZW50IHN0cmluZyBpcyBub3QgYSBiYXNlNjQtZW5jb2RlZCBtZWRpYS5cIixcbiAgICAgICAgY29udGVudCxcbiAgICAgICAgY2F1c2U6IGVycm9yXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKGNvbnRlbnQgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgIHJldHVybiBuZXcgVWludDhBcnJheShjb250ZW50KTtcbiAgfVxuICB0aHJvdyBuZXcgSW52YWxpZERhdGFDb250ZW50RXJyb3IoeyBjb250ZW50IH0pO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb1RleHQodWludDhBcnJheSkge1xuICB0cnkge1xuICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodWludDhBcnJheSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiRXJyb3IgZGVjb2RpbmcgVWludDhBcnJheSB0byB0ZXh0XCIpO1xuICB9XG59XG5cbi8vIGNvcmUvcHJvbXB0L2ludmFsaWQtbWVzc2FnZS1yb2xlLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I0IH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbnZhciBuYW1lNCA9IFwiQUlfSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3JcIjtcbnZhciBtYXJrZXI0ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU0fWA7XG52YXIgc3ltYm9sNCA9IFN5bWJvbC5mb3IobWFya2VyNCk7XG52YXIgX2E0O1xudmFyIEludmFsaWRNZXNzYWdlUm9sZUVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNCB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICByb2xlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBtZXNzYWdlIHJvbGU6ICcke3JvbGV9Jy4gTXVzdCBiZSBvbmUgb2Y6IFwic3lzdGVtXCIsIFwidXNlclwiLCBcImFzc2lzdGFudFwiLCBcInRvb2xcIi5gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E0XSA9IHRydWU7XG4gICAgdGhpcy5yb2xlID0gcm9sZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yNC5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjQpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgdHlwZW9mIGVycm9yLnJvbGUgPT09IFwic3RyaW5nXCI7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHJvbGU6IHRoaXMucm9sZVxuICAgIH07XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBjb3JlL3Byb21wdC9zcGxpdC1kYXRhLXVybC50c1xuZnVuY3Rpb24gc3BsaXREYXRhVXJsKGRhdGFVcmwpIHtcbiAgdHJ5IHtcbiAgICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICAgIHJldHVybiB7XG4gICAgICBtaW1lVHlwZTogaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV0sXG4gICAgICBiYXNlNjRDb250ZW50XG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbWltZVR5cGU6IHZvaWQgMCxcbiAgICAgIGJhc2U2NENvbnRlbnQ6IHZvaWQgMFxuICAgIH07XG4gIH1cbn1cblxuLy8gY29yZS9wcm9tcHQvY29udmVydC10by1sYW5ndWFnZS1tb2RlbC1wcm9tcHQudHNcbmFzeW5jIGZ1bmN0aW9uIGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICBwcm9tcHQsXG4gIG1vZGVsU3VwcG9ydHNJbWFnZVVybHMgPSB0cnVlLFxuICBtb2RlbFN1cHBvcnRzVXJsID0gKCkgPT4gZmFsc2UsXG4gIGRvd25sb2FkSW1wbGVtZW50YXRpb24gPSBkb3dubG9hZFxufSkge1xuICBjb25zdCBkb3dubG9hZGVkQXNzZXRzID0gYXdhaXQgZG93bmxvYWRBc3NldHMoXG4gICAgcHJvbXB0Lm1lc3NhZ2VzLFxuICAgIGRvd25sb2FkSW1wbGVtZW50YXRpb24sXG4gICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJscyxcbiAgICBtb2RlbFN1cHBvcnRzVXJsXG4gICk7XG4gIHJldHVybiBbXG4gICAgLi4ucHJvbXB0LnN5c3RlbSAhPSBudWxsID8gW3sgcm9sZTogXCJzeXN0ZW1cIiwgY29udGVudDogcHJvbXB0LnN5c3RlbSB9XSA6IFtdLFxuICAgIC4uLnByb21wdC5tZXNzYWdlcy5tYXAoXG4gICAgICAobWVzc2FnZSkgPT4gY29udmVydFRvTGFuZ3VhZ2VNb2RlbE1lc3NhZ2UobWVzc2FnZSwgZG93bmxvYWRlZEFzc2V0cylcbiAgICApXG4gIF07XG59XG5mdW5jdGlvbiBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsTWVzc2FnZShtZXNzYWdlLCBkb3dubG9hZGVkQXNzZXRzKSB7XG4gIGNvbnN0IHJvbGUgPSBtZXNzYWdlLnJvbGU7XG4gIHN3aXRjaCAocm9sZSkge1xuICAgIGNhc2UgXCJzeXN0ZW1cIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJzeXN0ZW1cIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBjYXNlIFwidXNlclwiOiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+IGNvbnZlcnRQYXJ0VG9MYW5ndWFnZU1vZGVsUGFydChwYXJ0LCBkb3dubG9hZGVkQXNzZXRzKSkuZmlsdGVyKChwYXJ0KSA9PiBwYXJ0LnR5cGUgIT09IFwidGV4dFwiIHx8IHBhcnQudGV4dCAhPT0gXCJcIiksXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IG1lc3NhZ2UuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJhc3Npc3RhbnRcIjoge1xuICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiBtZXNzYWdlLmNvbnRlbnQgfV0sXG4gICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogbWVzc2FnZS5jb250ZW50LmZpbHRlcihcbiAgICAgICAgICAvLyByZW1vdmUgZW1wdHkgdGV4dCBwYXJ0czpcbiAgICAgICAgICAocGFydCkgPT4gcGFydC50eXBlICE9PSBcInRleHRcIiB8fCBwYXJ0LnRleHQgIT09IFwiXCJcbiAgICAgICAgKS5tYXAoKHBhcnQpID0+IHtcbiAgICAgICAgICBjb25zdCB7IGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhLCAuLi5yZXN0IH0gPSBwYXJ0O1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAuLi5yZXN0LFxuICAgICAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgICB9O1xuICAgICAgICB9KSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogbWVzc2FnZS5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcInRvb2xcIjoge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgIGNvbnRlbnQ6IG1lc3NhZ2UuY29udGVudC5tYXAoKHBhcnQpID0+ICh7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHBhcnQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogcGFydC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHBhcnQucmVzdWx0LFxuICAgICAgICAgIGNvbnRlbnQ6IHBhcnQuZXhwZXJpbWVudGFsX2NvbnRlbnQsXG4gICAgICAgICAgaXNFcnJvcjogcGFydC5pc0Vycm9yLFxuICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgICAgfSkpLFxuICAgICAgICBwcm92aWRlck1ldGFkYXRhOiBtZXNzYWdlLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgICB9O1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkTWVzc2FnZVJvbGVFcnJvcih7IHJvbGU6IF9leGhhdXN0aXZlQ2hlY2sgfSk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiBkb3dubG9hZEFzc2V0cyhtZXNzYWdlcywgZG93bmxvYWRJbXBsZW1lbnRhdGlvbiwgbW9kZWxTdXBwb3J0c0ltYWdlVXJscywgbW9kZWxTdXBwb3J0c1VybCkge1xuICBjb25zdCB1cmxzID0gbWVzc2FnZXMuZmlsdGVyKChtZXNzYWdlKSA9PiBtZXNzYWdlLnJvbGUgPT09IFwidXNlclwiKS5tYXAoKG1lc3NhZ2UpID0+IG1lc3NhZ2UuY29udGVudCkuZmlsdGVyKFxuICAgIChjb250ZW50KSA9PiBBcnJheS5pc0FycmF5KGNvbnRlbnQpXG4gICkuZmxhdCgpLmZpbHRlcihcbiAgICAocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgfHwgcGFydC50eXBlID09PSBcImZpbGVcIlxuICApLmZpbHRlcihcbiAgICAocGFydCkgPT4gIShwYXJ0LnR5cGUgPT09IFwiaW1hZ2VcIiAmJiBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzID09PSB0cnVlKVxuICApLm1hcCgocGFydCkgPT4gcGFydC50eXBlID09PSBcImltYWdlXCIgPyBwYXJ0LmltYWdlIDogcGFydC5kYXRhKS5tYXAoXG4gICAgKHBhcnQpID0+IChcbiAgICAgIC8vIHN1cHBvcnQgc3RyaW5nIHVybHM6XG4gICAgICB0eXBlb2YgcGFydCA9PT0gXCJzdHJpbmdcIiAmJiAocGFydC5zdGFydHNXaXRoKFwiaHR0cDpcIikgfHwgcGFydC5zdGFydHNXaXRoKFwiaHR0cHM6XCIpKSA/IG5ldyBVUkwocGFydCkgOiBwYXJ0XG4gICAgKVxuICApLmZpbHRlcigoaW1hZ2UpID0+IGltYWdlIGluc3RhbmNlb2YgVVJMKS5maWx0ZXIoKHVybCkgPT4gIW1vZGVsU3VwcG9ydHNVcmwodXJsKSk7XG4gIGNvbnN0IGRvd25sb2FkZWRJbWFnZXMgPSBhd2FpdCBQcm9taXNlLmFsbChcbiAgICB1cmxzLm1hcChhc3luYyAodXJsKSA9PiAoe1xuICAgICAgdXJsLFxuICAgICAgZGF0YTogYXdhaXQgZG93bmxvYWRJbXBsZW1lbnRhdGlvbih7IHVybCB9KVxuICAgIH0pKVxuICApO1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIGRvd25sb2FkZWRJbWFnZXMubWFwKCh7IHVybCwgZGF0YSB9KSA9PiBbdXJsLnRvU3RyaW5nKCksIGRhdGFdKVxuICApO1xufVxuZnVuY3Rpb24gY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0KHBhcnQsIGRvd25sb2FkZWRBc3NldHMpIHtcbiAgaWYgKHBhcnQudHlwZSA9PT0gXCJ0ZXh0XCIpIHtcbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICB0ZXh0OiBwYXJ0LnRleHQsXG4gICAgICBwcm92aWRlck1ldGFkYXRhOiBwYXJ0LmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhXG4gICAgfTtcbiAgfVxuICBsZXQgbWltZVR5cGUgPSBwYXJ0Lm1pbWVUeXBlO1xuICBsZXQgZGF0YTtcbiAgbGV0IGNvbnRlbnQ7XG4gIGxldCBub3JtYWxpemVkRGF0YTtcbiAgY29uc3QgdHlwZSA9IHBhcnQudHlwZTtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBcImltYWdlXCI6XG4gICAgICBkYXRhID0gcGFydC5pbWFnZTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgXCJmaWxlXCI6XG4gICAgICBkYXRhID0gcGFydC5kYXRhO1xuICAgICAgYnJlYWs7XG4gICAgZGVmYXVsdDpcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgcGFydCB0eXBlOiAke3R5cGV9YCk7XG4gIH1cbiAgdHJ5IHtcbiAgICBjb250ZW50ID0gdHlwZW9mIGRhdGEgPT09IFwic3RyaW5nXCIgPyBuZXcgVVJMKGRhdGEpIDogZGF0YTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb250ZW50ID0gZGF0YTtcbiAgfVxuICBpZiAoY29udGVudCBpbnN0YW5jZW9mIFVSTCkge1xuICAgIGlmIChjb250ZW50LnByb3RvY29sID09PSBcImRhdGE6XCIpIHtcbiAgICAgIGNvbnN0IHsgbWltZVR5cGU6IGRhdGFVcmxNaW1lVHlwZSwgYmFzZTY0Q29udGVudCB9ID0gc3BsaXREYXRhVXJsKFxuICAgICAgICBjb250ZW50LnRvU3RyaW5nKClcbiAgICAgICk7XG4gICAgICBpZiAoZGF0YVVybE1pbWVUeXBlID09IG51bGwgfHwgYmFzZTY0Q29udGVudCA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQgaW4gcGFydCAke3R5cGV9YCk7XG4gICAgICB9XG4gICAgICBtaW1lVHlwZSA9IGRhdGFVcmxNaW1lVHlwZTtcbiAgICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpO1xuICAgIH0gZWxzZSB7XG4gICAgICBjb25zdCBkb3dubG9hZGVkRmlsZSA9IGRvd25sb2FkZWRBc3NldHNbY29udGVudC50b1N0cmluZygpXTtcbiAgICAgIGlmIChkb3dubG9hZGVkRmlsZSkge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGRvd25sb2FkZWRGaWxlLmRhdGE7XG4gICAgICAgIG1pbWVUeXBlICE9IG51bGwgPyBtaW1lVHlwZSA6IG1pbWVUeXBlID0gZG93bmxvYWRlZEZpbGUubWltZVR5cGU7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBub3JtYWxpemVkRGF0YSA9IGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIG5vcm1hbGl6ZWREYXRhID0gY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGNvbnRlbnQpO1xuICB9XG4gIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgXCJpbWFnZVwiOlxuICAgICAgaWYgKG1pbWVUeXBlID09IG51bGwgJiYgbm9ybWFsaXplZERhdGEgaW5zdGFuY2VvZiBVaW50OEFycmF5KSB7XG4gICAgICAgIG1pbWVUeXBlID0gZGV0ZWN0SW1hZ2VNaW1lVHlwZShub3JtYWxpemVkRGF0YSk7XG4gICAgICB9XG4gICAgICByZXR1cm4ge1xuICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgIGltYWdlOiBub3JtYWxpemVkRGF0YSxcbiAgICAgICAgbWltZVR5cGUsXG4gICAgICAgIHByb3ZpZGVyTWV0YWRhdGE6IHBhcnQuZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGFcbiAgICAgIH07XG4gICAgY2FzZSBcImZpbGVcIjpcbiAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgTWltZSB0eXBlIGlzIG1pc3NpbmcgZm9yIGZpbGUgcGFydGApO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogXCJmaWxlXCIsXG4gICAgICAgIGRhdGE6IG5vcm1hbGl6ZWREYXRhIGluc3RhbmNlb2YgVWludDhBcnJheSA/IGNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nKG5vcm1hbGl6ZWREYXRhKSA6IG5vcm1hbGl6ZWREYXRhLFxuICAgICAgICBtaW1lVHlwZSxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcGFydC5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfTtcbiAgfVxufVxuXG4vLyBlcnJvcnMvaW52YWxpZC1hcmd1bWVudC1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yNSB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTUgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNSA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDUgPSBTeW1ib2wuZm9yKG1hcmtlcjUpO1xudmFyIF9hNTtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjUge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgcGFyYW1ldGVyLFxuICAgIHZhbHVlLFxuICAgIG1lc3NhZ2VcbiAgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWU1LFxuICAgICAgbWVzc2FnZTogYEludmFsaWQgYXJndW1lbnQgZm9yIHBhcmFtZXRlciAke3BhcmFtZXRlcn06ICR7bWVzc2FnZX1gXG4gICAgfSk7XG4gICAgdGhpc1tfYTVdID0gdHJ1ZTtcbiAgICB0aGlzLnBhcmFtZXRlciA9IHBhcmFtZXRlcjtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjUuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI1KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkQXJndW1lbnRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIHR5cGVvZiBlcnJvci5wYXJhbWV0ZXIgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLnZhbHVlID09PSBcInN0cmluZ1wiO1xuICB9XG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwYXJhbWV0ZXI6IHRoaXMucGFyYW1ldGVyLFxuICAgICAgdmFsdWU6IHRoaXMudmFsdWVcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS1jYWxsLXNldHRpbmdzLnRzXG5mdW5jdGlvbiBwcmVwYXJlQ2FsbFNldHRpbmdzKHtcbiAgbWF4VG9rZW5zLFxuICB0ZW1wZXJhdHVyZSxcbiAgdG9wUCxcbiAgdG9wSyxcbiAgcHJlc2VuY2VQZW5hbHR5LFxuICBmcmVxdWVuY3lQZW5hbHR5LFxuICBzdG9wU2VxdWVuY2VzLFxuICBzZWVkLFxuICBtYXhSZXRyaWVzXG59KSB7XG4gIGlmIChtYXhUb2tlbnMgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihtYXhUb2tlbnMpKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwibWF4VG9rZW5zXCIsXG4gICAgICAgIHZhbHVlOiBtYXhUb2tlbnMsXG4gICAgICAgIG1lc3NhZ2U6IFwibWF4VG9rZW5zIG11c3QgYmUgYW4gaW50ZWdlclwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKG1heFRva2VucyA8IDEpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhUb2tlbnNcIixcbiAgICAgICAgdmFsdWU6IG1heFRva2VucyxcbiAgICAgICAgbWVzc2FnZTogXCJtYXhUb2tlbnMgbXVzdCBiZSA+PSAxXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodGVtcGVyYXR1cmUgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdGVtcGVyYXR1cmUgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJ0ZW1wZXJhdHVyZVwiLFxuICAgICAgICB2YWx1ZTogdGVtcGVyYXR1cmUsXG4gICAgICAgIG1lc3NhZ2U6IFwidGVtcGVyYXR1cmUgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHRvcFAgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgdG9wUCAhPT0gXCJudW1iZXJcIikge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInRvcFBcIixcbiAgICAgICAgdmFsdWU6IHRvcFAsXG4gICAgICAgIG1lc3NhZ2U6IFwidG9wUCBtdXN0IGJlIGEgbnVtYmVyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAodG9wSyAhPSBudWxsKSB7XG4gICAgaWYgKHR5cGVvZiB0b3BLICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwidG9wS1wiLFxuICAgICAgICB2YWx1ZTogdG9wSyxcbiAgICAgICAgbWVzc2FnZTogXCJ0b3BLIG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChwcmVzZW5jZVBlbmFsdHkgIT0gbnVsbCkge1xuICAgIGlmICh0eXBlb2YgcHJlc2VuY2VQZW5hbHR5ICE9PSBcIm51bWJlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwicHJlc2VuY2VQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBwcmVzZW5jZVBlbmFsdHksXG4gICAgICAgIG1lc3NhZ2U6IFwicHJlc2VuY2VQZW5hbHR5IG11c3QgYmUgYSBudW1iZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChmcmVxdWVuY3lQZW5hbHR5ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIGZyZXF1ZW5jeVBlbmFsdHkgIT09IFwibnVtYmVyXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJmcmVxdWVuY3lQZW5hbHR5XCIsXG4gICAgICAgIHZhbHVlOiBmcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICBtZXNzYWdlOiBcImZyZXF1ZW5jeVBlbmFsdHkgbXVzdCBiZSBhIG51bWJlclwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKHNlZWQgIT0gbnVsbCkge1xuICAgIGlmICghTnVtYmVyLmlzSW50ZWdlcihzZWVkKSkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNlZWRcIixcbiAgICAgICAgdmFsdWU6IHNlZWQsXG4gICAgICAgIG1lc3NhZ2U6IFwic2VlZCBtdXN0IGJlIGFuIGludGVnZXJcIlxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGlmIChtYXhSZXRyaWVzICE9IG51bGwpIHtcbiAgICBpZiAoIU51bWJlci5pc0ludGVnZXIobWF4UmV0cmllcykpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSBhbiBpbnRlZ2VyXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAobWF4UmV0cmllcyA8IDApIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtYXhSZXRyaWVzXCIsXG4gICAgICAgIHZhbHVlOiBtYXhSZXRyaWVzLFxuICAgICAgICBtZXNzYWdlOiBcIm1heFJldHJpZXMgbXVzdCBiZSA+PSAwXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4ge1xuICAgIG1heFRva2VucyxcbiAgICB0ZW1wZXJhdHVyZTogdGVtcGVyYXR1cmUgIT0gbnVsbCA/IHRlbXBlcmF0dXJlIDogMCxcbiAgICB0b3BQLFxuICAgIHRvcEssXG4gICAgcHJlc2VuY2VQZW5hbHR5LFxuICAgIGZyZXF1ZW5jeVBlbmFsdHksXG4gICAgc3RvcFNlcXVlbmNlczogc3RvcFNlcXVlbmNlcyAhPSBudWxsICYmIHN0b3BTZXF1ZW5jZXMubGVuZ3RoID4gMCA/IHN0b3BTZXF1ZW5jZXMgOiB2b2lkIDAsXG4gICAgc2VlZCxcbiAgICBtYXhSZXRyaWVzOiBtYXhSZXRyaWVzICE9IG51bGwgPyBtYXhSZXRyaWVzIDogMlxuICB9O1xufVxuXG4vLyBjb3JlL3Byb21wdC9zdGFuZGFyZGl6ZS1wcm9tcHQudHNcbmltcG9ydCB7IEludmFsaWRQcm9tcHRFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5pbXBvcnQgeyBzYWZlVmFsaWRhdGVUeXBlcyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyB6IGFzIHo3IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLnRzXG5pbXBvcnQgeyB6IGFzIHo2IH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL3Byb3ZpZGVyLW1ldGFkYXRhLnRzXG5pbXBvcnQgeyB6IGFzIHozIH0gZnJvbSBcInpvZFwiO1xuXG4vLyBjb3JlL3R5cGVzL2pzb24tdmFsdWUudHNcbmltcG9ydCB7IHogYXMgejIgfSBmcm9tIFwiem9kXCI7XG52YXIganNvblZhbHVlU2NoZW1hID0gejIubGF6eShcbiAgKCkgPT4gejIudW5pb24oW1xuICAgIHoyLm51bGwoKSxcbiAgICB6Mi5zdHJpbmcoKSxcbiAgICB6Mi5udW1iZXIoKSxcbiAgICB6Mi5ib29sZWFuKCksXG4gICAgejIucmVjb3JkKHoyLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpLFxuICAgIHoyLmFycmF5KGpzb25WYWx1ZVNjaGVtYSlcbiAgXSlcbik7XG5cbi8vIGNvcmUvdHlwZXMvcHJvdmlkZXItbWV0YWRhdGEudHNcbnZhciBwcm92aWRlck1ldGFkYXRhU2NoZW1hID0gejMucmVjb3JkKFxuICB6My5zdHJpbmcoKSxcbiAgejMucmVjb3JkKHozLnN0cmluZygpLCBqc29uVmFsdWVTY2hlbWEpXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbmltcG9ydCB7IHogYXMgejUgfSBmcm9tIFwiem9kXCI7XG5cbi8vIGNvcmUvcHJvbXB0L3Rvb2wtcmVzdWx0LWNvbnRlbnQudHNcbmltcG9ydCB7IHogYXMgejQgfSBmcm9tIFwiem9kXCI7XG52YXIgdG9vbFJlc3VsdENvbnRlbnRTY2hlbWEgPSB6NC5hcnJheShcbiAgejQudW5pb24oW1xuICAgIHo0Lm9iamVjdCh7IHR5cGU6IHo0LmxpdGVyYWwoXCJ0ZXh0XCIpLCB0ZXh0OiB6NC5zdHJpbmcoKSB9KSxcbiAgICB6NC5vYmplY3Qoe1xuICAgICAgdHlwZTogejQubGl0ZXJhbChcImltYWdlXCIpLFxuICAgICAgZGF0YTogejQuc3RyaW5nKCksXG4gICAgICBtaW1lVHlwZTogejQuc3RyaW5nKCkub3B0aW9uYWwoKVxuICAgIH0pXG4gIF0pXG4pO1xuXG4vLyBjb3JlL3Byb21wdC9jb250ZW50LXBhcnQudHNcbnZhciB0ZXh0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0ZXh0XCIpLFxuICB0ZXh0OiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgaW1hZ2VQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImltYWdlXCIpLFxuICBpbWFnZTogejUudW5pb24oW2RhdGFDb250ZW50U2NoZW1hLCB6NS5pbnN0YW5jZW9mKFVSTCldKSxcbiAgbWltZVR5cGU6IHo1LnN0cmluZygpLm9wdGlvbmFsKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGZpbGVQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcImZpbGVcIiksXG4gIGRhdGE6IHo1LnVuaW9uKFtkYXRhQ29udGVudFNjaGVtYSwgejUuaW5zdGFuY2VvZihVUkwpXSksXG4gIG1pbWVUeXBlOiB6NS5zdHJpbmcoKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgdG9vbENhbGxQYXJ0U2NoZW1hID0gejUub2JqZWN0KHtcbiAgdHlwZTogejUubGl0ZXJhbChcInRvb2wtY2FsbFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgYXJnczogejUudW5rbm93bigpXG59KTtcbnZhciB0b29sUmVzdWx0UGFydFNjaGVtYSA9IHo1Lm9iamVjdCh7XG4gIHR5cGU6IHo1LmxpdGVyYWwoXCJ0b29sLXJlc3VsdFwiKSxcbiAgdG9vbENhbGxJZDogejUuc3RyaW5nKCksXG4gIHRvb2xOYW1lOiB6NS5zdHJpbmcoKSxcbiAgcmVzdWx0OiB6NS51bmtub3duKCksXG4gIGNvbnRlbnQ6IHRvb2xSZXN1bHRDb250ZW50U2NoZW1hLm9wdGlvbmFsKCksXG4gIGlzRXJyb3I6IHo1LmJvb2xlYW4oKS5vcHRpb25hbCgpLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcblxuLy8gY29yZS9wcm9tcHQvbWVzc2FnZS50c1xudmFyIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInN5c3RlbVwiKSxcbiAgY29udGVudDogejYuc3RyaW5nKCksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhU2NoZW1hLm9wdGlvbmFsKClcbn0pO1xudmFyIGNvcmVVc2VyTWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJ1c2VyXCIpLFxuICBjb250ZW50OiB6Ni51bmlvbihbXG4gICAgejYuc3RyaW5nKCksXG4gICAgejYuYXJyYXkoejYudW5pb24oW3RleHRQYXJ0U2NoZW1hLCBpbWFnZVBhcnRTY2hlbWEsIGZpbGVQYXJ0U2NoZW1hXSkpXG4gIF0pLFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVNjaGVtYS5vcHRpb25hbCgpXG59KTtcbnZhciBjb3JlQXNzaXN0YW50TWVzc2FnZVNjaGVtYSA9IHo2Lm9iamVjdCh7XG4gIHJvbGU6IHo2LmxpdGVyYWwoXCJhc3Npc3RhbnRcIiksXG4gIGNvbnRlbnQ6IHo2LnVuaW9uKFtcbiAgICB6Ni5zdHJpbmcoKSxcbiAgICB6Ni5hcnJheSh6Ni51bmlvbihbdGV4dFBhcnRTY2hlbWEsIHRvb2xDYWxsUGFydFNjaGVtYV0pKVxuICBdKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZVRvb2xNZXNzYWdlU2NoZW1hID0gejYub2JqZWN0KHtcbiAgcm9sZTogejYubGl0ZXJhbChcInRvb2xcIiksXG4gIGNvbnRlbnQ6IHo2LmFycmF5KHRvb2xSZXN1bHRQYXJ0U2NoZW1hKSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGFTY2hlbWEub3B0aW9uYWwoKVxufSk7XG52YXIgY29yZU1lc3NhZ2VTY2hlbWEgPSB6Ni51bmlvbihbXG4gIGNvcmVTeXN0ZW1NZXNzYWdlU2NoZW1hLFxuICBjb3JlVXNlck1lc3NhZ2VTY2hlbWEsXG4gIGNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hLFxuICBjb3JlVG9vbE1lc3NhZ2VTY2hlbWFcbl0pO1xuXG4vLyBjb3JlL3Byb21wdC9kZXRlY3QtcHJvbXB0LXR5cGUudHNcbmZ1bmN0aW9uIGRldGVjdFByb21wdFR5cGUocHJvbXB0KSB7XG4gIGlmICghQXJyYXkuaXNBcnJheShwcm9tcHQpKSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxuICBpZiAocHJvbXB0Lmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VzXCI7XG4gIH1cbiAgY29uc3QgY2hhcmFjdGVyaXN0aWNzID0gcHJvbXB0Lm1hcChkZXRlY3RTaW5nbGVNZXNzYWdlQ2hhcmFjdGVyaXN0aWNzKTtcbiAgaWYgKGNoYXJhY3RlcmlzdGljcy5zb21lKChjKSA9PiBjID09PSBcImhhcy11aS1zcGVjaWZpYy1wYXJ0c1wiKSkge1xuICAgIHJldHVybiBcInVpLW1lc3NhZ2VzXCI7XG4gIH0gZWxzZSBpZiAoY2hhcmFjdGVyaXN0aWNzLmV2ZXJ5KFxuICAgIChjKSA9PiBjID09PSBcImhhcy1jb3JlLXNwZWNpZmljLXBhcnRzXCIgfHwgYyA9PT0gXCJtZXNzYWdlXCJcbiAgKSkge1xuICAgIHJldHVybiBcIm1lc3NhZ2VzXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuZnVuY3Rpb24gZGV0ZWN0U2luZ2xlTWVzc2FnZUNoYXJhY3RlcmlzdGljcyhtZXNzYWdlKSB7XG4gIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIChtZXNzYWdlLnJvbGUgPT09IFwiZnVuY3Rpb25cIiB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgbWVzc2FnZS5yb2xlID09PSBcImRhdGFcIiB8fCAvLyBVSS1vbmx5IHJvbGVcbiAgXCJ0b29sSW52b2NhdGlvbnNcIiBpbiBtZXNzYWdlIHx8IC8vIFVJLXNwZWNpZmljIGZpZWxkXG4gIFwiZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXCIgaW4gbWVzc2FnZSkpIHtcbiAgICByZXR1cm4gXCJoYXMtdWktc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwiY29udGVudFwiIGluIG1lc3NhZ2UgJiYgKEFycmF5LmlzQXJyYXkobWVzc2FnZS5jb250ZW50KSB8fCAvLyBDb3JlIG1lc3NhZ2VzIGNhbiBoYXZlIGFycmF5IGNvbnRlbnRcbiAgXCJleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YVwiIGluIG1lc3NhZ2UpKSB7XG4gICAgcmV0dXJuIFwiaGFzLWNvcmUtc3BlY2lmaWMtcGFydHNcIjtcbiAgfSBlbHNlIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gXCJvYmplY3RcIiAmJiBtZXNzYWdlICE9PSBudWxsICYmIFwicm9sZVwiIGluIG1lc3NhZ2UgJiYgXCJjb250ZW50XCIgaW4gbWVzc2FnZSAmJiB0eXBlb2YgbWVzc2FnZS5jb250ZW50ID09PSBcInN0cmluZ1wiICYmIFtcInN5c3RlbVwiLCBcInVzZXJcIiwgXCJhc3Npc3RhbnRcIiwgXCJ0b29sXCJdLmluY2x1ZGVzKG1lc3NhZ2Uucm9sZSkpIHtcbiAgICByZXR1cm4gXCJtZXNzYWdlXCI7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIFwib3RoZXJcIjtcbiAgfVxufVxuXG4vLyBjb3JlL3Byb21wdC9hdHRhY2htZW50cy10by1wYXJ0cy50c1xuZnVuY3Rpb24gYXR0YWNobWVudHNUb1BhcnRzKGF0dGFjaG1lbnRzKSB7XG4gIHZhciBfYTExLCBfYiwgX2M7XG4gIGNvbnN0IHBhcnRzID0gW107XG4gIGZvciAoY29uc3QgYXR0YWNobWVudCBvZiBhdHRhY2htZW50cykge1xuICAgIGxldCB1cmw7XG4gICAgdHJ5IHtcbiAgICAgIHVybCA9IG5ldyBVUkwoYXR0YWNobWVudC51cmwpO1xuICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgIH1cbiAgICBzd2l0Y2ggKHVybC5wcm90b2NvbCkge1xuICAgICAgY2FzZSBcImh0dHA6XCI6XG4gICAgICBjYXNlIFwiaHR0cHM6XCI6IHtcbiAgICAgICAgaWYgKChfYTExID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuc3RhcnRzV2l0aChcImltYWdlL1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goeyB0eXBlOiBcImltYWdlXCIsIGltYWdlOiB1cmwgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlLCBpdCBtdXN0IHNwZWNpZnkgYSBjb250ZW50IHR5cGVcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImZpbGVcIixcbiAgICAgICAgICAgIGRhdGE6IHVybCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YTpcIjoge1xuICAgICAgICBsZXQgaGVhZGVyO1xuICAgICAgICBsZXQgYmFzZTY0Q29udGVudDtcbiAgICAgICAgbGV0IG1pbWVUeXBlO1xuICAgICAgICB0cnkge1xuICAgICAgICAgIFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gYXR0YWNobWVudC51cmwuc3BsaXQoXCIsXCIpO1xuICAgICAgICAgIG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBFcnJvciBwcm9jZXNzaW5nIGRhdGEgVVJMOiAke2F0dGFjaG1lbnQudXJsfWApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBkYXRhIFVSTCBmb3JtYXQ6ICR7YXR0YWNobWVudC51cmx9YCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChfYiA9IGF0dGFjaG1lbnQuY29udGVudFR5cGUpID09IG51bGwgPyB2b2lkIDAgOiBfYi5zdGFydHNXaXRoKFwiaW1hZ2UvXCIpKSB7XG4gICAgICAgICAgcGFydHMucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiBcImltYWdlXCIsXG4gICAgICAgICAgICBpbWFnZTogY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAoKF9jID0gYXR0YWNobWVudC5jb250ZW50VHlwZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnN0YXJ0c1dpdGgoXCJ0ZXh0L1wiKSkge1xuICAgICAgICAgIHBhcnRzLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICB0ZXh0OiBjb252ZXJ0VWludDhBcnJheVRvVGV4dChcbiAgICAgICAgICAgICAgY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5KGJhc2U2NENvbnRlbnQpXG4gICAgICAgICAgICApXG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaWYgKCFhdHRhY2htZW50LmNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIFwiSWYgdGhlIGF0dGFjaG1lbnQgaXMgbm90IGFuIGltYWdlIG9yIHRleHQsIGl0IG11c3Qgc3BlY2lmeSBhIGNvbnRlbnQgdHlwZVwiXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBwYXJ0cy5wdXNoKHtcbiAgICAgICAgICAgIHR5cGU6IFwiZmlsZVwiLFxuICAgICAgICAgICAgZGF0YTogYmFzZTY0Q29udGVudCxcbiAgICAgICAgICAgIG1pbWVUeXBlOiBhdHRhY2htZW50LmNvbnRlbnRUeXBlXG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5zdXBwb3J0ZWQgVVJMIHByb3RvY29sOiAke3VybC5wcm90b2NvbH1gKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG4vLyBjb3JlL3Byb21wdC9tZXNzYWdlLWNvbnZlcnNpb24tZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjYgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU2ID0gXCJBSV9NZXNzYWdlQ29udmVyc2lvbkVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNn1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBNZXNzYWdlQ29udmVyc2lvbkVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNiB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBvcmlnaW5hbE1lc3NhZ2UsXG4gICAgbWVzc2FnZVxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNiwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIHRoaXMub3JpZ2luYWxNZXNzYWdlID0gb3JpZ2luYWxNZXNzYWdlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I2Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNik7XG4gIH1cbn07XG5fYTYgPSBzeW1ib2w2O1xuXG4vLyBjb3JlL3Byb21wdC9jb252ZXJ0LXRvLWNvcmUtbWVzc2FnZXMudHNcbmZ1bmN0aW9uIGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhtZXNzYWdlcywgb3B0aW9ucykge1xuICB2YXIgX2ExMTtcbiAgY29uc3QgdG9vbHMgPSAoX2ExMSA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudG9vbHMpICE9IG51bGwgPyBfYTExIDoge307XG4gIGNvbnN0IGNvcmVNZXNzYWdlcyA9IFtdO1xuICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXMpIHtcbiAgICBjb25zdCB7IHJvbGUsIGNvbnRlbnQsIHRvb2xJbnZvY2F0aW9ucywgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzIH0gPSBtZXNzYWdlO1xuICAgIHN3aXRjaCAocm9sZSkge1xuICAgICAgY2FzZSBcInN5c3RlbVwiOiB7XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcInN5c3RlbVwiLFxuICAgICAgICAgIGNvbnRlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcInVzZXJcIjoge1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ1c2VyXCIsXG4gICAgICAgICAgY29udGVudDogZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzID8gW1xuICAgICAgICAgICAgeyB0eXBlOiBcInRleHRcIiwgdGV4dDogY29udGVudCB9LFxuICAgICAgICAgICAgLi4uYXR0YWNobWVudHNUb1BhcnRzKGV4cGVyaW1lbnRhbF9hdHRhY2htZW50cylcbiAgICAgICAgICBdIDogY29udGVudFxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiYXNzaXN0YW50XCI6IHtcbiAgICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgY29yZU1lc3NhZ2VzLnB1c2goeyByb2xlOiBcImFzc2lzdGFudFwiLCBjb250ZW50IH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNvcmVNZXNzYWdlcy5wdXNoKHtcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IFtcbiAgICAgICAgICAgIHsgdHlwZTogXCJ0ZXh0XCIsIHRleHQ6IGNvbnRlbnQgfSxcbiAgICAgICAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucy5tYXAoXG4gICAgICAgICAgICAgICh7IHRvb2xDYWxsSWQsIHRvb2xOYW1lLCBhcmdzIH0pID0+ICh7XG4gICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGxcIixcbiAgICAgICAgICAgICAgICB0b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgIHRvb2xOYW1lLFxuICAgICAgICAgICAgICAgIGFyZ3NcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIClcbiAgICAgICAgICBdXG4gICAgICAgIH0pO1xuICAgICAgICBjb3JlTWVzc2FnZXMucHVzaCh7XG4gICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgY29udGVudDogdG9vbEludm9jYXRpb25zLm1hcCgodG9vbEludm9jYXRpb24pID0+IHtcbiAgICAgICAgICAgIGlmICghKFwicmVzdWx0XCIgaW4gdG9vbEludm9jYXRpb24pKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBNZXNzYWdlQ29udmVyc2lvbkVycm9yKHtcbiAgICAgICAgICAgICAgICBvcmlnaW5hbE1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgbWVzc2FnZTogXCJUb29sSW52b2NhdGlvbiBtdXN0IGhhdmUgYSByZXN1bHQ6IFwiICsgSlNPTi5zdHJpbmdpZnkodG9vbEludm9jYXRpb24pXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc3QgeyB0b29sQ2FsbElkLCB0b29sTmFtZSwgcmVzdWx0IH0gPSB0b29sSW52b2NhdGlvbjtcbiAgICAgICAgICAgIGNvbnN0IHRvb2wyID0gdG9vbHNbdG9vbE5hbWVdO1xuICAgICAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIHJlc3VsdDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQocmVzdWx0KSxcbiAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX2NvbnRlbnQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHJlc3VsdClcbiAgICAgICAgICAgIH0gOiB7XG4gICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1yZXN1bHRcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWUsXG4gICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICB9KVxuICAgICAgICB9KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZnVuY3Rpb25cIjpcbiAgICAgIGNhc2UgXCJkYXRhXCI6XG4gICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgZGVmYXVsdDoge1xuICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gcm9sZTtcbiAgICAgICAgdGhyb3cgbmV3IE1lc3NhZ2VDb252ZXJzaW9uRXJyb3Ioe1xuICAgICAgICAgIG9yaWdpbmFsTWVzc2FnZTogbWVzc2FnZSxcbiAgICAgICAgICBtZXNzYWdlOiBgVW5zdXBwb3J0ZWQgcm9sZTogJHtfZXhoYXVzdGl2ZUNoZWNrfWBcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3JlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvcHJvbXB0L3N0YW5kYXJkaXplLXByb21wdC50c1xuZnVuY3Rpb24gc3RhbmRhcmRpemVQcm9tcHQoe1xuICBwcm9tcHQsXG4gIHRvb2xzXG59KSB7XG4gIGlmIChwcm9tcHQucHJvbXB0ID09IG51bGwgJiYgcHJvbXB0Lm1lc3NhZ2VzID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG9yIG1lc3NhZ2VzIG11c3QgYmUgZGVmaW5lZFwiXG4gICAgfSk7XG4gIH1cbiAgaWYgKHByb21wdC5wcm9tcHQgIT0gbnVsbCAmJiBwcm9tcHQubWVzc2FnZXMgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgcHJvbXB0LFxuICAgICAgbWVzc2FnZTogXCJwcm9tcHQgYW5kIG1lc3NhZ2VzIGNhbm5vdCBiZSBkZWZpbmVkIGF0IHRoZSBzYW1lIHRpbWVcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQuc3lzdGVtICE9IG51bGwgJiYgdHlwZW9mIHByb21wdC5zeXN0ZW0gIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgIHByb21wdCxcbiAgICAgIG1lc3NhZ2U6IFwic3lzdGVtIG11c3QgYmUgYSBzdHJpbmdcIlxuICAgIH0pO1xuICB9XG4gIGlmIChwcm9tcHQucHJvbXB0ICE9IG51bGwpIHtcbiAgICBpZiAodHlwZW9mIHByb21wdC5wcm9tcHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwicHJvbXB0IG11c3QgYmUgYSBzdHJpbmdcIlxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInByb21wdFwiLFxuICAgICAgc3lzdGVtOiBwcm9tcHQuc3lzdGVtLFxuICAgICAgbWVzc2FnZXM6IFtcbiAgICAgICAge1xuICAgICAgICAgIHJvbGU6IFwidXNlclwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHByb21wdC5wcm9tcHRcbiAgICAgICAgfVxuICAgICAgXVxuICAgIH07XG4gIH1cbiAgaWYgKHByb21wdC5tZXNzYWdlcyAhPSBudWxsKSB7XG4gICAgY29uc3QgcHJvbXB0VHlwZSA9IGRldGVjdFByb21wdFR5cGUocHJvbXB0Lm1lc3NhZ2VzKTtcbiAgICBpZiAocHJvbXB0VHlwZSA9PT0gXCJvdGhlclwiKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZFByb21wdEVycm9yKHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICBtZXNzYWdlOiBcIm1lc3NhZ2VzIG11c3QgYmUgYW4gYXJyYXkgb2YgQ29yZU1lc3NhZ2Ugb3IgVUlNZXNzYWdlXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBjb25zdCBtZXNzYWdlcyA9IHByb21wdFR5cGUgPT09IFwidWktbWVzc2FnZXNcIiA/IGNvbnZlcnRUb0NvcmVNZXNzYWdlcyhwcm9tcHQubWVzc2FnZXMsIHtcbiAgICAgIHRvb2xzXG4gICAgfSkgOiBwcm9tcHQubWVzc2FnZXM7XG4gICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgIHZhbHVlOiBtZXNzYWdlcyxcbiAgICAgIHNjaGVtYTogejcuYXJyYXkoY29yZU1lc3NhZ2VTY2hlbWEpXG4gICAgfSk7XG4gICAgaWYgKCF2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkUHJvbXB0RXJyb3Ioe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIG1lc3NhZ2U6IFwibWVzc2FnZXMgbXVzdCBiZSBhbiBhcnJheSBvZiBDb3JlTWVzc2FnZSBvciBVSU1lc3NhZ2VcIixcbiAgICAgICAgY2F1c2U6IHZhbGlkYXRpb25SZXN1bHQuZXJyb3JcbiAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJtZXNzYWdlc1wiLFxuICAgICAgbWVzc2FnZXMsXG4gICAgICBzeXN0ZW06IHByb21wdC5zeXN0ZW1cbiAgICB9O1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcInVucmVhY2hhYmxlXCIpO1xufVxuXG4vLyBjb3JlL3R5cGVzL3VzYWdlLnRzXG5mdW5jdGlvbiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpIHtcbiAgcmV0dXJuIHtcbiAgICBwcm9tcHRUb2tlbnM6IHVzYWdlLnByb21wdFRva2VucyxcbiAgICBjb21wbGV0aW9uVG9rZW5zOiB1c2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgIHRvdGFsVG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyB1c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gIH07XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IGhlYWRlcnMgPSBuZXcgSGVhZGVycygoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCA/IF9hMTEgOiB7fSk7XG4gIGlmICghaGVhZGVycy5oYXMoXCJDb250ZW50LVR5cGVcIikpIHtcbiAgICBoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBjb250ZW50VHlwZSk7XG4gIH1cbiAgaWYgKGRhdGFTdHJlYW1WZXJzaW9uICE9PSB2b2lkIDApIHtcbiAgICBoZWFkZXJzLnNldChcIlgtVmVyY2VsLUFJLURhdGEtU3RyZWFtXCIsIGRhdGFTdHJlYW1WZXJzaW9uKTtcbiAgfVxuICByZXR1cm4gaGVhZGVycztcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvaW5qZWN0LWpzb24taW5zdHJ1Y3Rpb24udHNcbnZhciBERUZBVUxUX1NDSEVNQV9QUkVGSVggPSBcIkpTT04gc2NoZW1hOlwiO1xudmFyIERFRkFVTFRfU0NIRU1BX1NVRkZJWCA9IFwiWW91IE1VU1QgYW5zd2VyIHdpdGggYSBKU09OIG9iamVjdCB0aGF0IG1hdGNoZXMgdGhlIEpTT04gc2NoZW1hIGFib3ZlLlwiO1xudmFyIERFRkFVTFRfR0VORVJJQ19TVUZGSVggPSBcIllvdSBNVVNUIGFuc3dlciB3aXRoIEpTT04uXCI7XG5mdW5jdGlvbiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICBwcm9tcHQsXG4gIHNjaGVtYSxcbiAgc2NoZW1hUHJlZml4ID0gc2NoZW1hICE9IG51bGwgPyBERUZBVUxUX1NDSEVNQV9QUkVGSVggOiB2b2lkIDAsXG4gIHNjaGVtYVN1ZmZpeCA9IHNjaGVtYSAhPSBudWxsID8gREVGQVVMVF9TQ0hFTUFfU1VGRklYIDogREVGQVVMVF9HRU5FUklDX1NVRkZJWFxufSkge1xuICByZXR1cm4gW1xuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gcHJvbXB0IDogdm9pZCAwLFxuICAgIHByb21wdCAhPSBudWxsICYmIHByb21wdC5sZW5ndGggPiAwID8gXCJcIiA6IHZvaWQgMCxcbiAgICAvLyBhZGQgYSBuZXdsaW5lIGlmIHByb21wdCBpcyBub3QgbnVsbFxuICAgIHNjaGVtYVByZWZpeCxcbiAgICBzY2hlbWEgIT0gbnVsbCA/IEpTT04uc3RyaW5naWZ5KHNjaGVtYSkgOiB2b2lkIDAsXG4gICAgc2NoZW1hU3VmZml4XG4gIF0uZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9IG51bGwpLmpvaW4oXCJcXG5cIik7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L25vLW9iamVjdC1nZW5lcmF0ZWQtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjcgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU3ID0gXCJBSV9Ob09iamVjdEdlbmVyYXRlZEVycm9yXCI7XG52YXIgbWFya2VyNyA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lN31gO1xudmFyIHN5bWJvbDcgPSBTeW1ib2wuZm9yKG1hcmtlcjcpO1xudmFyIF9hNztcbnZhciBOb09iamVjdEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yNyB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIk5vIG9iamVjdCBnZW5lcmF0ZWQuXCIgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNywgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hN10gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3I3Lmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb09iamVjdEdlbmVyYXRlZEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTc7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBjYXVzZTogdGhpcy5jYXVzZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrXG4gICAgfTtcbiAgfVxufTtcbl9hNyA9IHN5bWJvbDc7XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L291dHB1dC1zdHJhdGVneS50c1xuaW1wb3J0IHtcbiAgaXNKU09OQXJyYXksXG4gIGlzSlNPTk9iamVjdCxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Jcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IHNhZmVWYWxpZGF0ZVR5cGVzIGFzIHNhZmVWYWxpZGF0ZVR5cGVzMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgeyBhc1NjaGVtYSB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9hc3luYy1pdGVyYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0oc291cmNlLCB0cmFuc2Zvcm1lcikge1xuICBjb25zdCB0cmFuc2Zvcm1lZFN0cmVhbSA9IHNvdXJjZS5waXBlVGhyb3VnaChcbiAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKVxuICApO1xuICB0cmFuc2Zvcm1lZFN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSAoKSA9PiB7XG4gICAgY29uc3QgcmVhZGVyID0gdHJhbnNmb3JtZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgcmV0dXJuIHtcbiAgICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIHJldHVybiBkb25lID8geyBkb25lOiB0cnVlLCB2YWx1ZTogdm9pZCAwIH0gOiB7IGRvbmU6IGZhbHNlLCB2YWx1ZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB0cmFuc2Zvcm1lZFN0cmVhbTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvb3V0cHV0LXN0cmF0ZWd5LnRzXG52YXIgbm9TY2hlbWFPdXRwdXRTdHJhdGVneSA9IHtcbiAgdHlwZTogXCJuby1zY2hlbWFcIixcbiAganNvblNjaGVtYTogdm9pZCAwLFxuICB2YWxpZGF0ZVBhcnRpYWxSZXN1bHQoeyB2YWx1ZSwgdGV4dERlbHRhIH0pIHtcbiAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogeyBwYXJ0aWFsOiB2YWx1ZSwgdGV4dERlbHRhIH0gfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiB2YWx1ZSA9PT0gdm9pZCAwID8geyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCkgfSA6IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgfSxcbiAgY3JlYXRlRWxlbWVudFN0cmVhbSgpIHtcbiAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgZnVuY3Rpb25hbGl0eTogXCJlbGVtZW50IHN0cmVhbXMgaW4gbm8tc2NoZW1hIG1vZGVcIlxuICAgIH0pO1xuICB9XG59O1xudmFyIG9iamVjdE91dHB1dFN0cmF0ZWd5ID0gKHNjaGVtYSkgPT4gKHtcbiAgdHlwZTogXCJvYmplY3RcIixcbiAganNvblNjaGVtYTogc2NoZW1hLmpzb25TY2hlbWEsXG4gIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCB0ZXh0RGVsdGEgfSkge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgdmFsdWU6IHtcbiAgICAgICAgLy8gTm90ZTogY3VycmVudGx5IG5vIHZhbGlkYXRpb24gb2YgcGFydGlhbCByZXN1bHRzOlxuICAgICAgICBwYXJ0aWFsOiB2YWx1ZSxcbiAgICAgICAgdGV4dERlbHRhXG4gICAgICB9XG4gICAgfTtcbiAgfSxcbiAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlczIoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9LFxuICBjcmVhdGVFbGVtZW50U3RyZWFtKCkge1xuICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBvYmplY3QgbW9kZVwiXG4gICAgfSk7XG4gIH1cbn0pO1xudmFyIGFycmF5T3V0cHV0U3RyYXRlZ3kgPSAoc2NoZW1hKSA9PiB7XG4gIGNvbnN0IHsgJHNjaGVtYSwgLi4uaXRlbVNjaGVtYSB9ID0gc2NoZW1hLmpzb25TY2hlbWE7XG4gIHJldHVybiB7XG4gICAgdHlwZTogXCJlbnVtXCIsXG4gICAgLy8gd3JhcCBpbiBvYmplY3QgdGhhdCBjb250YWlucyBhcnJheSBvZiBlbGVtZW50cywgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBhcnJheSBkaXJlY3RseTpcbiAgICAvLyBwb3NzaWJsZSBmdXR1cmUgb3B0aW1pemF0aW9uOiB1c2UgYXJyYXlzIGRpcmVjdGx5IHdoZW4gbW9kZWwgc3VwcG9ydHMgZ3JhbW1hci1ndWlkZWQgZ2VuZXJhdGlvblxuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICBlbGVtZW50czogeyB0eXBlOiBcImFycmF5XCIsIGl0ZW1zOiBpdGVtU2NoZW1hIH1cbiAgICAgIH0sXG4gICAgICByZXF1aXJlZDogW1wiZWxlbWVudHNcIl0sXG4gICAgICBhZGRpdGlvbmFsUHJvcGVydGllczogZmFsc2VcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCh7IHZhbHVlLCBsYXRlc3RPYmplY3QsIGlzRmlyc3REZWx0YSwgaXNGaW5hbERlbHRhIH0pIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8ICFpc0pTT05BcnJheSh2YWx1ZS5lbGVtZW50cykpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogXCJ2YWx1ZSBtdXN0IGJlIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGFuIGFycmF5IG9mIGVsZW1lbnRzXCJcbiAgICAgICAgICB9KVxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29uc3QgaW5wdXRBcnJheSA9IHZhbHVlLmVsZW1lbnRzO1xuICAgICAgY29uc3QgcmVzdWx0QXJyYXkgPSBbXTtcbiAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXRBcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICBjb25zdCBlbGVtZW50ID0gaW5wdXRBcnJheVtpXTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMyKHsgdmFsdWU6IGVsZW1lbnQsIHNjaGVtYSB9KTtcbiAgICAgICAgaWYgKGkgPT09IGlucHV0QXJyYXkubGVuZ3RoIC0gMSAmJiAhaXNGaW5hbERlbHRhKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0QXJyYXkucHVzaChyZXN1bHQudmFsdWUpO1xuICAgICAgfVxuICAgICAgY29uc3QgcHVibGlzaGVkRWxlbWVudENvdW50ID0gKF9hMTEgPSBsYXRlc3RPYmplY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGxhdGVzdE9iamVjdC5sZW5ndGgpICE9IG51bGwgPyBfYTExIDogMDtcbiAgICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgICAgaWYgKGlzRmlyc3REZWx0YSkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCJbXCI7XG4gICAgICB9XG4gICAgICBpZiAocHVibGlzaGVkRWxlbWVudENvdW50ID4gMCkge1xuICAgICAgICB0ZXh0RGVsdGEgKz0gXCIsXCI7XG4gICAgICB9XG4gICAgICB0ZXh0RGVsdGEgKz0gcmVzdWx0QXJyYXkuc2xpY2UocHVibGlzaGVkRWxlbWVudENvdW50KS5tYXAoKGVsZW1lbnQpID0+IEpTT04uc3RyaW5naWZ5KGVsZW1lbnQpKS5qb2luKFwiLFwiKTtcbiAgICAgIGlmIChpc0ZpbmFsRGVsdGEpIHtcbiAgICAgICAgdGV4dERlbHRhICs9IFwiXVwiO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IHtcbiAgICAgICAgICBwYXJ0aWFsOiByZXN1bHRBcnJheSxcbiAgICAgICAgICB0ZXh0RGVsdGFcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlRmluYWxSZXN1bHQodmFsdWUpIHtcbiAgICAgIGlmICghaXNKU09OT2JqZWN0KHZhbHVlKSB8fCAhaXNKU09OQXJyYXkodmFsdWUuZWxlbWVudHMpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICAgICAgZXJyb3I6IG5ldyBUeXBlVmFsaWRhdGlvbkVycm9yKHtcbiAgICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgICAgY2F1c2U6IFwidmFsdWUgbXVzdCBiZSBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhbiBhcnJheSBvZiBlbGVtZW50c1wiXG4gICAgICAgICAgfSlcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGlucHV0QXJyYXkgPSB2YWx1ZS5lbGVtZW50cztcbiAgICAgIGZvciAoY29uc3QgZWxlbWVudCBvZiBpbnB1dEFycmF5KSB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzMih7IHZhbHVlOiBlbGVtZW50LCBzY2hlbWEgfSk7XG4gICAgICAgIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogaW5wdXRBcnJheSB9O1xuICAgIH0sXG4gICAgY3JlYXRlRWxlbWVudFN0cmVhbShvcmlnaW5hbFN0cmVhbSkge1xuICAgICAgbGV0IHB1Ymxpc2hlZEVsZW1lbnRzID0gMDtcbiAgICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKG9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcIm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGFycmF5ID0gY2h1bmsub2JqZWN0O1xuICAgICAgICAgICAgICBmb3IgKDsgcHVibGlzaGVkRWxlbWVudHMgPCBhcnJheS5sZW5ndGg7IHB1Ymxpc2hlZEVsZW1lbnRzKyspIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoYXJyYXlbcHVibGlzaGVkRWxlbWVudHNdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfTtcbn07XG52YXIgZW51bU91dHB1dFN0cmF0ZWd5ID0gKGVudW1WYWx1ZXMpID0+IHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcImVudW1cIixcbiAgICAvLyB3cmFwIGluIG9iamVjdCB0aGF0IGNvbnRhaW5zIHJlc3VsdCwgc2luY2UgbW9zdCBMTE1zIHdpbGwgbm90XG4gICAgLy8gYmUgYWJsZSB0byBnZW5lcmF0ZSBhbiBlbnVtIHZhbHVlIGRpcmVjdGx5OlxuICAgIC8vIHBvc3NpYmxlIGZ1dHVyZSBvcHRpbWl6YXRpb246IHVzZSBlbnVtcyBkaXJlY3RseSB3aGVuIG1vZGVsIHN1cHBvcnRzIHRvcC1sZXZlbCBlbnVtc1xuICAgIGpzb25TY2hlbWE6IHtcbiAgICAgICRzY2hlbWE6IFwiaHR0cDovL2pzb24tc2NoZW1hLm9yZy9kcmFmdC0wNy9zY2hlbWEjXCIsXG4gICAgICB0eXBlOiBcIm9iamVjdFwiLFxuICAgICAgcHJvcGVydGllczoge1xuICAgICAgICByZXN1bHQ6IHsgdHlwZTogXCJzdHJpbmdcIiwgZW51bTogZW51bVZhbHVlcyB9XG4gICAgICB9LFxuICAgICAgcmVxdWlyZWQ6IFtcInJlc3VsdFwiXSxcbiAgICAgIGFkZGl0aW9uYWxQcm9wZXJ0aWVzOiBmYWxzZVxuICAgIH0sXG4gICAgdmFsaWRhdGVGaW5hbFJlc3VsdCh2YWx1ZSkge1xuICAgICAgaWYgKCFpc0pTT05PYmplY3QodmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yZXN1bHQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgICBjYXVzZTogJ3ZhbHVlIG11c3QgYmUgYW4gb2JqZWN0IHRoYXQgY29udGFpbnMgYSBzdHJpbmcgaW4gdGhlIFwicmVzdWx0XCIgcHJvcGVydHkuJ1xuICAgICAgICAgIH0pXG4gICAgICAgIH07XG4gICAgICB9XG4gICAgICBjb25zdCByZXN1bHQgPSB2YWx1ZS5yZXN1bHQ7XG4gICAgICByZXR1cm4gZW51bVZhbHVlcy5pbmNsdWRlcyhyZXN1bHQpID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0IH0gOiB7XG4gICAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgICBlcnJvcjogbmV3IFR5cGVWYWxpZGF0aW9uRXJyb3Ioe1xuICAgICAgICAgIHZhbHVlLFxuICAgICAgICAgIGNhdXNlOiBcInZhbHVlIG11c3QgYmUgYSBzdHJpbmcgaW4gdGhlIGVudW1cIlxuICAgICAgICB9KVxuICAgICAgfTtcbiAgICB9LFxuICAgIHZhbGlkYXRlUGFydGlhbFJlc3VsdCgpIHtcbiAgICAgIHRocm93IG5ldyBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcih7XG4gICAgICAgIGZ1bmN0aW9uYWxpdHk6IFwicGFydGlhbCByZXN1bHRzIGluIGVudW0gbW9kZVwiXG4gICAgICB9KTtcbiAgICB9LFxuICAgIGNyZWF0ZUVsZW1lbnRTdHJlYW0oKSB7XG4gICAgICB0aHJvdyBuZXcgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3Ioe1xuICAgICAgICBmdW5jdGlvbmFsaXR5OiBcImVsZW1lbnQgc3RyZWFtcyBpbiBlbnVtIG1vZGVcIlxuICAgICAgfSk7XG4gICAgfVxuICB9O1xufTtcbmZ1bmN0aW9uIGdldE91dHB1dFN0cmF0ZWd5KHtcbiAgb3V0cHV0LFxuICBzY2hlbWEsXG4gIGVudW1WYWx1ZXNcbn0pIHtcbiAgc3dpdGNoIChvdXRwdXQpIHtcbiAgICBjYXNlIFwib2JqZWN0XCI6XG4gICAgICByZXR1cm4gb2JqZWN0T3V0cHV0U3RyYXRlZ3koYXNTY2hlbWEoc2NoZW1hKSk7XG4gICAgY2FzZSBcImFycmF5XCI6XG4gICAgICByZXR1cm4gYXJyYXlPdXRwdXRTdHJhdGVneShhc1NjaGVtYShzY2hlbWEpKTtcbiAgICBjYXNlIFwiZW51bVwiOlxuICAgICAgcmV0dXJuIGVudW1PdXRwdXRTdHJhdGVneShlbnVtVmFsdWVzKTtcbiAgICBjYXNlIFwibm8tc2NoZW1hXCI6XG4gICAgICByZXR1cm4gbm9TY2hlbWFPdXRwdXRTdHJhdGVneTtcbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gb3V0cHV0O1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBvdXRwdXQ6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICB9XG4gIH1cbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3QvdmFsaWRhdGUtb2JqZWN0LWdlbmVyYXRpb24taW5wdXQudHNcbmZ1bmN0aW9uIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgb3V0cHV0LFxuICBtb2RlLFxuICBzY2hlbWEsXG4gIHNjaGVtYU5hbWUsXG4gIHNjaGVtYURlc2NyaXB0aW9uLFxuICBlbnVtVmFsdWVzXG59KSB7XG4gIGlmIChvdXRwdXQgIT0gbnVsbCAmJiBvdXRwdXQgIT09IFwib2JqZWN0XCIgJiYgb3V0cHV0ICE9PSBcImFycmF5XCIgJiYgb3V0cHV0ICE9PSBcImVudW1cIiAmJiBvdXRwdXQgIT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm91dHB1dFwiLFxuICAgICAgdmFsdWU6IG91dHB1dCxcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBvdXRwdXQgdHlwZS5cIlxuICAgIH0pO1xuICB9XG4gIGlmIChvdXRwdXQgPT09IFwibm8tc2NoZW1hXCIpIHtcbiAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PT0gXCJ0b29sXCIpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJtb2RlXCIsXG4gICAgICAgIHZhbHVlOiBtb2RlLFxuICAgICAgICBtZXNzYWdlOiAnTW9kZSBtdXN0IGJlIFwianNvblwiIGZvciBuby1zY2hlbWEgb3V0cHV0LidcbiAgICAgIH0pO1xuICAgIH1cbiAgICBpZiAoc2NoZW1hICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYSxcbiAgICAgICAgbWVzc2FnZTogXCJTY2hlbWEgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKHNjaGVtYU5hbWUgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYU5hbWVcIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYU5hbWUsXG4gICAgICAgIG1lc3NhZ2U6IFwiU2NoZW1hIG5hbWUgaXMgbm90IHN1cHBvcnRlZCBmb3Igbm8tc2NoZW1hIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBuby1zY2hlbWEgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJvYmplY3RcIikge1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyByZXF1aXJlZCBmb3Igb2JqZWN0IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBvYmplY3Qgb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gIH1cbiAgaWYgKG91dHB1dCA9PT0gXCJhcnJheVwiKSB7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWEsXG4gICAgICAgIG1lc3NhZ2U6IFwiRWxlbWVudCBzY2hlbWEgaXMgcmVxdWlyZWQgZm9yIGFycmF5IG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChlbnVtVmFsdWVzICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgIHZhbHVlOiBlbnVtVmFsdWVzLFxuICAgICAgICBtZXNzYWdlOiBcIkVudW0gdmFsdWVzIGFyZSBub3Qgc3VwcG9ydGVkIGZvciBhcnJheSBvdXRwdXQuXCJcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBpZiAob3V0cHV0ID09PSBcImVudW1cIikge1xuICAgIGlmIChzY2hlbWEgIT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcInNjaGVtYVwiLFxuICAgICAgICB2YWx1ZTogc2NoZW1hLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICBwYXJhbWV0ZXI6IFwic2NoZW1hRGVzY3JpcHRpb25cIixcbiAgICAgICAgdmFsdWU6IHNjaGVtYURlc2NyaXB0aW9uLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBkZXNjcmlwdGlvbiBpcyBub3Qgc3VwcG9ydGVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGlmIChzY2hlbWFOYW1lICE9IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICAgIHBhcmFtZXRlcjogXCJzY2hlbWFOYW1lXCIsXG4gICAgICAgIHZhbHVlOiBzY2hlbWFOYW1lLFxuICAgICAgICBtZXNzYWdlOiBcIlNjaGVtYSBuYW1lIGlzIG5vdCBzdXBwb3J0ZWQgZm9yIGVudW0gb3V0cHV0LlwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgaWYgKGVudW1WYWx1ZXMgPT0gbnVsbCkge1xuICAgICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgICAgcGFyYW1ldGVyOiBcImVudW1WYWx1ZXNcIixcbiAgICAgICAgdmFsdWU6IGVudW1WYWx1ZXMsXG4gICAgICAgIG1lc3NhZ2U6IFwiRW51bSB2YWx1ZXMgYXJlIHJlcXVpcmVkIGZvciBlbnVtIG91dHB1dC5cIlxuICAgICAgfSk7XG4gICAgfVxuICAgIGZvciAoY29uc3QgdmFsdWUgb2YgZW51bVZhbHVlcykge1xuICAgICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgICAgIHBhcmFtZXRlcjogXCJlbnVtVmFsdWVzXCIsXG4gICAgICAgICAgdmFsdWUsXG4gICAgICAgICAgbWVzc2FnZTogXCJFbnVtIHZhbHVlcyBtdXN0IGJlIHN0cmluZ3MuXCJcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtb2JqZWN0L2dlbmVyYXRlLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZCA9IGNyZWF0ZUlkR2VuZXJhdG9yKHsgcHJlZml4OiBcImFpb2JqXCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gZ2VuZXJhdGVPYmplY3Qoe1xuICBtb2RlbCxcbiAgZW51bTogZW51bVZhbHVlcyxcbiAgLy8gcmVuYW1lIGJjIGVudW0gaXMgcmVzZXJ2ZWQgYnkgdHlwZXNjcmlwdFxuICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICBzY2hlbWFOYW1lLFxuICBzY2hlbWFEZXNjcmlwdGlvbixcbiAgbW9kZSxcbiAgb3V0cHV0ID0gXCJvYmplY3RcIixcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgZXhwZXJpbWVudGFsX3RlbGVtZXRyeTogdGVsZW1ldHJ5LFxuICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YSxcbiAgX2ludGVybmFsOiB7XG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMgPSBvcmlnaW5hbEdlbmVyYXRlSWQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIHZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0KHtcbiAgICBvdXRwdXQsXG4gICAgbW9kZSxcbiAgICBzY2hlbWE6IGlucHV0U2NoZW1hLFxuICAgIHNjaGVtYU5hbWUsXG4gICAgc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgY29uc3Qgb3V0cHV0U3RyYXRlZ3kgPSBnZXRPdXRwdXRTdHJhdGVneSh7XG4gICAgb3V0cHV0LFxuICAgIHNjaGVtYTogaW5wdXRTY2hlbWEsXG4gICAgZW51bVZhbHVlc1xuICB9KTtcbiAgaWYgKG91dHB1dFN0cmF0ZWd5LnR5cGUgPT09IFwibm8tc2NoZW1hXCIgJiYgbW9kZSA9PT0gdm9pZCAwKSB7XG4gICAgbW9kZSA9IFwianNvblwiO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IHRyYWNlciA9IGdldFRyYWNlcih0ZWxlbWV0cnkpO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdFwiLFxuICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgdGVsZW1ldHJ5LFxuICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEpIH0gOiB2b2lkIDAsXG4gICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGUsXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGZuOiBhc3luYyAoc3BhbikgPT4ge1xuICAgICAgdmFyIF9hMTEsIF9iO1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgaWYgKG1vZGUgPT09IFwiYXV0b1wiIHx8IG1vZGUgPT0gbnVsbCkge1xuICAgICAgICBtb2RlID0gbW9kZWwuZGVmYXVsdE9iamVjdEdlbmVyYXRpb25Nb2RlO1xuICAgICAgfVxuICAgICAgbGV0IHJlc3VsdDtcbiAgICAgIGxldCBmaW5pc2hSZWFzb247XG4gICAgICBsZXQgdXNhZ2U7XG4gICAgICBsZXQgd2FybmluZ3M7XG4gICAgICBsZXQgcmF3UmVzcG9uc2U7XG4gICAgICBsZXQgcmVzcG9uc2U7XG4gICAgICBsZXQgcmVxdWVzdDtcbiAgICAgIGxldCBsb2dwcm9icztcbiAgICAgIGxldCByZXN1bHRQcm92aWRlck1ldGFkYXRhO1xuICAgICAgc3dpdGNoIChtb2RlKSB7XG4gICAgICAgIGNhc2UgXCJqc29uXCI6IHtcbiAgICAgICAgICBjb25zdCBzdGFuZGFyZGl6ZWRQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgICAgc3lzdGVtOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hID09IG51bGwgPyBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oeyBwcm9tcHQ6IHN5c3RlbSB9KSA6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMgPyBzeXN0ZW0gOiBpbmplY3RKc29uSW5zdHJ1Y3Rpb24oe1xuICAgICAgICAgICAgICAgIHByb21wdDogc3lzdGVtLFxuICAgICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgcHJvbXB0LFxuICAgICAgICAgICAgICBtZXNzYWdlc1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHRvb2xzOiB2b2lkIDBcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBwcm9tcHRNZXNzYWdlcyA9IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgY29uc3QgZ2VuZXJhdGVSZXN1bHQgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgICBuYW1lOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLmdlbmVyYXRlT2JqZWN0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQuZm9ybWF0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IHN0YW5kYXJkaXplZFByb21wdC50eXBlXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQubWVzc2FnZXNcIjoge1xuICAgICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgXCJhaS5zZXR0aW5ncy5tb2RlXCI6IG1vZGUsXG4gICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1vZGVsXCI6IG1vZGVsLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5wcmVzZW5jZV9wZW5hbHR5XCI6IHNldHRpbmdzLnByZXNlbmNlUGVuYWx0eSxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudGVtcGVyYXR1cmVcIjogc2V0dGluZ3MudGVtcGVyYXR1cmUsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICAgIGZuOiBhc3luYyAoc3BhbjIpID0+IHtcbiAgICAgICAgICAgICAgICB2YXIgX2ExMiwgX2IyLCBfYywgX2QsIF9lLCBfZjtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LWpzb25cIixcbiAgICAgICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lLFxuICAgICAgICAgICAgICAgICAgICBkZXNjcmlwdGlvbjogc2NoZW1hRGVzY3JpcHRpb25cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAuLi5wcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKSxcbiAgICAgICAgICAgICAgICAgIGlucHV0Rm9ybWF0OiBzdGFuZGFyZGl6ZWRQcm9tcHQudHlwZSxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIudGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTm9PYmplY3RHZW5lcmF0ZWRFcnJvcigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjb25zdCByZXNwb25zZURhdGEgPSB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9iMiA9IChfYTEyID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTIuaWQpICE9IG51bGwgPyBfYjIgOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MudGltZXN0YW1wKSAhPSBudWxsID8gX2QgOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mID0gKF9lID0gcmVzdWx0Mi5yZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm1vZGVsSWQpICE9IG51bGwgPyBfZiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIHNwYW4yLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0Mi5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IHJlc3VsdDIudGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0Mi5maW5pc2hSZWFzb25dLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5tb2RlbFwiOiByZXNwb25zZURhdGEubW9kZWxJZCxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5wcm9tcHRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmNvbXBsZXRpb25fdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0Miwgb2JqZWN0VGV4dDogcmVzdWx0Mi50ZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVxdWVzdCA9IChfYTExID0gZ2VuZXJhdGVSZXN1bHQucmVxdWVzdCkgIT0gbnVsbCA/IF9hMTEgOiB7fTtcbiAgICAgICAgICByZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJlc3BvbnNlRGF0YTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmxcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCBpbnB1dEZvcm1hdCA9IHN0YW5kYXJkaXplZFByb21wdC50eXBlO1xuICAgICAgICAgIGNvbnN0IGdlbmVyYXRlUmVzdWx0ID0gYXdhaXQgcmV0cnkoXG4gICAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgbmFtZTogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS5nZW5lcmF0ZU9iamVjdC5kb0dlbmVyYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiBpbnB1dEZvcm1hdFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHByb21wdE1lc3NhZ2VzKVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlLFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tb2RlbFwiOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QucHJlc2VuY2VfcGVuYWx0eVwiOiBzZXR0aW5ncy5wcmVzZW5jZVBlbmFsdHksXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3Bfa1wiOiBzZXR0aW5ncy50b3BLLFxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC50b3BfcFwiOiBzZXR0aW5ncy50b3BQXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgdHJhY2VyLFxuICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgICAgdmFyIF9hMTIsIF9iMiwgX2MsIF9kLCBfZSwgX2YsIF9nLCBfaDtcbiAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQyID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgICBtb2RlOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwib2JqZWN0LXRvb2xcIixcbiAgICAgICAgICAgICAgICAgICAgdG9vbDoge1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZnVuY3Rpb25cIixcbiAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBzY2hlbWFOYW1lICE9IG51bGwgPyBzY2hlbWFOYW1lIDogXCJqc29uXCIsXG4gICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uICE9IG51bGwgPyBzY2hlbWFEZXNjcmlwdGlvbiA6IFwiUmVzcG9uZCB3aXRoIGEgSlNPTiBvYmplY3QuXCIsXG4gICAgICAgICAgICAgICAgICAgICAgcGFyYW1ldGVyczogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgICBpbnB1dEZvcm1hdCxcbiAgICAgICAgICAgICAgICAgIHByb21wdDogcHJvbXB0TWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29uc3Qgb2JqZWN0VGV4dCA9IChfYjIgPSAoX2ExMiA9IHJlc3VsdDIudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMlswXSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iMi5hcmdzO1xuICAgICAgICAgICAgICAgIGlmIChvYmplY3RUZXh0ID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBOb09iamVjdEdlbmVyYXRlZEVycm9yKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnN0IHJlc3BvbnNlRGF0YSA9IHtcbiAgICAgICAgICAgICAgICAgIGlkOiAoX2QgPSAoX2MgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MuaWQpICE9IG51bGwgPyBfZCA6IGdlbmVyYXRlSWQzKCksXG4gICAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZiA9IChfZSA9IHJlc3VsdDIucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZS50aW1lc3RhbXApICE9IG51bGwgPyBfZiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgICBtb2RlbElkOiAoX2ggPSAoX2cgPSByZXN1bHQyLnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2cubW9kZWxJZCkgIT0gbnVsbCA/IF9oIDogbW9kZWwubW9kZWxJZFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gb2JqZWN0VGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogcmVzcG9uc2VEYXRhLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQyLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiByZXN1bHQyLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IG9iamVjdFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW3Jlc3VsdDIuZmluaXNoUmVhc29uXSxcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZURhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkudXNhZ2UuaW5wdXRfdG9rZW5zXCI6IHJlc3VsdDIudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogcmVzdWx0Mi51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgICByZXR1cm4geyAuLi5yZXN1bHQyLCBvYmplY3RUZXh0LCByZXNwb25zZURhdGEgfTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICAgIHJlc3VsdCA9IGdlbmVyYXRlUmVzdWx0Lm9iamVjdFRleHQ7XG4gICAgICAgICAgZmluaXNoUmVhc29uID0gZ2VuZXJhdGVSZXN1bHQuZmluaXNoUmVhc29uO1xuICAgICAgICAgIHVzYWdlID0gZ2VuZXJhdGVSZXN1bHQudXNhZ2U7XG4gICAgICAgICAgd2FybmluZ3MgPSBnZW5lcmF0ZVJlc3VsdC53YXJuaW5ncztcbiAgICAgICAgICByYXdSZXNwb25zZSA9IGdlbmVyYXRlUmVzdWx0LnJhd1Jlc3BvbnNlO1xuICAgICAgICAgIGxvZ3Byb2JzID0gZ2VuZXJhdGVSZXN1bHQubG9ncHJvYnM7XG4gICAgICAgICAgcmVzdWx0UHJvdmlkZXJNZXRhZGF0YSA9IGdlbmVyYXRlUmVzdWx0LnByb3ZpZGVyTWV0YWRhdGE7XG4gICAgICAgICAgcmVxdWVzdCA9IChfYiA9IGdlbmVyYXRlUmVzdWx0LnJlcXVlc3QpICE9IG51bGwgPyBfYiA6IHt9O1xuICAgICAgICAgIHJlc3BvbnNlID0gZ2VuZXJhdGVSZXN1bHQucmVzcG9uc2VEYXRhO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHBhcnNlUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7IHRleHQ6IHJlc3VsdCB9KTtcbiAgICAgIGlmICghcGFyc2VSZXN1bHQuc3VjY2Vzcykge1xuICAgICAgICB0aHJvdyBwYXJzZVJlc3VsdC5lcnJvcjtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZUZpbmFsUmVzdWx0KFxuICAgICAgICBwYXJzZVJlc3VsdC52YWx1ZVxuICAgICAgKTtcbiAgICAgIGlmICghdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICAgIHRocm93IHZhbGlkYXRpb25SZXN1bHQuZXJyb3I7XG4gICAgICB9XG4gICAgICBzcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodmFsaWRhdGlvblJlc3VsdC52YWx1ZSlcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBcImFpLnVzYWdlLnByb21wdFRva2Vuc1wiOiB1c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogdXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjoge1xuICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHZhbGlkYXRpb25SZXN1bHQudmFsdWUpXG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdEdlbmVyYXRlT2JqZWN0UmVzdWx0KHtcbiAgICAgICAgb2JqZWN0OiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLFxuICAgICAgICBmaW5pc2hSZWFzb24sXG4gICAgICAgIHVzYWdlOiBjYWxjdWxhdGVMYW5ndWFnZU1vZGVsVXNhZ2UodXNhZ2UpLFxuICAgICAgICB3YXJuaW5ncyxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBsb2dwcm9icyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogcmVzdWx0UHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICB0aGlzLm9iamVjdCA9IG9wdGlvbnMub2JqZWN0O1xuICAgIHRoaXMuZmluaXNoUmVhc29uID0gb3B0aW9ucy5maW5pc2hSZWFzb247XG4gICAgdGhpcy51c2FnZSA9IG9wdGlvbnMudXNhZ2U7XG4gICAgdGhpcy53YXJuaW5ncyA9IG9wdGlvbnMud2FybmluZ3M7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJlc3BvbnNlID0gb3B0aW9ucy5yZXNwb25zZTtcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHtcbiAgICAgIGhlYWRlcnM6IG9wdGlvbnMucmVzcG9uc2UuaGVhZGVyc1xuICAgIH07XG4gICAgdGhpcy5sb2dwcm9icyA9IG9wdGlvbnMubG9ncHJvYnM7XG4gIH1cbiAgdG9Kc29uUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTExO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5vYmplY3QpLCB7XG4gICAgICBzdGF0dXM6IChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLFxuICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgIGNvbnRlbnRUeXBlOiBcImFwcGxpY2F0aW9uL2pzb247IGNoYXJzZXQ9dXRmLThcIlxuICAgICAgfSlcbiAgICB9KTtcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QgPSBnZW5lcmF0ZU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xuaW1wb3J0IHsgY3JlYXRlSWRHZW5lcmF0b3IgYXMgY3JlYXRlSWRHZW5lcmF0b3IyIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAgcGFyc2VQYXJ0aWFsSnNvblxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyB1dGlsL2NyZWF0ZS1yZXNvbHZhYmxlLXByb21pc2UudHNcbmZ1bmN0aW9uIGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCkge1xuICBsZXQgcmVzb2x2ZTtcbiAgbGV0IHJlamVjdDtcbiAgY29uc3QgcHJvbWlzZSA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgIHJlc29sdmUgPSByZXM7XG4gICAgcmVqZWN0ID0gcmVqO1xuICB9KTtcbiAgcmV0dXJuIHtcbiAgICBwcm9taXNlLFxuICAgIHJlc29sdmUsXG4gICAgcmVqZWN0XG4gIH07XG59XG5cbi8vIHV0aWwvZGVsYXllZC1wcm9taXNlLnRzXG52YXIgRGVsYXllZFByb21pc2UgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInBlbmRpbmdcIiB9O1xuICAgIHRoaXMuX3Jlc29sdmUgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVqZWN0ID0gdm9pZCAwO1xuICB9XG4gIGdldCB2YWx1ZSgpIHtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICByZXR1cm4gdGhpcy5wcm9taXNlO1xuICAgIH1cbiAgICB0aGlzLnByb21pc2UgPSBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICBpZiAodGhpcy5zdGF0dXMudHlwZSA9PT0gXCJyZXNvbHZlZFwiKSB7XG4gICAgICAgIHJlc29sdmUodGhpcy5zdGF0dXMudmFsdWUpO1xuICAgICAgfSBlbHNlIGlmICh0aGlzLnN0YXR1cy50eXBlID09PSBcInJlamVjdGVkXCIpIHtcbiAgICAgICAgcmVqZWN0KHRoaXMuc3RhdHVzLmVycm9yKTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3Jlc29sdmUgPSByZXNvbHZlO1xuICAgICAgdGhpcy5fcmVqZWN0ID0gcmVqZWN0O1xuICAgIH0pO1xuICAgIHJldHVybiB0aGlzLnByb21pc2U7XG4gIH1cbiAgcmVzb2x2ZSh2YWx1ZSkge1xuICAgIHZhciBfYTExO1xuICAgIHRoaXMuc3RhdHVzID0geyB0eXBlOiBcInJlc29sdmVkXCIsIHZhbHVlIH07XG4gICAgaWYgKHRoaXMucHJvbWlzZSkge1xuICAgICAgKF9hMTEgPSB0aGlzLl9yZXNvbHZlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKHRoaXMsIHZhbHVlKTtcbiAgICB9XG4gIH1cbiAgcmVqZWN0KGVycm9yKSB7XG4gICAgdmFyIF9hMTE7XG4gICAgdGhpcy5zdGF0dXMgPSB7IHR5cGU6IFwicmVqZWN0ZWRcIiwgZXJyb3IgfTtcbiAgICBpZiAodGhpcy5wcm9taXNlKSB7XG4gICAgICAoX2ExMSA9IHRoaXMuX3JlamVjdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbCh0aGlzLCBlcnJvcik7XG4gICAgfVxuICB9XG59O1xuXG4vLyBjb3JlL3V0aWwvbm93LnRzXG5mdW5jdGlvbiBub3coKSB7XG4gIHZhciBfYTExLCBfYjtcbiAgcmV0dXJuIChfYiA9IChfYTExID0gZ2xvYmFsVGhpcyA9PSBudWxsID8gdm9pZCAwIDogZ2xvYmFsVGhpcy5wZXJmb3JtYW5jZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEubm93KCkpICE9IG51bGwgPyBfYiA6IERhdGUubm93KCk7XG59XG5cbi8vIGNvcmUvdXRpbC9wcmVwYXJlLW91dGdvaW5nLWh0dHAtaGVhZGVycy50c1xuZnVuY3Rpb24gcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICBjb250ZW50VHlwZSxcbiAgZGF0YVN0cmVhbVZlcnNpb25cbn0pIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICBpZiAoKGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuaGVhZGVycykgIT0gbnVsbCkge1xuICAgIGZvciAoY29uc3QgW2tleSwgdmFsdWVdIG9mIE9iamVjdC5lbnRyaWVzKGluaXQuaGVhZGVycykpIHtcbiAgICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICAgIH1cbiAgfVxuICBpZiAoaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9PSBudWxsKSB7XG4gICAgaGVhZGVyc1tcIkNvbnRlbnQtVHlwZVwiXSA9IGNvbnRlbnRUeXBlO1xuICB9XG4gIGlmIChkYXRhU3RyZWFtVmVyc2lvbiAhPT0gdm9pZCAwKSB7XG4gICAgaGVhZGVyc1tcIlgtVmVyY2VsLUFJLURhdGEtU3RyZWFtXCJdID0gZGF0YVN0cmVhbVZlcnNpb247XG4gIH1cbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIGNvcmUvdXRpbC93cml0ZS10by1zZXJ2ZXItcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHdyaXRlVG9TZXJ2ZXJSZXNwb25zZSh7XG4gIHJlc3BvbnNlLFxuICBzdGF0dXMsXG4gIHN0YXR1c1RleHQsXG4gIGhlYWRlcnMsXG4gIHN0cmVhbVxufSkge1xuICByZXNwb25zZS53cml0ZUhlYWQoc3RhdHVzICE9IG51bGwgPyBzdGF0dXMgOiAyMDAsIHN0YXR1c1RleHQsIGhlYWRlcnMpO1xuICBjb25zdCByZWFkZXIgPSBzdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGNvbnN0IHJlYWQgPSBhc3luYyAoKSA9PiB7XG4gICAgdHJ5IHtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKVxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH0gZmluYWxseSB7XG4gICAgICByZXNwb25zZS5lbmQoKTtcbiAgICB9XG4gIH07XG4gIHJlYWQoKTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS1vYmplY3Qvc3RyZWFtLW9iamVjdC50c1xudmFyIG9yaWdpbmFsR2VuZXJhdGVJZDIgPSBjcmVhdGVJZEdlbmVyYXRvcjIoeyBwcmVmaXg6IFwiYWlvYmpcIiwgc2l6ZTogMjQgfSk7XG5hc3luYyBmdW5jdGlvbiBzdHJlYW1PYmplY3Qoe1xuICBtb2RlbCxcbiAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgc2NoZW1hTmFtZSxcbiAgc2NoZW1hRGVzY3JpcHRpb24sXG4gIG1vZGUsXG4gIG91dHB1dCA9IFwib2JqZWN0XCIsXG4gIHN5c3RlbSxcbiAgcHJvbXB0LFxuICBtZXNzYWdlcyxcbiAgbWF4UmV0cmllcyxcbiAgYWJvcnRTaWduYWwsXG4gIGhlYWRlcnMsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIG9uRmluaXNoLFxuICBfaW50ZXJuYWw6IHtcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDIsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICBub3c6IG5vdzIgPSBub3dcbiAgfSA9IHt9LFxuICAuLi5zZXR0aW5nc1xufSkge1xuICB2YWxpZGF0ZU9iamVjdEdlbmVyYXRpb25JbnB1dCh7XG4gICAgb3V0cHV0LFxuICAgIG1vZGUsXG4gICAgc2NoZW1hOiBpbnB1dFNjaGVtYSxcbiAgICBzY2hlbWFOYW1lLFxuICAgIHNjaGVtYURlc2NyaXB0aW9uXG4gIH0pO1xuICBjb25zdCBvdXRwdXRTdHJhdGVneSA9IGdldE91dHB1dFN0cmF0ZWd5KHsgb3V0cHV0LCBzY2hlbWE6IGlucHV0U2NoZW1hIH0pO1xuICBpZiAob3V0cHV0U3RyYXRlZ3kudHlwZSA9PT0gXCJuby1zY2hlbWFcIiAmJiBtb2RlID09PSB2b2lkIDApIHtcbiAgICBtb2RlID0gXCJqc29uXCI7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuc3RyZWFtT2JqZWN0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2NoZW1hXCI6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgIT0gbnVsbCA/IHsgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEpIH0gOiB2b2lkIDAsXG4gICAgICAgIFwiYWkuc2NoZW1hLm5hbWVcIjogc2NoZW1hTmFtZSxcbiAgICAgICAgXCJhaS5zY2hlbWEuZGVzY3JpcHRpb25cIjogc2NoZW1hRGVzY3JpcHRpb24sXG4gICAgICAgIFwiYWkuc2V0dGluZ3Mub3V0cHV0XCI6IG91dHB1dFN0cmF0ZWd5LnR5cGUsXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubW9kZVwiOiBtb2RlXG4gICAgICB9XG4gICAgfSksXG4gICAgdHJhY2VyLFxuICAgIGVuZFdoZW5Eb25lOiBmYWxzZSxcbiAgICBmbjogYXN5bmMgKHJvb3RTcGFuKSA9PiB7XG4gICAgICBpZiAobW9kZSA9PT0gXCJhdXRvXCIgfHwgbW9kZSA9PSBudWxsKSB7XG4gICAgICAgIG1vZGUgPSBtb2RlbC5kZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU7XG4gICAgICB9XG4gICAgICBsZXQgY2FsbE9wdGlvbnM7XG4gICAgICBsZXQgdHJhbnNmb3JtZXI7XG4gICAgICBzd2l0Y2ggKG1vZGUpIHtcbiAgICAgICAgY2FzZSBcImpzb25cIjoge1xuICAgICAgICAgIGNvbnN0IHN0YW5kYXJkaXplZFByb21wdCA9IHN0YW5kYXJkaXplUHJvbXB0KHtcbiAgICAgICAgICAgIHByb21wdDoge1xuICAgICAgICAgICAgICBzeXN0ZW06IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWEgPT0gbnVsbCA/IGluamVjdEpzb25JbnN0cnVjdGlvbih7IHByb21wdDogc3lzdGVtIH0pIDogbW9kZWwuc3VwcG9ydHNTdHJ1Y3R1cmVkT3V0cHV0cyA/IHN5c3RlbSA6IGluamVjdEpzb25JbnN0cnVjdGlvbih7XG4gICAgICAgICAgICAgICAgcHJvbXB0OiBzeXN0ZW0sXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBvdXRwdXRTdHJhdGVneS5qc29uU2NoZW1hXG4gICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICBwcm9tcHQsXG4gICAgICAgICAgICAgIG1lc3NhZ2VzXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC1qc29uXCIsXG4gICAgICAgICAgICAgIHNjaGVtYTogb3V0cHV0U3RyYXRlZ3kuanNvblNjaGVtYSxcbiAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSxcbiAgICAgICAgICAgICAgZGVzY3JpcHRpb246IHNjaGVtYURlc2NyaXB0aW9uXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICBpbnB1dEZvcm1hdDogc3RhbmRhcmRpemVkUHJvbXB0LnR5cGUsXG4gICAgICAgICAgICBwcm9tcHQ6IGF3YWl0IGNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQoe1xuICAgICAgICAgICAgICBwcm9tcHQ6IHN0YW5kYXJkaXplZFByb21wdCxcbiAgICAgICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsXG4gICAgICAgICAgICB9KSxcbiAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICBhYm9ydFNpZ25hbCxcbiAgICAgICAgICAgIGhlYWRlcnNcbiAgICAgICAgICB9O1xuICAgICAgICAgIHRyYW5zZm9ybWVyID0ge1xuICAgICAgICAgICAgdHJhbnNmb3JtOiAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSBcInJlc3BvbnNlLW1ldGFkYXRhXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImZpbmlzaFwiOlxuICAgICAgICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwidG9vbFwiOiB7XG4gICAgICAgICAgY29uc3Qgc3RhbmRhcmRpemVkUHJvbXB0ID0gc3RhbmRhcmRpemVQcm9tcHQoe1xuICAgICAgICAgICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgICAgICAgICAgdG9vbHM6IHZvaWQgMFxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGNhbGxPcHRpb25zID0ge1xuICAgICAgICAgICAgbW9kZToge1xuICAgICAgICAgICAgICB0eXBlOiBcIm9iamVjdC10b29sXCIsXG4gICAgICAgICAgICAgIHRvb2w6IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICAgICAgbmFtZTogc2NoZW1hTmFtZSAhPSBudWxsID8gc2NoZW1hTmFtZSA6IFwianNvblwiLFxuICAgICAgICAgICAgICAgIGRlc2NyaXB0aW9uOiBzY2hlbWFEZXNjcmlwdGlvbiAhPSBudWxsID8gc2NoZW1hRGVzY3JpcHRpb24gOiBcIlJlc3BvbmQgd2l0aCBhIEpTT04gb2JqZWN0LlwiLFxuICAgICAgICAgICAgICAgIHBhcmFtZXRlcnM6IG91dHB1dFN0cmF0ZWd5Lmpzb25TY2hlbWFcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC4uLnByZXBhcmVDYWxsU2V0dGluZ3Moc2V0dGluZ3MpLFxuICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHN0YW5kYXJkaXplZFByb21wdC50eXBlLFxuICAgICAgICAgICAgcHJvbXB0OiBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICAgICAgcHJvbXB0OiBzdGFuZGFyZGl6ZWRQcm9tcHQsXG4gICAgICAgICAgICAgIG1vZGVsU3VwcG9ydHNJbWFnZVVybHM6IG1vZGVsLnN1cHBvcnRzSW1hZ2VVcmxzLFxuICAgICAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICBwcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICBoZWFkZXJzXG4gICAgICAgICAgfTtcbiAgICAgICAgICB0cmFuc2Zvcm1lciA9IHtcbiAgICAgICAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgICAgICBzd2l0Y2ggKGNodW5rLnR5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsuYXJnc1RleHREZWx0YSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICAgICAgY2FzZSBcImVycm9yXCI6XG4gICAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9O1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2Ugdm9pZCAwOiB7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgXCJNb2RlbCBkb2VzIG5vdCBoYXZlIGEgZGVmYXVsdCBvYmplY3QgZ2VuZXJhdGlvbiBtb2RlLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IG1vZGU7XG4gICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBtb2RlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcmVzdWx0OiB7IHN0cmVhbSwgd2FybmluZ3MsIHJhd1Jlc3BvbnNlLCByZXF1ZXN0IH0sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgc3RhcnRUaW1lc3RhbXBNc1xuICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICBuYW1lOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbU9iamVjdC5kb1N0cmVhbVwiLFxuICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgLi4uYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMsXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgaW5wdXQ6ICgpID0+IGNhbGxPcHRpb25zLmlucHV0Rm9ybWF0XG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIFwiYWkucHJvbXB0Lm1lc3NhZ2VzXCI6IHtcbiAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY2FsbE9wdGlvbnMucHJvbXB0KVxuICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICBcImFpLnNldHRpbmdzLm1vZGVcIjogbW9kZSxcbiAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICBcImdlbl9haS5zeXN0ZW1cIjogbW9kZWwucHJvdmlkZXIsXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5mcmVxdWVuY3lfcGVuYWx0eVwiOiBzZXR0aW5ncy5mcmVxdWVuY3lQZW5hbHR5LFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0Lm1heF90b2tlbnNcIjogc2V0dGluZ3MubWF4VG9rZW5zLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9rXCI6IHNldHRpbmdzLnRvcEssXG4gICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX3BcIjogc2V0dGluZ3MudG9wUFxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgZm46IGFzeW5jIChkb1N0cmVhbVNwYW4yKSA9PiAoe1xuICAgICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogbm93MigpLFxuICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4yLFxuICAgICAgICAgICAgcmVzdWx0OiBhd2FpdCBtb2RlbC5kb1N0cmVhbShjYWxsT3B0aW9ucylcbiAgICAgICAgICB9KVxuICAgICAgICB9KVxuICAgICAgKTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbU9iamVjdFJlc3VsdCh7XG4gICAgICAgIG91dHB1dFN0cmF0ZWd5LFxuICAgICAgICBzdHJlYW06IHN0cmVhbS5waXBlVGhyb3VnaChuZXcgVHJhbnNmb3JtU3RyZWFtKHRyYW5zZm9ybWVyKSksXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgcmVxdWVzdDogcmVxdWVzdCAhPSBudWxsID8gcmVxdWVzdCA6IHt9LFxuICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgcm9vdFNwYW4sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICBub3c6IG5vdzIsXG4gICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkM1xuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbnZhciBEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgc3RyZWFtLFxuICAgIHdhcm5pbmdzLFxuICAgIHJhd1Jlc3BvbnNlLFxuICAgIHJlcXVlc3QsXG4gICAgb3V0cHV0U3RyYXRlZ3ksXG4gICAgb25GaW5pc2gsXG4gICAgcm9vdFNwYW4sXG4gICAgZG9TdHJlYW1TcGFuLFxuICAgIHRlbGVtZXRyeSxcbiAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgIG1vZGVsSWQsXG4gICAgbm93OiBub3cyLFxuICAgIGN1cnJlbnREYXRlLFxuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzXG4gIH0pIHtcbiAgICB0aGlzLndhcm5pbmdzID0gd2FybmluZ3M7XG4gICAgdGhpcy5yYXdSZXNwb25zZSA9IHJhd1Jlc3BvbnNlO1xuICAgIHRoaXMub3V0cHV0U3RyYXRlZ3kgPSBvdXRwdXRTdHJhdGVneTtcbiAgICB0aGlzLnJlcXVlc3QgPSBQcm9taXNlLnJlc29sdmUocmVxdWVzdCk7XG4gICAgdGhpcy5vYmplY3RQcm9taXNlID0gbmV3IERlbGF5ZWRQcm9taXNlKCk7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZVJlc3BvbnNlLCBwcm9taXNlOiByZXNwb25zZVByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlUHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICByZXNvbHZlOiByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YSxcbiAgICAgIHByb21pc2U6IHByb3ZpZGVyTWV0YWRhdGFQcm9taXNlXG4gICAgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IHByb3ZpZGVyTWV0YWRhdGFQcm9taXNlO1xuICAgIGxldCB1c2FnZTtcbiAgICBsZXQgZmluaXNoUmVhc29uO1xuICAgIGxldCBwcm92aWRlck1ldGFkYXRhO1xuICAgIGxldCBvYmplY3Q7XG4gICAgbGV0IGVycm9yO1xuICAgIGxldCBhY2N1bXVsYXRlZFRleHQgPSBcIlwiO1xuICAgIGxldCB0ZXh0RGVsdGEgPSBcIlwiO1xuICAgIGxldCByZXNwb25zZSA9IHtcbiAgICAgIGlkOiBnZW5lcmF0ZUlkMygpLFxuICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgbW9kZWxJZFxuICAgIH07XG4gICAgbGV0IGxhdGVzdE9iamVjdEpzb24gPSB2b2lkIDA7XG4gICAgbGV0IGxhdGVzdE9iamVjdCA9IHZvaWQgMDtcbiAgICBsZXQgaXNGaXJzdENodW5rID0gdHJ1ZTtcbiAgICBsZXQgaXNGaXJzdERlbHRhID0gdHJ1ZTtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICAgIHZhciBfYTExLCBfYiwgX2M7XG4gICAgICAgICAgaWYgKGlzRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgY29uc3QgbXNUb0ZpcnN0Q2h1bmsgPSBub3cyKCkgLSBzdGFydFRpbWVzdGFtcE1zO1xuICAgICAgICAgICAgaXNGaXJzdENodW5rID0gZmFsc2U7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uYWRkRXZlbnQoXCJhaS5zdHJlYW0uZmlyc3RDaHVua1wiLCB7XG4gICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGRvU3RyZWFtU3Bhbi5zZXRBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgXCJhaS5zdHJlYW0ubXNUb0ZpcnN0Q2h1bmtcIjogbXNUb0ZpcnN0Q2h1bmtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAodHlwZW9mIGNodW5rID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBhY2N1bXVsYXRlZFRleHQgKz0gY2h1bms7XG4gICAgICAgICAgICB0ZXh0RGVsdGEgKz0gY2h1bms7XG4gICAgICAgICAgICBjb25zdCB7IHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbiwgc3RhdGU6IHBhcnNlU3RhdGUgfSA9IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgIGlmIChjdXJyZW50T2JqZWN0SnNvbiAhPT0gdm9pZCAwICYmICFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0SnNvbiwgY3VycmVudE9iamVjdEpzb24pKSB7XG4gICAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRpb25SZXN1bHQgPSBvdXRwdXRTdHJhdGVneS52YWxpZGF0ZVBhcnRpYWxSZXN1bHQoe1xuICAgICAgICAgICAgICAgIHZhbHVlOiBjdXJyZW50T2JqZWN0SnNvbixcbiAgICAgICAgICAgICAgICB0ZXh0RGVsdGEsXG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgIGlzRmlyc3REZWx0YSxcbiAgICAgICAgICAgICAgICBpc0ZpbmFsRGVsdGE6IHBhcnNlU3RhdGUgPT09IFwic3VjY2Vzc2Z1bC1wYXJzZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAodmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzICYmICFpc0RlZXBFcXVhbERhdGEobGF0ZXN0T2JqZWN0LCB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnBhcnRpYWwpKSB7XG4gICAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0SnNvbiA9IGN1cnJlbnRPYmplY3RKc29uO1xuICAgICAgICAgICAgICAgIGxhdGVzdE9iamVjdCA9IHZhbGlkYXRpb25SZXN1bHQudmFsdWUucGFydGlhbDtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgdHlwZTogXCJvYmplY3RcIixcbiAgICAgICAgICAgICAgICAgIG9iamVjdDogbGF0ZXN0T2JqZWN0XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgdGV4dERlbHRhOiB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlLnRleHREZWx0YVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRleHREZWx0YSA9IFwiXCI7XG4gICAgICAgICAgICAgICAgaXNGaXJzdERlbHRhID0gZmFsc2U7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwicmVzcG9uc2UtbWV0YWRhdGFcIjoge1xuICAgICAgICAgICAgICByZXNwb25zZSA9IHtcbiAgICAgICAgICAgICAgICBpZDogKF9hMTEgPSBjaHVuay5pZCkgIT0gbnVsbCA/IF9hMTEgOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfYiA9IGNodW5rLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9iIDogcmVzcG9uc2UudGltZXN0YW1wLFxuICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHJlc3BvbnNlLm1vZGVsSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgICAgaWYgKHRleHREZWx0YSAhPT0gXCJcIikge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7IHR5cGU6IFwidGV4dC1kZWx0YVwiLCB0ZXh0RGVsdGEgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgZmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICB1c2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShjaHVuay51c2FnZSk7XG4gICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5wcm92aWRlck1ldGFkYXRhO1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoeyAuLi5jaHVuaywgdXNhZ2UsIHJlc3BvbnNlIH0pO1xuICAgICAgICAgICAgICByZXNvbHZlVXNhZ2UodXNhZ2UpO1xuICAgICAgICAgICAgICByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YShwcm92aWRlck1ldGFkYXRhKTtcbiAgICAgICAgICAgICAgcmVzb2x2ZVJlc3BvbnNlKHtcbiAgICAgICAgICAgICAgICAuLi5yZXNwb25zZSxcbiAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IG91dHB1dFN0cmF0ZWd5LnZhbGlkYXRlRmluYWxSZXN1bHQobGF0ZXN0T2JqZWN0SnNvbik7XG4gICAgICAgICAgICAgIGlmICh2YWxpZGF0aW9uUmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICBvYmplY3QgPSB2YWxpZGF0aW9uUmVzdWx0LnZhbHVlO1xuICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0UHJvbWlzZS5yZXNvbHZlKG9iamVjdCk7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgZXJyb3IgPSB2YWxpZGF0aW9uUmVzdWx0LmVycm9yO1xuICAgICAgICAgICAgICAgIHNlbGYub2JqZWN0UHJvbWlzZS5yZWplY3QoZXJyb3IpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgYXN5bmMgZmx1c2goY29udHJvbGxlcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBjb25zdCBmaW5hbFVzYWdlID0gdXNhZ2UgIT0gbnVsbCA/IHVzYWdlIDoge1xuICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IE5hTixcbiAgICAgICAgICAgICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgICAgICAgICAgICB0b3RhbFRva2VuczogTmFOXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgZG9TdHJlYW1TcGFuLnNldEF0dHJpYnV0ZXMoXG4gICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBmaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm9iamVjdFwiOiB7XG4gICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2UuaWQsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZS50aW1lc3RhbXAudG9JU09TdHJpbmcoKSxcbiAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IGZpbmFsVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgIFwiYWkuZmluaXNoUmVhc29uXCI6IGZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0Lm9iamVjdFwiOiB7IG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkob2JqZWN0KSB9LFxuICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuZmluaXNoX3JlYXNvbnNcIjogW2ZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5pZFwiOiByZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5pbnB1dF90b2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IGZpbmFsVXNhZ2UuY29tcGxldGlvblRva2Vuc1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBkb1N0cmVhbVNwYW4uZW5kKCk7XG4gICAgICAgICAgICByb290U3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogZmluYWxVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBcImFpLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcIjogZmluYWxVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5vYmplY3RcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdClcbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC5vYmplY3RcIjogeyBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KG9iamVjdCkgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgdXNhZ2U6IGZpbmFsVXNhZ2UsXG4gICAgICAgICAgICAgIG9iamVjdCxcbiAgICAgICAgICAgICAgZXJyb3IsXG4gICAgICAgICAgICAgIHJhd1Jlc3BvbnNlLFxuICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzXG4gICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogcHJvdmlkZXJNZXRhZGF0YVxuICAgICAgICAgICAgfSkpO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcjIpO1xuICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBnZXQgb2JqZWN0KCkge1xuICAgIHJldHVybiB0aGlzLm9iamVjdFByb21pc2UudmFsdWU7XG4gIH1cbiAgZ2V0IHBhcnRpYWxPYmplY3RTdHJlYW0oKSB7XG4gICAgcmV0dXJuIGNyZWF0ZUFzeW5jSXRlcmFibGVTdHJlYW0odGhpcy5vcmlnaW5hbFN0cmVhbSwge1xuICAgICAgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgIHN3aXRjaCAoY2h1bmsudHlwZSkge1xuICAgICAgICAgIGNhc2UgXCJvYmplY3RcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay5vYmplY3QpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBjYXNlIFwiZXJyb3JcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoY2h1bmsuZXJyb3IpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbnN1cHBvcnRlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZ2V0IGVsZW1lbnRTdHJlYW0oKSB7XG4gICAgcmV0dXJuIHRoaXMub3V0cHV0U3RyYXRlZ3kuY3JlYXRlRWxlbWVudFN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtKTtcbiAgfVxuICBnZXQgdGV4dFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgc3dpdGNoIChjaHVuay50eXBlKSB7XG4gICAgICAgICAgY2FzZSBcInRleHQtZGVsdGFcIjpcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuay50ZXh0RGVsdGEpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgY2FzZSBcIm9iamVjdFwiOlxuICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjpcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIGNhc2UgXCJlcnJvclwiOlxuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihjaHVuay5lcnJvcik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBfZXhoYXVzdGl2ZUNoZWNrID0gY2h1bms7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIGNodW5rIHR5cGU6ICR7X2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBnZXQgZnVsbFN0cmVhbSgpIHtcbiAgICByZXR1cm4gY3JlYXRlQXN5bmNJdGVyYWJsZVN0cmVhbSh0aGlzLm9yaWdpbmFsU3RyZWFtLCB7XG4gICAgICB0cmFuc2Zvcm0oY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBwaXBlVGV4dFN0cmVhbVRvUmVzcG9uc2UocmVzcG9uc2UsIGluaXQpIHtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRleHRTdHJlYW0ucGlwZVRocm91Z2gobmV3IFRleHRFbmNvZGVyU3RyZWFtKCkpXG4gICAgfSk7XG4gIH1cbiAgdG9UZXh0U3RyZWFtUmVzcG9uc2UoaW5pdCkge1xuICAgIHZhciBfYTExO1xuICAgIHJldHVybiBuZXcgUmVzcG9uc2UodGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKSwge1xuICAgICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVSZXNwb25zZUhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbn07XG52YXIgZXhwZXJpbWVudGFsX3N0cmVhbU9iamVjdCA9IHN0cmVhbU9iamVjdDtcblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L2dlbmVyYXRlLXRleHQudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yMyB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGVycm9ycy9pbmRleC50c1xuaW1wb3J0IHtcbiAgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTAsXG4gIEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkUHJvbXB0RXJyb3IgYXMgSW52YWxpZFByb21wdEVycm9yMixcbiAgSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yLFxuICBKU09OUGFyc2VFcnJvcixcbiAgTG9hZEFQSUtleUVycm9yLFxuICBOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcixcbiAgTm9TdWNoTW9kZWxFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgYXMgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIGVycm9ycy9pbnZhbGlkLXRvb2wtYXJndW1lbnRzLWVycm9yLnRzXG5pbXBvcnQgeyBBSVNES0Vycm9yIGFzIEFJU0RLRXJyb3I4LCBnZXRFcnJvck1lc3NhZ2UgYXMgZ2V0RXJyb3JNZXNzYWdlMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG52YXIgbmFtZTggPSBcIkFJX0ludmFsaWRUb29sQXJndW1lbnRzRXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3I4IHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHRvb2xBcmdzLFxuICAgIHRvb2xOYW1lLFxuICAgIGNhdXNlLFxuICAgIG1lc3NhZ2UgPSBgSW52YWxpZCBhcmd1bWVudHMgZm9yIHRvb2wgJHt0b29sTmFtZX06ICR7Z2V0RXJyb3JNZXNzYWdlMihcbiAgICAgIGNhdXNlXG4gICAgKX1gXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hOF0gPSB0cnVlO1xuICAgIHRoaXMudG9vbEFyZ3MgPSB0b29sQXJncztcbiAgICB0aGlzLnRvb2xOYW1lID0gdG9vbE5hbWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjguaGFzTWFya2VyKGVycm9yLCBtYXJrZXI4KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNJbnZhbGlkVG9vbEFyZ3VtZW50c0Vycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTggJiYgdHlwZW9mIGVycm9yLnRvb2xOYW1lID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci50b29sQXJncyA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0aGlzLnRvb2xBcmdzXG4gICAgfTtcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIGVycm9ycy9uby1zdWNoLXRvb2wtZXJyb3IudHNcbmltcG9ydCB7IEFJU0RLRXJyb3IgYXMgQUlTREtFcnJvcjkgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWU5ID0gXCJBSV9Ob1N1Y2hUb29sRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIE5vU3VjaFRvb2xFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvcjkge1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgdG9vbE5hbWUsXG4gICAgYXZhaWxhYmxlVG9vbHMgPSB2b2lkIDAsXG4gICAgbWVzc2FnZSA9IGBNb2RlbCB0cmllZCB0byBjYWxsIHVuYXZhaWxhYmxlIHRvb2wgJyR7dG9vbE5hbWV9Jy4gJHthdmFpbGFibGVUb29scyA9PT0gdm9pZCAwID8gXCJObyB0b29scyBhcmUgYXZhaWxhYmxlLlwiIDogYEF2YWlsYWJsZSB0b29sczogJHthdmFpbGFibGVUb29scy5qb2luKFwiLCBcIil9LmB9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lOSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hOV0gPSB0cnVlO1xuICAgIHRoaXMudG9vbE5hbWUgPSB0b29sTmFtZTtcbiAgICB0aGlzLmF2YWlsYWJsZVRvb2xzID0gYXZhaWxhYmxlVG9vbHM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjkuaGFzTWFya2VyKGVycm9yLCBtYXJrZXI5KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNOb1N1Y2hUb29sRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lOSAmJiBcInRvb2xOYW1lXCIgaW4gZXJyb3IgJiYgZXJyb3IudG9vbE5hbWUgIT0gdm9pZCAwICYmIHR5cGVvZiBlcnJvci5uYW1lID09PSBcInN0cmluZ1wiO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB0b29sTmFtZTogdGhpcy50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiB0aGlzLmF2YWlsYWJsZVRvb2xzXG4gICAgfTtcbiAgfVxufTtcbl9hOSA9IHN5bWJvbDk7XG5cbi8vIGNvcmUvcHJvbXB0L3ByZXBhcmUtdG9vbHMtYW5kLXRvb2wtY2hvaWNlLnRzXG5pbXBvcnQgeyBhc1NjaGVtYSBhcyBhc1NjaGVtYTIgfSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuXG4vLyBjb3JlL3V0aWwvaXMtbm9uLWVtcHR5LW9iamVjdC50c1xuZnVuY3Rpb24gaXNOb25FbXB0eU9iamVjdChvYmplY3QpIHtcbiAgcmV0dXJuIG9iamVjdCAhPSBudWxsICYmIE9iamVjdC5rZXlzKG9iamVjdCkubGVuZ3RoID4gMDtcbn1cblxuLy8gY29yZS9wcm9tcHQvcHJlcGFyZS10b29scy1hbmQtdG9vbC1jaG9pY2UudHNcbmZ1bmN0aW9uIHByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2Uoe1xuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgYWN0aXZlVG9vbHNcbn0pIHtcbiAgaWYgKCFpc05vbkVtcHR5T2JqZWN0KHRvb2xzKSkge1xuICAgIHJldHVybiB7XG4gICAgICB0b29sczogdm9pZCAwLFxuICAgICAgdG9vbENob2ljZTogdm9pZCAwXG4gICAgfTtcbiAgfVxuICBjb25zdCBmaWx0ZXJlZFRvb2xzID0gYWN0aXZlVG9vbHMgIT0gbnVsbCA/IE9iamVjdC5lbnRyaWVzKHRvb2xzKS5maWx0ZXIoXG4gICAgKFtuYW1lMTFdKSA9PiBhY3RpdmVUb29scy5pbmNsdWRlcyhuYW1lMTEpXG4gICkgOiBPYmplY3QuZW50cmllcyh0b29scyk7XG4gIHJldHVybiB7XG4gICAgdG9vbHM6IGZpbHRlcmVkVG9vbHMubWFwKChbbmFtZTExLCB0b29sMl0pID0+IHtcbiAgICAgIGNvbnN0IHRvb2xUeXBlID0gdG9vbDIudHlwZTtcbiAgICAgIHN3aXRjaCAodG9vbFR5cGUpIHtcbiAgICAgICAgY2FzZSB2b2lkIDA6XG4gICAgICAgIGNhc2UgXCJmdW5jdGlvblwiOlxuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB0eXBlOiBcImZ1bmN0aW9uXCIsXG4gICAgICAgICAgICBuYW1lOiBuYW1lMTEsXG4gICAgICAgICAgICBkZXNjcmlwdGlvbjogdG9vbDIuZGVzY3JpcHRpb24sXG4gICAgICAgICAgICBwYXJhbWV0ZXJzOiBhc1NjaGVtYTIodG9vbDIucGFyYW1ldGVycykuanNvblNjaGVtYVxuICAgICAgICAgIH07XG4gICAgICAgIGNhc2UgXCJwcm92aWRlci1kZWZpbmVkXCI6XG4gICAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIHR5cGU6IFwicHJvdmlkZXItZGVmaW5lZFwiLFxuICAgICAgICAgICAgbmFtZTogbmFtZTExLFxuICAgICAgICAgICAgaWQ6IHRvb2wyLmlkLFxuICAgICAgICAgICAgYXJnczogdG9vbDIuYXJnc1xuICAgICAgICAgIH07XG4gICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSB0b29sVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuc3VwcG9ydGVkIHRvb2wgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9KSxcbiAgICB0b29sQ2hvaWNlOiB0b29sQ2hvaWNlID09IG51bGwgPyB7IHR5cGU6IFwiYXV0b1wiIH0gOiB0eXBlb2YgdG9vbENob2ljZSA9PT0gXCJzdHJpbmdcIiA/IHsgdHlwZTogdG9vbENob2ljZSB9IDogeyB0eXBlOiBcInRvb2xcIiwgdG9vbE5hbWU6IHRvb2xDaG9pY2UudG9vbE5hbWUgfVxuICB9O1xufVxuXG4vLyBjb3JlL3V0aWwvc3BsaXQtb24tbGFzdC13aGl0ZXNwYWNlLnRzXG52YXIgbGFzdFdoaXRlc3BhY2VSZWdleHAgPSAvXihbXFxzXFxTXSo/KShcXHMrKShcXFMqKSQvO1xuZnVuY3Rpb24gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQpIHtcbiAgY29uc3QgbWF0Y2ggPSB0ZXh0Lm1hdGNoKGxhc3RXaGl0ZXNwYWNlUmVnZXhwKTtcbiAgcmV0dXJuIG1hdGNoID8geyBwcmVmaXg6IG1hdGNoWzFdLCB3aGl0ZXNwYWNlOiBtYXRjaFsyXSwgc3VmZml4OiBtYXRjaFszXSB9IDogdm9pZCAwO1xufVxuXG4vLyBjb3JlL3V0aWwvcmVtb3ZlLXRleHQtYWZ0ZXItbGFzdC13aGl0ZXNwYWNlLnRzXG5mdW5jdGlvbiByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZSh0ZXh0KSB7XG4gIGNvbnN0IG1hdGNoID0gc3BsaXRPbkxhc3RXaGl0ZXNwYWNlKHRleHQpO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaC5wcmVmaXggKyBtYXRjaC53aGl0ZXNwYWNlIDogdGV4dDtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3BhcnNlLXRvb2wtY2FsbC50c1xuaW1wb3J0IHsgc2FmZVBhcnNlSlNPTiBhcyBzYWZlUGFyc2VKU09OMiwgc2FmZVZhbGlkYXRlVHlwZXMgYXMgc2FmZVZhbGlkYXRlVHlwZXMzIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7IGFzU2NoZW1hIGFzIGFzU2NoZW1hMyB9IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZVRvb2xDYWxsKHtcbiAgdG9vbENhbGwsXG4gIHRvb2xzXG59KSB7XG4gIGNvbnN0IHRvb2xOYW1lID0gdG9vbENhbGwudG9vbE5hbWU7XG4gIGlmICh0b29scyA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IE5vU3VjaFRvb2xFcnJvcih7IHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSB9KTtcbiAgfVxuICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgaWYgKHRvb2wyID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgIGF2YWlsYWJsZVRvb2xzOiBPYmplY3Qua2V5cyh0b29scylcbiAgICB9KTtcbiAgfVxuICBjb25zdCBzY2hlbWEgPSBhc1NjaGVtYTModG9vbDIucGFyYW1ldGVycyk7XG4gIGNvbnN0IHBhcnNlUmVzdWx0ID0gdG9vbENhbGwuYXJncy50cmltKCkgPT09IFwiXCIgPyBzYWZlVmFsaWRhdGVUeXBlczMoeyB2YWx1ZToge30sIHNjaGVtYSB9KSA6IHNhZmVQYXJzZUpTT04yKHsgdGV4dDogdG9vbENhbGwuYXJncywgc2NoZW1hIH0pO1xuICBpZiAocGFyc2VSZXN1bHQuc3VjY2VzcyA9PT0gZmFsc2UpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvcih7XG4gICAgICB0b29sTmFtZSxcbiAgICAgIHRvb2xBcmdzOiB0b29sQ2FsbC5hcmdzLFxuICAgICAgY2F1c2U6IHBhcnNlUmVzdWx0LmVycm9yXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB0eXBlOiBcInRvb2wtY2FsbFwiLFxuICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgdG9vbE5hbWUsXG4gICAgYXJnczogcGFyc2VSZXN1bHQudmFsdWVcbiAgfTtcbn1cblxuLy8gY29yZS9nZW5lcmF0ZS10ZXh0L3RvLXJlc3BvbnNlLW1lc3NhZ2VzLnRzXG5mdW5jdGlvbiB0b1Jlc3BvbnNlTWVzc2FnZXMoe1xuICB0ZXh0ID0gXCJcIixcbiAgdG9vbHMsXG4gIHRvb2xDYWxscyxcbiAgdG9vbFJlc3VsdHNcbn0pIHtcbiAgY29uc3QgcmVzcG9uc2VNZXNzYWdlcyA9IFtdO1xuICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgY29udGVudDogW3sgdHlwZTogXCJ0ZXh0XCIsIHRleHQgfSwgLi4udG9vbENhbGxzXVxuICB9KTtcbiAgaWYgKHRvb2xSZXN1bHRzLmxlbmd0aCA+IDApIHtcbiAgICByZXNwb25zZU1lc3NhZ2VzLnB1c2goe1xuICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICBjb250ZW50OiB0b29sUmVzdWx0cy5tYXAoKHRvb2xSZXN1bHQpID0+IHtcbiAgICAgICAgY29uc3QgdG9vbDIgPSB0b29sc1t0b29sUmVzdWx0LnRvb2xOYW1lXTtcbiAgICAgICAgcmV0dXJuICh0b29sMiA9PSBudWxsID8gdm9pZCAwIDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQpICE9IG51bGwgPyB7XG4gICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xSZXN1bHQudG9vbENhbGxJZCxcbiAgICAgICAgICB0b29sTmFtZTogdG9vbFJlc3VsdC50b29sTmFtZSxcbiAgICAgICAgICByZXN1bHQ6IHRvb2wyLmV4cGVyaW1lbnRhbF90b1Rvb2xSZXN1bHRDb250ZW50KHRvb2xSZXN1bHQucmVzdWx0KSxcbiAgICAgICAgICBleHBlcmltZW50YWxfY29udGVudDogdG9vbDIuZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQoXG4gICAgICAgICAgICB0b29sUmVzdWx0LnJlc3VsdFxuICAgICAgICAgIClcbiAgICAgICAgfSA6IHtcbiAgICAgICAgICB0eXBlOiBcInRvb2wtcmVzdWx0XCIsXG4gICAgICAgICAgdG9vbENhbGxJZDogdG9vbFJlc3VsdC50b29sQ2FsbElkLFxuICAgICAgICAgIHRvb2xOYW1lOiB0b29sUmVzdWx0LnRvb2xOYW1lLFxuICAgICAgICAgIHJlc3VsdDogdG9vbFJlc3VsdC5yZXN1bHRcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIHJlc3BvbnNlTWVzc2FnZXM7XG59XG5cbi8vIGNvcmUvZ2VuZXJhdGUtdGV4dC9nZW5lcmF0ZS10ZXh0LnRzXG52YXIgb3JpZ2luYWxHZW5lcmF0ZUlkMyA9IGNyZWF0ZUlkR2VuZXJhdG9yMyh7IHByZWZpeDogXCJhaXR4dFwiLCBzaXplOiAyNCB9KTtcbmFzeW5jIGZ1bmN0aW9uIGdlbmVyYXRlVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4QXV0b21hdGljUm91bmR0cmlwcyA9IDAsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzLFxuICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogY29udGludWVTdGVwcyA9IGV4cGVyaW1lbnRhbF9jb250aW51YXRpb25TdGVwcyAhPSBudWxsID8gZXhwZXJpbWVudGFsX2NvbnRpbnVhdGlvblN0ZXBzIDogZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF90ZWxlbWV0cnk6IHRlbGVtZXRyeSxcbiAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHByb3ZpZGVyTWV0YWRhdGEsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIF9pbnRlcm5hbDoge1xuICAgIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQzID0gb3JpZ2luYWxHZW5lcmF0ZUlkMyxcbiAgICBjdXJyZW50RGF0ZSA9ICgpID0+IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpXG4gIH0gPSB7fSxcbiAgb25TdGVwRmluaXNoLFxuICAuLi5zZXR0aW5nc1xufSkge1xuICBpZiAobWF4U3RlcHMgPCAxKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIHBhcmFtZXRlcjogXCJtYXhTdGVwc1wiLFxuICAgICAgdmFsdWU6IG1heFN0ZXBzLFxuICAgICAgbWVzc2FnZTogXCJtYXhTdGVwcyBtdXN0IGJlIGF0IGxlYXN0IDFcIlxuICAgIH0pO1xuICB9XG4gIGNvbnN0IGJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzID0gZ2V0QmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgIG1vZGVsLFxuICAgIHRlbGVtZXRyeSxcbiAgICBoZWFkZXJzLFxuICAgIHNldHRpbmdzOiB7IC4uLnNldHRpbmdzLCBtYXhSZXRyaWVzIH1cbiAgfSk7XG4gIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgIHRvb2xzXG4gIH0pO1xuICBjb25zdCB0cmFjZXIgPSBnZXRUcmFjZXIodGVsZW1ldHJ5KTtcbiAgcmV0dXJuIHJlY29yZFNwYW4oe1xuICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0XCIsXG4gICAgICAgICAgdGVsZW1ldHJ5XG4gICAgICAgIH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICB2YXIgX2ExMSwgX2IsIF9jLCBfZCwgX2UsIF9mO1xuICAgICAgY29uc3QgcmV0cnkgPSByZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYoeyBtYXhSZXRyaWVzIH0pO1xuICAgICAgY29uc3QgbW9kZSA9IHtcbiAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgIC4uLnByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UoeyB0b29scywgdG9vbENob2ljZSwgYWN0aXZlVG9vbHMgfSlcbiAgICAgIH07XG4gICAgICBjb25zdCBjYWxsU2V0dGluZ3MgPSBwcmVwYXJlQ2FsbFNldHRpbmdzKHNldHRpbmdzKTtcbiAgICAgIGxldCBjdXJyZW50TW9kZWxSZXNwb25zZTtcbiAgICAgIGxldCBjdXJyZW50VG9vbENhbGxzID0gW107XG4gICAgICBsZXQgY3VycmVudFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgc3RlcENvdW50ID0gMDtcbiAgICAgIGNvbnN0IHJlc3BvbnNlTWVzc2FnZXMgPSBbXTtcbiAgICAgIGxldCB0ZXh0ID0gXCJcIjtcbiAgICAgIGNvbnN0IHN0ZXBzID0gW107XG4gICAgICBjb25zdCB1c2FnZSA9IHtcbiAgICAgICAgY29tcGxldGlvblRva2VuczogMCxcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfTtcbiAgICAgIGxldCBzdGVwVHlwZSA9IFwiaW5pdGlhbFwiO1xuICAgICAgZG8ge1xuICAgICAgICBpZiAoc3RlcENvdW50ID09PSAxKSB7XG4gICAgICAgICAgaW5pdGlhbFByb21wdC50eXBlID0gXCJtZXNzYWdlc1wiO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHByb21wdEZvcm1hdCA9IHN0ZXBDb3VudCA9PT0gMCA/IGluaXRpYWxQcm9tcHQudHlwZSA6IFwibWVzc2FnZXNcIjtcbiAgICAgICAgY29uc3QgcHJvbXB0TWVzc2FnZXMgPSBhd2FpdCBjb252ZXJ0VG9MYW5ndWFnZU1vZGVsUHJvbXB0KHtcbiAgICAgICAgICBwcm9tcHQ6IHtcbiAgICAgICAgICAgIHR5cGU6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgIHN5c3RlbTogaW5pdGlhbFByb21wdC5zeXN0ZW0sXG4gICAgICAgICAgICBtZXNzYWdlczogWy4uLmluaXRpYWxQcm9tcHQubWVzc2FnZXMsIC4uLnJlc3BvbnNlTWVzc2FnZXNdXG4gICAgICAgICAgfSxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzOiBtb2RlbC5zdXBwb3J0c0ltYWdlVXJscyxcbiAgICAgICAgICBtb2RlbFN1cHBvcnRzVXJsOiBtb2RlbC5zdXBwb3J0c1VybFxuICAgICAgICB9KTtcbiAgICAgICAgY3VycmVudE1vZGVsUmVzcG9uc2UgPSBhd2FpdCByZXRyeShcbiAgICAgICAgICAoKSA9PiByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgIG5hbWU6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkuZ2VuZXJhdGVUZXh0LmRvR2VuZXJhdGVcIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7IGlucHV0OiAoKSA9PiBwcm9tcHRGb3JtYXQgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTEyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTIgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMi5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4yKSA9PiB7XG4gICAgICAgICAgICAgIHZhciBfYTEyLCBfYjIsIF9jMiwgX2QyLCBfZTIsIF9mMjtcbiAgICAgICAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgbW9kZWwuZG9HZW5lcmF0ZSh7XG4gICAgICAgICAgICAgICAgbW9kZSxcbiAgICAgICAgICAgICAgICAuLi5jYWxsU2V0dGluZ3MsXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2VEYXRhID0ge1xuICAgICAgICAgICAgICAgIGlkOiAoX2IyID0gKF9hMTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfYTEyLmlkKSAhPSBudWxsID8gX2IyIDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IChfZDIgPSAoX2MyID0gcmVzdWx0LnJlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2MyLnRpbWVzdGFtcCkgIT0gbnVsbCA/IF9kMiA6IGN1cnJlbnREYXRlKCksXG4gICAgICAgICAgICAgICAgbW9kZWxJZDogKF9mMiA9IChfZTIgPSByZXN1bHQucmVzcG9uc2UpID09IG51bGwgPyB2b2lkIDAgOiBfZTIubW9kZWxJZCkgIT0gbnVsbCA/IF9mMiA6IG1vZGVsLm1vZGVsSWRcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgc3BhbjIuc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IHJlc3VsdC50ZXh0XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdC50b29sQ2FsbHMpXG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogcmVzcG9uc2VEYXRhLmlkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1vZGVsXCI6IHJlc3BvbnNlRGF0YS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLnRpbWVzdGFtcFwiOiByZXNwb25zZURhdGEudGltZXN0YW1wLnRvSVNPU3RyaW5nKCksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHJlc3VsdC51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UuY29tcGxldGlvblRva2Vuc1wiOiByZXN1bHQudXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogcmVzdWx0LmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiByZXN1bHQudGV4dFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0LnRvb2xDYWxscylcbiAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgLy8gc3RhbmRhcmRpemVkIGdlbi1haSBsbG0gc3BhbiBhdHRyaWJ1dGVzOlxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbcmVzdWx0LmZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLmlkXCI6IHJlc3BvbnNlRGF0YS5pZCxcbiAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UubW9kZWxcIjogcmVzcG9uc2VEYXRhLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiByZXN1bHQudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICBcImdlbl9haS51c2FnZS5vdXRwdXRfdG9rZW5zXCI6IHJlc3VsdC51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgcmV0dXJuIHsgLi4ucmVzdWx0LCByZXNwb25zZTogcmVzcG9uc2VEYXRhIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSlcbiAgICAgICAgKTtcbiAgICAgICAgY3VycmVudFRvb2xDYWxscyA9ICgoX2ExMSA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnRvb2xDYWxscykgIT0gbnVsbCA/IF9hMTEgOiBbXSkubWFwKFxuICAgICAgICAgIChtb2RlbFRvb2xDYWxsKSA9PiBwYXJzZVRvb2xDYWxsKHsgdG9vbENhbGw6IG1vZGVsVG9vbENhbGwsIHRvb2xzIH0pXG4gICAgICAgICk7XG4gICAgICAgIGN1cnJlbnRUb29sUmVzdWx0cyA9IHRvb2xzID09IG51bGwgPyBbXSA6IGF3YWl0IGV4ZWN1dGVUb29scyh7XG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xzLFxuICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgYWJvcnRTaWduYWxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IGN1cnJlbnRVc2FnZSA9IGNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZShcbiAgICAgICAgICBjdXJyZW50TW9kZWxSZXNwb25zZS51c2FnZVxuICAgICAgICApO1xuICAgICAgICB1c2FnZS5jb21wbGV0aW9uVG9rZW5zICs9IGN1cnJlbnRVc2FnZS5jb21wbGV0aW9uVG9rZW5zO1xuICAgICAgICB1c2FnZS5wcm9tcHRUb2tlbnMgKz0gY3VycmVudFVzYWdlLnByb21wdFRva2VucztcbiAgICAgICAgdXNhZ2UudG90YWxUb2tlbnMgKz0gY3VycmVudFVzYWdlLnRvdGFsVG9rZW5zO1xuICAgICAgICBsZXQgbmV4dFN0ZXBUeXBlID0gXCJkb25lXCI7XG4gICAgICAgIGlmICgrK3N0ZXBDb3VudCA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uID09PSBcImxlbmd0aFwiICYmIC8vIG9ubHkgdXNlIGNvbnRpbnVlIHdoZW4gdGhlcmUgYXJlIG5vIHRvb2wgY2FsbHM6XG4gICAgICAgICAgY3VycmVudFRvb2xDYWxscy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwiY29udGludWVcIjtcbiAgICAgICAgICB9IGVsc2UgaWYgKFxuICAgICAgICAgICAgLy8gdGhlcmUgYXJlIHRvb2wgY2FsbHM6XG4gICAgICAgICAgICBjdXJyZW50VG9vbENhbGxzLmxlbmd0aCA+IDAgJiYgLy8gYWxsIGN1cnJlbnQgdG9vbCBjYWxscyBoYXZlIHJlc3VsdHM6XG4gICAgICAgICAgICBjdXJyZW50VG9vbFJlc3VsdHMubGVuZ3RoID09PSBjdXJyZW50VG9vbENhbGxzLmxlbmd0aFxuICAgICAgICAgICkge1xuICAgICAgICAgICAgbmV4dFN0ZXBUeXBlID0gXCJ0b29sLXJlc3VsdFwiO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBjb25zdCBvcmlnaW5hbFRleHQgPSAoX2IgPSBjdXJyZW50TW9kZWxSZXNwb25zZS50ZXh0KSAhPSBudWxsID8gX2IgOiBcIlwiO1xuICAgICAgICBjb25zdCBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCA9IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgJiYgLy8gb25seSBmb3IgY29udGludWUgc3RlcHNcbiAgICAgICAgdGV4dC50cmltRW5kKCkgIT09IHRleHQgPyBvcmlnaW5hbFRleHQudHJpbVN0YXJ0KCkgOiBvcmlnaW5hbFRleHQ7XG4gICAgICAgIGNvbnN0IHN0ZXBUZXh0ID0gbmV4dFN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyByZW1vdmVUZXh0QWZ0ZXJMYXN0V2hpdGVzcGFjZShzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZCkgOiBzdGVwVGV4dExlYWRpbmdXaGl0ZXNwYWNlVHJpbW1lZDtcbiAgICAgICAgdGV4dCA9IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiIHx8IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyB0ZXh0ICsgc3RlcFRleHQgOiBzdGVwVGV4dDtcbiAgICAgICAgaWYgKHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIpIHtcbiAgICAgICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IHJlc3BvbnNlTWVzc2FnZXNbcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICAgICAgICBpZiAodHlwZW9mIGxhc3RNZXNzYWdlLmNvbnRlbnQgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQgKz0gc3RlcFRleHQ7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGxhc3RNZXNzYWdlLmNvbnRlbnQucHVzaCh7XG4gICAgICAgICAgICAgIHRleHQ6IHN0ZXBUZXh0LFxuICAgICAgICAgICAgICB0eXBlOiBcInRleHRcIlxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMucHVzaChcbiAgICAgICAgICAgIC4uLnRvUmVzcG9uc2VNZXNzYWdlcyh7XG4gICAgICAgICAgICAgIHRleHQsXG4gICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgICAgICB0b29sUmVzdWx0czogY3VycmVudFRvb2xSZXN1bHRzXG4gICAgICAgICAgICB9KVxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgdG9vbENhbGxzOiBjdXJyZW50VG9vbENhbGxzLFxuICAgICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgICAgZmluaXNoUmVhc29uOiBjdXJyZW50TW9kZWxSZXNwb25zZS5maW5pc2hSZWFzb24sXG4gICAgICAgICAgdXNhZ2U6IGN1cnJlbnRVc2FnZSxcbiAgICAgICAgICB3YXJuaW5nczogY3VycmVudE1vZGVsUmVzcG9uc2Uud2FybmluZ3MsXG4gICAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICAgIHJlcXVlc3Q6IChfYyA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJlcXVlc3QpICE9IG51bGwgPyBfYyA6IHt9LFxuICAgICAgICAgIHJlc3BvbnNlOiB7XG4gICAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICAgIGhlYWRlcnM6IChfZCA9IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2QuaGVhZGVycyxcbiAgICAgICAgICAgIC8vIGRlZXAgY2xvbmUgbXNncyB0byBhdm9pZCBtdXRhdGluZyBwYXN0IG1lc3NhZ2VzIGluIG11bHRpLXN0ZXA6XG4gICAgICAgICAgICBtZXNzYWdlczogSlNPTi5wYXJzZShKU09OLnN0cmluZ2lmeShyZXNwb25zZU1lc3NhZ2VzKSlcbiAgICAgICAgICB9LFxuICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBjdXJyZW50TW9kZWxSZXNwb25zZS5wcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICB9O1xuICAgICAgICBzdGVwcy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgIHN0ZXBUeXBlID0gbmV4dFN0ZXBUeXBlO1xuICAgICAgfSB3aGlsZSAoc3RlcFR5cGUgIT09IFwiZG9uZVwiKTtcbiAgICAgIHNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeShjdXJyZW50TW9kZWxSZXNwb25zZS50b29sQ2FsbHMpXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY3VycmVudE1vZGVsUmVzcG9uc2UudXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMsXG4gICAgICAgICAgICAvLyBkZXByZWNhdGVkOlxuICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgXCJhaS5yZXN1bHQudGV4dFwiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gY3VycmVudE1vZGVsUmVzcG9uc2UudGV4dFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIFwiYWkucmVzdWx0LnRvb2xDYWxsc1wiOiB7XG4gICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkoY3VycmVudE1vZGVsUmVzcG9uc2UudG9vbENhbGxzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgICByZXR1cm4gbmV3IERlZmF1bHRHZW5lcmF0ZVRleHRSZXN1bHQoe1xuICAgICAgICB0ZXh0LFxuICAgICAgICB0b29sQ2FsbHM6IGN1cnJlbnRUb29sQ2FsbHMsXG4gICAgICAgIHRvb2xSZXN1bHRzOiBjdXJyZW50VG9vbFJlc3VsdHMsXG4gICAgICAgIGZpbmlzaFJlYXNvbjogY3VycmVudE1vZGVsUmVzcG9uc2UuZmluaXNoUmVhc29uLFxuICAgICAgICB1c2FnZSxcbiAgICAgICAgd2FybmluZ3M6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLndhcm5pbmdzLFxuICAgICAgICByZXF1ZXN0OiAoX2UgPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yZXF1ZXN0KSAhPSBudWxsID8gX2UgOiB7fSxcbiAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAuLi5jdXJyZW50TW9kZWxSZXNwb25zZS5yZXNwb25zZSxcbiAgICAgICAgICBoZWFkZXJzOiAoX2YgPSBjdXJyZW50TW9kZWxSZXNwb25zZS5yYXdSZXNwb25zZSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLmhlYWRlcnMsXG4gICAgICAgICAgbWVzc2FnZXM6IHJlc3BvbnNlTWVzc2FnZXNcbiAgICAgICAgfSxcbiAgICAgICAgbG9ncHJvYnM6IGN1cnJlbnRNb2RlbFJlc3BvbnNlLmxvZ3Byb2JzLFxuICAgICAgICByZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgICBzdGVwcyxcbiAgICAgICAgcHJvdmlkZXJNZXRhZGF0YTogY3VycmVudE1vZGVsUmVzcG9uc2UucHJvdmlkZXJNZXRhZGF0YVxuICAgICAgfSk7XG4gICAgfVxuICB9KTtcbn1cbmFzeW5jIGZ1bmN0aW9uIGV4ZWN1dGVUb29scyh7XG4gIHRvb2xDYWxscyxcbiAgdG9vbHMsXG4gIHRyYWNlcixcbiAgdGVsZW1ldHJ5LFxuICBhYm9ydFNpZ25hbFxufSkge1xuICBjb25zdCB0b29sUmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKFxuICAgIHRvb2xDYWxscy5tYXAoYXN5bmMgKHRvb2xDYWxsKSA9PiB7XG4gICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xDYWxsLnRvb2xOYW1lXTtcbiAgICAgIGlmICgodG9vbDIgPT0gbnVsbCA/IHZvaWQgMCA6IHRvb2wyLmV4ZWN1dGUpID09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIHZvaWQgMDtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IHJlY29yZFNwYW4oe1xuICAgICAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAuLi5hc3NlbWJsZU9wZXJhdGlvbk5hbWUoe1xuICAgICAgICAgICAgICBvcGVyYXRpb25JZDogXCJhaS50b29sQ2FsbFwiLFxuICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5uYW1lXCI6IHRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5hcmdzXCI6IHtcbiAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sQ2FsbC5hcmdzKVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfSksXG4gICAgICAgIHRyYWNlcixcbiAgICAgICAgZm46IGFzeW5jIChzcGFuKSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVzdWx0MiA9IGF3YWl0IHRvb2wyLmV4ZWN1dGUodG9vbENhbGwuYXJncywgeyBhYm9ydFNpZ25hbCB9KTtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHJlc3VsdDIpXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgfVxuICAgICAgICAgIHJldHVybiByZXN1bHQyO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHRvb2xDYWxsSWQ6IHRvb2xDYWxsLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogdG9vbENhbGwuYXJncyxcbiAgICAgICAgcmVzdWx0XG4gICAgICB9O1xuICAgIH0pXG4gICk7XG4gIHJldHVybiB0b29sUmVzdWx0cy5maWx0ZXIoXG4gICAgKHJlc3VsdCkgPT4gcmVzdWx0ICE9IG51bGxcbiAgKTtcbn1cbnZhciBEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0ID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcihvcHRpb25zKSB7XG4gICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgIHRoaXMudG9vbENhbGxzID0gb3B0aW9ucy50b29sQ2FsbHM7XG4gICAgdGhpcy50b29sUmVzdWx0cyA9IG9wdGlvbnMudG9vbFJlc3VsdHM7XG4gICAgdGhpcy5maW5pc2hSZWFzb24gPSBvcHRpb25zLmZpbmlzaFJlYXNvbjtcbiAgICB0aGlzLnVzYWdlID0gb3B0aW9ucy51c2FnZTtcbiAgICB0aGlzLndhcm5pbmdzID0gb3B0aW9ucy53YXJuaW5ncztcbiAgICB0aGlzLnJlcXVlc3QgPSBvcHRpb25zLnJlcXVlc3Q7XG4gICAgdGhpcy5yZXNwb25zZSA9IG9wdGlvbnMucmVzcG9uc2U7XG4gICAgdGhpcy5yZXNwb25zZU1lc3NhZ2VzID0gb3B0aW9ucy5yZXNwb25zZU1lc3NhZ2VzO1xuICAgIHRoaXMucm91bmR0cmlwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5zdGVwcyA9IG9wdGlvbnMuc3RlcHM7XG4gICAgdGhpcy5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YSA9IG9wdGlvbnMucHJvdmlkZXJNZXRhZGF0YTtcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0ge1xuICAgICAgaGVhZGVyczogb3B0aW9ucy5yZXNwb25zZS5oZWFkZXJzXG4gICAgfTtcbiAgICB0aGlzLmxvZ3Byb2JzID0gb3B0aW9ucy5sb2dwcm9icztcbiAgfVxufTtcbnZhciBleHBlcmltZW50YWxfZ2VuZXJhdGVUZXh0ID0gZ2VuZXJhdGVUZXh0O1xuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbmltcG9ydCB7IGNyZWF0ZUlkR2VuZXJhdG9yIGFzIGNyZWF0ZUlkR2VuZXJhdG9yNCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIGNvcmUvdXRpbC9jcmVhdGUtc3RpdGNoYWJsZS1zdHJlYW0udHNcbmZ1bmN0aW9uIGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKSB7XG4gIGxldCBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgbGV0IGNvbnRyb2xsZXIgPSBudWxsO1xuICBsZXQgaXNDbG9zZWQgPSBmYWxzZTtcbiAgY29uc3QgcHJvY2Vzc1B1bGwgPSBhc3luYyAoKSA9PiB7XG4gICAgaWYgKGlzQ2xvc2VkICYmIGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IGlubmVyU3RyZWFtUmVhZGVyc1swXS5yZWFkKCk7XG4gICAgICBpZiAoZG9uZSkge1xuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgYXdhaXQgcHJvY2Vzc1B1bGwoKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0Nsb3NlZCkge1xuICAgICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICAgIH1cbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMuc2hpZnQoKTtcbiAgICAgIGlmIChpc0Nsb3NlZCAmJiBpbm5lclN0cmVhbVJlYWRlcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc3RyZWFtOiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgICAgc3RhcnQoY29udHJvbGxlclBhcmFtKSB7XG4gICAgICAgIGNvbnRyb2xsZXIgPSBjb250cm9sbGVyUGFyYW07XG4gICAgICB9LFxuICAgICAgcHVsbDogcHJvY2Vzc1B1bGwsXG4gICAgICBhc3luYyBjYW5jZWwoKSB7XG4gICAgICAgIGZvciAoY29uc3QgcmVhZGVyIG9mIGlubmVyU3RyZWFtUmVhZGVycykge1xuICAgICAgICAgIGF3YWl0IHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgfVxuICAgICAgICBpbm5lclN0cmVhbVJlYWRlcnMgPSBbXTtcbiAgICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pLFxuICAgIGFkZFN0cmVhbTogKGlubmVyU3RyZWFtKSA9PiB7XG4gICAgICBpZiAoaXNDbG9zZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2Fubm90IGFkZCBpbm5lciBzdHJlYW06IG91dGVyIHN0cmVhbSBpcyBjbG9zZWRcIik7XG4gICAgICB9XG4gICAgICBpbm5lclN0cmVhbVJlYWRlcnMucHVzaChpbm5lclN0cmVhbS5nZXRSZWFkZXIoKSk7XG4gICAgfSxcbiAgICBjbG9zZTogKCkgPT4ge1xuICAgICAgaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgaWYgKGlubmVyU3RyZWFtUmVhZGVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgY29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbn1cblxuLy8gY29yZS91dGlsL21lcmdlLXN0cmVhbXMudHNcbmZ1bmN0aW9uIG1lcmdlU3RyZWFtcyhzdHJlYW0xLCBzdHJlYW0yKSB7XG4gIGNvbnN0IHJlYWRlcjEgPSBzdHJlYW0xLmdldFJlYWRlcigpO1xuICBjb25zdCByZWFkZXIyID0gc3RyZWFtMi5nZXRSZWFkZXIoKTtcbiAgbGV0IGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgbGV0IGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgbGV0IHN0cmVhbTFEb25lID0gZmFsc2U7XG4gIGxldCBzdHJlYW0yRG9uZSA9IGZhbHNlO1xuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMShjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDEgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDEgPSByZWFkZXIxLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMTtcbiAgICAgIGxhc3RSZWFkMSA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICBhc3luYyBmdW5jdGlvbiByZWFkU3RyZWFtMihjb250cm9sbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIGlmIChsYXN0UmVhZDIgPT0gbnVsbCkge1xuICAgICAgICBsYXN0UmVhZDIgPSByZWFkZXIyLnJlYWQoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IHJlc3VsdCA9IGF3YWl0IGxhc3RSZWFkMjtcbiAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHJlc3VsdC52YWx1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGlmIChzdHJlYW0xRG9uZSkge1xuICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0yKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RyZWFtMkRvbmUpIHtcbiAgICAgICAgICBhd2FpdCByZWFkU3RyZWFtMShjb250cm9sbGVyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMSA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gcmVhZGVyMS5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxhc3RSZWFkMiA9PSBudWxsKSB7XG4gICAgICAgICAgbGFzdFJlYWQyID0gcmVhZGVyMi5yZWFkKCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgeyByZXN1bHQsIHJlYWRlciB9ID0gYXdhaXQgUHJvbWlzZS5yYWNlKFtcbiAgICAgICAgICBsYXN0UmVhZDEudGhlbigocmVzdWx0MikgPT4gKHsgcmVzdWx0OiByZXN1bHQyLCByZWFkZXI6IHJlYWRlcjEgfSkpLFxuICAgICAgICAgIGxhc3RSZWFkMi50aGVuKChyZXN1bHQyKSA9PiAoeyByZXN1bHQ6IHJlc3VsdDIsIHJlYWRlcjogcmVhZGVyMiB9KSlcbiAgICAgICAgXSk7XG4gICAgICAgIGlmICghcmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocmVzdWx0LnZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhZGVyID09PSByZWFkZXIxKSB7XG4gICAgICAgICAgbGFzdFJlYWQxID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChyZXN1bHQuZG9uZSkge1xuICAgICAgICAgICAgYXdhaXQgcmVhZFN0cmVhbTIoY29udHJvbGxlcik7XG4gICAgICAgICAgICBzdHJlYW0xRG9uZSA9IHRydWU7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RSZWFkMiA9IHZvaWQgMDtcbiAgICAgICAgICBpZiAocmVzdWx0LmRvbmUpIHtcbiAgICAgICAgICAgIHN0cmVhbTJEb25lID0gdHJ1ZTtcbiAgICAgICAgICAgIGF3YWl0IHJlYWRTdHJlYW0xKGNvbnRyb2xsZXIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgY29udHJvbGxlci5lcnJvcihlcnJvcik7XG4gICAgICB9XG4gICAgfSxcbiAgICBjYW5jZWwoKSB7XG4gICAgICByZWFkZXIxLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyMi5jYW5jZWwoKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvcnVuLXRvb2xzLXRyYW5zZm9ybWF0aW9uLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIHJ1blRvb2xzVHJhbnNmb3JtYXRpb24oe1xuICB0b29scyxcbiAgZ2VuZXJhdG9yU3RyZWFtLFxuICB0b29sQ2FsbFN0cmVhbWluZyxcbiAgdHJhY2VyLFxuICB0ZWxlbWV0cnksXG4gIGFib3J0U2lnbmFsXG59KSB7XG4gIGxldCB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIgPSBudWxsO1xuICBjb25zdCB0b29sUmVzdWx0c1N0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICB9XG4gIH0pO1xuICBjb25zdCBhY3RpdmVUb29sQ2FsbHMgPSB7fTtcbiAgY29uc3Qgb3V0c3RhbmRpbmdUb29sUmVzdWx0cyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgU2V0KCk7XG4gIGxldCBjYW5DbG9zZSA9IGZhbHNlO1xuICBsZXQgZmluaXNoQ2h1bmsgPSB2b2lkIDA7XG4gIGZ1bmN0aW9uIGF0dGVtcHRDbG9zZSgpIHtcbiAgICBpZiAoY2FuQ2xvc2UgJiYgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5zaXplID09PSAwKSB7XG4gICAgICBpZiAoZmluaXNoQ2h1bmsgIT0gbnVsbCkge1xuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZShmaW5pc2hDaHVuayk7XG4gICAgICB9XG4gICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB9XG4gIH1cbiAgY29uc3QgZm9yd2FyZFN0cmVhbSA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgIHN3aXRjaCAoY2h1bmtUeXBlKSB7XG4gICAgICAgIGNhc2UgXCJ0ZXh0LWRlbHRhXCI6XG4gICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOlxuICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsU3RyZWFtaW5nKSB7XG4gICAgICAgICAgICBpZiAoIWFjdGl2ZVRvb2xDYWxsc1tjaHVuay50b29sQ2FsbElkXSkge1xuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgIHR5cGU6IFwidG9vbC1jYWxsLXN0cmVhbWluZy1zdGFydFwiLFxuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBhY3RpdmVUb29sQ2FsbHNbY2h1bmsudG9vbENhbGxJZF0gPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLWNhbGwtZGVsdGFcIixcbiAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lLFxuICAgICAgICAgICAgICBhcmdzVGV4dERlbHRhOiBjaHVuay5hcmdzVGV4dERlbHRhXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcInRvb2wtY2FsbFwiOiB7XG4gICAgICAgICAgY29uc3QgdG9vbE5hbWUgPSBjaHVuay50b29sTmFtZTtcbiAgICAgICAgICBpZiAodG9vbHMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yKHsgdG9vbE5hbWU6IGNodW5rLnRvb2xOYW1lIH0pXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0b29sMiA9IHRvb2xzW3Rvb2xOYW1lXTtcbiAgICAgICAgICBpZiAodG9vbDIgPT0gbnVsbCkge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yOiBuZXcgTm9TdWNoVG9vbEVycm9yKHtcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXZhaWxhYmxlVG9vbHM6IE9iamVjdC5rZXlzKHRvb2xzKVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGNvbnN0IHRvb2xDYWxsID0gcGFyc2VUb29sQ2FsbCh7XG4gICAgICAgICAgICAgIHRvb2xDYWxsOiBjaHVuayxcbiAgICAgICAgICAgICAgdG9vbHNcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRvb2xDYWxsKTtcbiAgICAgICAgICAgIGlmICh0b29sMi5leGVjdXRlICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdG9vbEV4ZWN1dGlvbklkID0gZ2VuZXJhdGVJZCgpO1xuICAgICAgICAgICAgICBvdXRzdGFuZGluZ1Rvb2xSZXN1bHRzLmFkZCh0b29sRXhlY3V0aW9uSWQpO1xuICAgICAgICAgICAgICByZWNvcmRTcGFuKHtcbiAgICAgICAgICAgICAgICBuYW1lOiBcImFpLnRvb2xDYWxsXCIsXG4gICAgICAgICAgICAgICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7XG4gICAgICAgICAgICAgICAgICAgICAgb3BlcmF0aW9uSWQ6IFwiYWkudG9vbENhbGxcIixcbiAgICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnlcbiAgICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwubmFtZVwiOiB0b29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS50b29sQ2FsbC5pZFwiOiB0b29sQ2FsbC50b29sQ2FsbElkLFxuICAgICAgICAgICAgICAgICAgICBcImFpLnRvb2xDYWxsLmFyZ3NcIjoge1xuICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkodG9vbENhbGwuYXJncylcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgICBmbjogYXN5bmMgKHNwYW4pID0+IHRvb2wyLmV4ZWN1dGUodG9vbENhbGwuYXJncywgeyBhYm9ydFNpZ25hbCB9KS50aGVuKFxuICAgICAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0c1N0cmVhbUNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgLi4udG9vbENhbGwsXG4gICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJ0b29sLXJlc3VsdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgc3Bhbi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiYWkudG9vbENhbGwucmVzdWx0XCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgICAgICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAoZXJyb3IpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwiZXJyb3JcIixcbiAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgb3V0c3RhbmRpbmdUb29sUmVzdWx0cy5kZWxldGUodG9vbEV4ZWN1dGlvbklkKTtcbiAgICAgICAgICAgICAgICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgdG9vbFJlc3VsdHNTdHJlYW1Db250cm9sbGVyLmVucXVldWUoe1xuICAgICAgICAgICAgICB0eXBlOiBcImVycm9yXCIsXG4gICAgICAgICAgICAgIGVycm9yXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcImZpbmlzaFwiOiB7XG4gICAgICAgICAgZmluaXNoQ2h1bmsgPSB7XG4gICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgZmluaXNoUmVhc29uOiBjaHVuay5maW5pc2hSZWFzb24sXG4gICAgICAgICAgICBsb2dwcm9iczogY2h1bmsubG9ncHJvYnMsXG4gICAgICAgICAgICB1c2FnZTogY2FsY3VsYXRlTGFuZ3VhZ2VNb2RlbFVzYWdlKGNodW5rLnVzYWdlKSxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBjaHVuay5wcm92aWRlck1ldGFkYXRhXG4gICAgICAgICAgfTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgY29uc3QgX2V4aGF1c3RpdmVDaGVjayA9IGNodW5rVHlwZTtcbiAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVuaGFuZGxlZCBjaHVuayB0eXBlOiAke19leGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9LFxuICAgIGZsdXNoKCkge1xuICAgICAgY2FuQ2xvc2UgPSB0cnVlO1xuICAgICAgYXR0ZW1wdENsb3NlKCk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgcmV0dXJuIFByb21pc2UuYWxsKFtcbiAgICAgICAgZ2VuZXJhdG9yU3RyZWFtLnBpcGVUaHJvdWdoKGZvcndhcmRTdHJlYW0pLnBpcGVUbyhcbiAgICAgICAgICBuZXcgV3JpdGFibGVTdHJlYW0oe1xuICAgICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZSgpIHtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApLFxuICAgICAgICB0b29sUmVzdWx0c1N0cmVhbS5waXBlVG8oXG4gICAgICAgICAgbmV3IFdyaXRhYmxlU3RyZWFtKHtcbiAgICAgICAgICAgIHdyaXRlKGNodW5rKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KVxuICAgICAgICApXG4gICAgICBdKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBjb3JlL2dlbmVyYXRlLXRleHQvc3RyZWFtLXRleHQudHNcbnZhciBvcmlnaW5hbEdlbmVyYXRlSWQ0ID0gY3JlYXRlSWRHZW5lcmF0b3I0KHsgcHJlZml4OiBcImFpdHh0XCIsIHNpemU6IDI0IH0pO1xuYXN5bmMgZnVuY3Rpb24gc3RyZWFtVGV4dCh7XG4gIG1vZGVsLFxuICB0b29scyxcbiAgdG9vbENob2ljZSxcbiAgc3lzdGVtLFxuICBwcm9tcHQsXG4gIG1lc3NhZ2VzLFxuICBtYXhSZXRyaWVzLFxuICBhYm9ydFNpZ25hbCxcbiAgaGVhZGVycyxcbiAgbWF4VG9vbFJvdW5kdHJpcHMgPSAwLFxuICBtYXhTdGVwcyA9IG1heFRvb2xSb3VuZHRyaXBzICE9IG51bGwgPyBtYXhUb29sUm91bmR0cmlwcyArIDEgOiAxLFxuICBleHBlcmltZW50YWxfY29udGludWVTdGVwczogY29udGludWVTdGVwcyA9IGZhbHNlLFxuICBleHBlcmltZW50YWxfdGVsZW1ldHJ5OiB0ZWxlbWV0cnksXG4gIGV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhOiBwcm92aWRlck1ldGFkYXRhLFxuICBleHBlcmltZW50YWxfdG9vbENhbGxTdHJlYW1pbmc6IHRvb2xDYWxsU3RyZWFtaW5nID0gZmFsc2UsXG4gIGV4cGVyaW1lbnRhbF9hY3RpdmVUb29sczogYWN0aXZlVG9vbHMsXG4gIG9uQ2h1bmssXG4gIG9uRmluaXNoLFxuICBvblN0ZXBGaW5pc2gsXG4gIF9pbnRlcm5hbDoge1xuICAgIG5vdzogbm93MiA9IG5vdyxcbiAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyA9IG9yaWdpbmFsR2VuZXJhdGVJZDQsXG4gICAgY3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxuICB9ID0ge30sXG4gIC4uLnNldHRpbmdzXG59KSB7XG4gIGlmIChtYXhTdGVwcyA8IDEpIHtcbiAgICB0aHJvdyBuZXcgSW52YWxpZEFyZ3VtZW50RXJyb3Ioe1xuICAgICAgcGFyYW1ldGVyOiBcIm1heFN0ZXBzXCIsXG4gICAgICB2YWx1ZTogbWF4U3RlcHMsXG4gICAgICBtZXNzYWdlOiBcIm1heFN0ZXBzIG11c3QgYmUgYXQgbGVhc3QgMVwiXG4gICAgfSk7XG4gIH1cbiAgY29uc3QgYmFzZVRlbGVtZXRyeUF0dHJpYnV0ZXMgPSBnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgbW9kZWwsXG4gICAgdGVsZW1ldHJ5LFxuICAgIGhlYWRlcnMsXG4gICAgc2V0dGluZ3M6IHsgLi4uc2V0dGluZ3MsIG1heFJldHJpZXMgfVxuICB9KTtcbiAgY29uc3QgdHJhY2VyID0gZ2V0VHJhY2VyKHRlbGVtZXRyeSk7XG4gIGNvbnN0IGluaXRpYWxQcm9tcHQgPSBzdGFuZGFyZGl6ZVByb21wdCh7XG4gICAgcHJvbXB0OiB7IHN5c3RlbSwgcHJvbXB0LCBtZXNzYWdlcyB9LFxuICAgIHRvb2xzXG4gIH0pO1xuICByZXR1cm4gcmVjb3JkU3Bhbih7XG4gICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0XCIsXG4gICAgYXR0cmlidXRlczogc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICB0ZWxlbWV0cnksXG4gICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgIC4uLmFzc2VtYmxlT3BlcmF0aW9uTmFtZSh7IG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHRcIiwgdGVsZW1ldHJ5IH0pLFxuICAgICAgICAuLi5iYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyxcbiAgICAgICAgLy8gc3BlY2lmaWMgc2V0dGluZ3MgdGhhdCBvbmx5IG1ha2Ugc2Vuc2Ugb24gdGhlIG91dGVyIGxldmVsOlxuICAgICAgICBcImFpLnByb21wdFwiOiB7XG4gICAgICAgICAgaW5wdXQ6ICgpID0+IEpTT04uc3RyaW5naWZ5KHsgc3lzdGVtLCBwcm9tcHQsIG1lc3NhZ2VzIH0pXG4gICAgICAgIH0sXG4gICAgICAgIFwiYWkuc2V0dGluZ3MubWF4U3RlcHNcIjogbWF4U3RlcHNcbiAgICAgIH1cbiAgICB9KSxcbiAgICB0cmFjZXIsXG4gICAgZW5kV2hlbkRvbmU6IGZhbHNlLFxuICAgIGZuOiBhc3luYyAocm9vdFNwYW4pID0+IHtcbiAgICAgIGNvbnN0IHJldHJ5ID0gcmV0cnlXaXRoRXhwb25lbnRpYWxCYWNrb2ZmKHsgbWF4UmV0cmllcyB9KTtcbiAgICAgIGNvbnN0IHN0YXJ0U3RlcCA9IGFzeW5jICh7XG4gICAgICAgIHJlc3BvbnNlTWVzc2FnZXNcbiAgICAgIH0pID0+IHtcbiAgICAgICAgY29uc3QgcHJvbXB0Rm9ybWF0ID0gcmVzcG9uc2VNZXNzYWdlcy5sZW5ndGggPT09IDAgPyBpbml0aWFsUHJvbXB0LnR5cGUgOiBcIm1lc3NhZ2VzXCI7XG4gICAgICAgIGNvbnN0IHByb21wdE1lc3NhZ2VzID0gYXdhaXQgY29udmVydFRvTGFuZ3VhZ2VNb2RlbFByb21wdCh7XG4gICAgICAgICAgcHJvbXB0OiB7XG4gICAgICAgICAgICB0eXBlOiBwcm9tcHRGb3JtYXQsXG4gICAgICAgICAgICBzeXN0ZW06IGluaXRpYWxQcm9tcHQuc3lzdGVtLFxuICAgICAgICAgICAgbWVzc2FnZXM6IFsuLi5pbml0aWFsUHJvbXB0Lm1lc3NhZ2VzLCAuLi5yZXNwb25zZU1lc3NhZ2VzXVxuICAgICAgICAgIH0sXG4gICAgICAgICAgbW9kZWxTdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgICAgICAgbW9kZWxTdXBwb3J0c1VybDogbW9kZWwuc3VwcG9ydHNVcmxcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IG1vZGUgPSB7XG4gICAgICAgICAgdHlwZTogXCJyZWd1bGFyXCIsXG4gICAgICAgICAgLi4ucHJlcGFyZVRvb2xzQW5kVG9vbENob2ljZSh7IHRvb2xzLCB0b29sQ2hvaWNlLCBhY3RpdmVUb29scyB9KVxuICAgICAgICB9O1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmVzdWx0OiB7IHN0cmVhbTogc3RyZWFtMiwgd2FybmluZ3M6IHdhcm5pbmdzMiwgcmF3UmVzcG9uc2U6IHJhd1Jlc3BvbnNlMiwgcmVxdWVzdDogcmVxdWVzdDIgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfSA9IGF3YWl0IHJldHJ5KFxuICAgICAgICAgICgpID0+IHJlY29yZFNwYW4oe1xuICAgICAgICAgICAgbmFtZTogXCJhaS5zdHJlYW1UZXh0LmRvU3RyZWFtXCIsXG4gICAgICAgICAgICBhdHRyaWJ1dGVzOiBzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzKHtcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7XG4gICAgICAgICAgICAgICAgLi4uYXNzZW1ibGVPcGVyYXRpb25OYW1lKHtcbiAgICAgICAgICAgICAgICAgIG9wZXJhdGlvbklkOiBcImFpLnN0cmVhbVRleHQuZG9TdHJlYW1cIixcbiAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeVxuICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgIC4uLmJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzLFxuICAgICAgICAgICAgICAgIFwiYWkucHJvbXB0LmZvcm1hdFwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gcHJvbXB0Rm9ybWF0XG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC5tZXNzYWdlc1wiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gSlNPTi5zdHJpbmdpZnkocHJvbXB0TWVzc2FnZXMpXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBcImFpLnByb21wdC50b29sc1wiOiB7XG4gICAgICAgICAgICAgICAgICAvLyBjb252ZXJ0IHRoZSBsYW5ndWFnZSBtb2RlbCBsZXZlbCB0b29sczpcbiAgICAgICAgICAgICAgICAgIGlucHV0OiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBfYTExO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hMTEgPSBtb2RlLnRvb2xzKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5tYXAoKHRvb2wyKSA9PiBKU09OLnN0cmluZ2lmeSh0b29sMikpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgXCJhaS5wcm9tcHQudG9vbENob2ljZVwiOiB7XG4gICAgICAgICAgICAgICAgICBpbnB1dDogKCkgPT4gbW9kZS50b29sQ2hvaWNlICE9IG51bGwgPyBKU09OLnN0cmluZ2lmeShtb2RlLnRvb2xDaG9pY2UpIDogdm9pZCAwXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAvLyBzdGFuZGFyZGl6ZWQgZ2VuLWFpIGxsbSBzcGFuIGF0dHJpYnV0ZXM6XG4gICAgICAgICAgICAgICAgXCJnZW5fYWkuc3lzdGVtXCI6IG1vZGVsLnByb3ZpZGVyLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QubW9kZWxcIjogbW9kZWwubW9kZWxJZCxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LmZyZXF1ZW5jeV9wZW5hbHR5XCI6IHNldHRpbmdzLmZyZXF1ZW5jeVBlbmFsdHksXG4gICAgICAgICAgICAgICAgXCJnZW5fYWkucmVxdWVzdC5tYXhfdG9rZW5zXCI6IHNldHRpbmdzLm1heFRva2VucyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnByZXNlbmNlX3BlbmFsdHlcIjogc2V0dGluZ3MucHJlc2VuY2VQZW5hbHR5LFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3Quc3RvcF9zZXF1ZW5jZXNcIjogc2V0dGluZ3Muc3RvcFNlcXVlbmNlcyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRlbXBlcmF0dXJlXCI6IHNldHRpbmdzLnRlbXBlcmF0dXJlLFxuICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlcXVlc3QudG9wX2tcIjogc2V0dGluZ3MudG9wSyxcbiAgICAgICAgICAgICAgICBcImdlbl9haS5yZXF1ZXN0LnRvcF9wXCI6IHNldHRpbmdzLnRvcFBcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB0cmFjZXIsXG4gICAgICAgICAgICBlbmRXaGVuRG9uZTogZmFsc2UsXG4gICAgICAgICAgICBmbjogYXN5bmMgKGRvU3RyZWFtU3BhbjMpID0+ICh7XG4gICAgICAgICAgICAgIHN0YXJ0VGltZXN0YW1wTXM6IG5vdzIoKSxcbiAgICAgICAgICAgICAgLy8gZ2V0IGJlZm9yZSB0aGUgY2FsbFxuICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjMsXG4gICAgICAgICAgICAgIHJlc3VsdDogYXdhaXQgbW9kZWwuZG9TdHJlYW0oe1xuICAgICAgICAgICAgICAgIG1vZGUsXG4gICAgICAgICAgICAgICAgLi4ucHJlcGFyZUNhbGxTZXR0aW5ncyhzZXR0aW5ncyksXG4gICAgICAgICAgICAgICAgaW5wdXRGb3JtYXQ6IHByb21wdEZvcm1hdCxcbiAgICAgICAgICAgICAgICBwcm9tcHQ6IHByb21wdE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgIHByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgYWJvcnRTaWduYWwsXG4gICAgICAgICAgICAgICAgaGVhZGVyc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICB9KVxuICAgICAgICApO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHJlc3VsdDoge1xuICAgICAgICAgICAgc3RyZWFtOiBydW5Ub29sc1RyYW5zZm9ybWF0aW9uKHtcbiAgICAgICAgICAgICAgdG9vbHMsXG4gICAgICAgICAgICAgIGdlbmVyYXRvclN0cmVhbTogc3RyZWFtMixcbiAgICAgICAgICAgICAgdG9vbENhbGxTdHJlYW1pbmcsXG4gICAgICAgICAgICAgIHRyYWNlcixcbiAgICAgICAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICAgICAgICBhYm9ydFNpZ25hbFxuICAgICAgICAgICAgfSksXG4gICAgICAgICAgICB3YXJuaW5nczogd2FybmluZ3MyLFxuICAgICAgICAgICAgcmVxdWVzdDogcmVxdWVzdDIgIT0gbnVsbCA/IHJlcXVlc3QyIDoge30sXG4gICAgICAgICAgICByYXdSZXNwb25zZTogcmF3UmVzcG9uc2UyXG4gICAgICAgICAgfSxcbiAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICAgICAgc3RhcnRUaW1lc3RhbXBNczogc3RhcnRUaW1lc3RhbXBNczJcbiAgICAgICAgfTtcbiAgICAgIH07XG4gICAgICBjb25zdCB7XG4gICAgICAgIHJlc3VsdDogeyBzdHJlYW0sIHdhcm5pbmdzLCByYXdSZXNwb25zZSwgcmVxdWVzdCB9LFxuICAgICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICAgIHN0YXJ0VGltZXN0YW1wTXNcbiAgICAgIH0gPSBhd2FpdCBzdGFydFN0ZXAoeyByZXNwb25zZU1lc3NhZ2VzOiBbXSB9KTtcbiAgICAgIHJldHVybiBuZXcgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQoe1xuICAgICAgICBzdHJlYW0sXG4gICAgICAgIHdhcm5pbmdzLFxuICAgICAgICByYXdSZXNwb25zZSxcbiAgICAgICAgcmVxdWVzdCxcbiAgICAgICAgb25DaHVuayxcbiAgICAgICAgb25GaW5pc2gsXG4gICAgICAgIG9uU3RlcEZpbmlzaCxcbiAgICAgICAgcm9vdFNwYW4sXG4gICAgICAgIGRvU3RyZWFtU3BhbixcbiAgICAgICAgdGVsZW1ldHJ5LFxuICAgICAgICBzdGFydFRpbWVzdGFtcE1zLFxuICAgICAgICBtYXhTdGVwcyxcbiAgICAgICAgY29udGludWVTdGVwcyxcbiAgICAgICAgc3RhcnRTdGVwLFxuICAgICAgICBtb2RlbElkOiBtb2RlbC5tb2RlbElkLFxuICAgICAgICBub3c6IG5vdzIsXG4gICAgICAgIGN1cnJlbnREYXRlLFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMyxcbiAgICAgICAgdG9vbHNcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG59XG52YXIgRGVmYXVsdFN0cmVhbVRleHRSZXN1bHQgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBzdHJlYW0sXG4gICAgd2FybmluZ3MsXG4gICAgcmF3UmVzcG9uc2UsXG4gICAgcmVxdWVzdCxcbiAgICBvbkNodW5rLFxuICAgIG9uRmluaXNoLFxuICAgIG9uU3RlcEZpbmlzaCxcbiAgICByb290U3BhbixcbiAgICBkb1N0cmVhbVNwYW4sXG4gICAgdGVsZW1ldHJ5LFxuICAgIHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgbWF4U3RlcHMsXG4gICAgY29udGludWVTdGVwcyxcbiAgICBzdGFydFN0ZXAsXG4gICAgbW9kZWxJZCxcbiAgICBub3c6IG5vdzIsXG4gICAgY3VycmVudERhdGUsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDMsXG4gICAgdG9vbHNcbiAgfSkge1xuICAgIHRoaXMud2FybmluZ3MgPSB3YXJuaW5ncztcbiAgICB0aGlzLnJhd1Jlc3BvbnNlID0gcmF3UmVzcG9uc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVXNhZ2UsIHByb21pc2U6IHVzYWdlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnVzYWdlID0gdXNhZ2VQcm9taXNlO1xuICAgIGNvbnN0IHsgcmVzb2x2ZTogcmVzb2x2ZUZpbmlzaFJlYXNvbiwgcHJvbWlzZTogZmluaXNoUmVhc29uUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmZpbmlzaFJlYXNvbiA9IGZpbmlzaFJlYXNvblByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVGV4dCwgcHJvbWlzZTogdGV4dFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy50ZXh0ID0gdGV4dFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlVG9vbENhbGxzLCBwcm9taXNlOiB0b29sQ2FsbHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbENhbGxzID0gdG9vbENhbGxzUHJvbWlzZTtcbiAgICBjb25zdCB7IHJlc29sdmU6IHJlc29sdmVUb29sUmVzdWx0cywgcHJvbWlzZTogdG9vbFJlc3VsdHNQcm9taXNlIH0gPSBjcmVhdGVSZXNvbHZhYmxlUHJvbWlzZSgpO1xuICAgIHRoaXMudG9vbFJlc3VsdHMgPSB0b29sUmVzdWx0c1Byb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlU3RlcHMsIHByb21pc2U6IHN0ZXBzUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnN0ZXBzID0gc3RlcHNQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVQcm92aWRlck1ldGFkYXRhLFxuICAgICAgcHJvbWlzZTogcHJvdmlkZXJNZXRhZGF0YVByb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLmV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhID0gcHJvdmlkZXJNZXRhZGF0YVByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVxdWVzdCwgcHJvbWlzZTogcmVxdWVzdFByb21pc2UgfSA9IGNyZWF0ZVJlc29sdmFibGVQcm9taXNlKCk7XG4gICAgdGhpcy5yZXF1ZXN0ID0gcmVxdWVzdFByb21pc2U7XG4gICAgY29uc3QgeyByZXNvbHZlOiByZXNvbHZlUmVzcG9uc2UsIHByb21pc2U6IHJlc3BvbnNlUHJvbWlzZSB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlID0gcmVzcG9uc2VQcm9taXNlO1xuICAgIGNvbnN0IHtcbiAgICAgIHJlc29sdmU6IHJlc29sdmVSZXNwb25zZU1lc3NhZ2VzLFxuICAgICAgcHJvbWlzZTogcmVzcG9uc2VNZXNzYWdlc1Byb21pc2VcbiAgICB9ID0gY3JlYXRlUmVzb2x2YWJsZVByb21pc2UoKTtcbiAgICB0aGlzLnJlc3BvbnNlTWVzc2FnZXMgPSByZXNwb25zZU1lc3NhZ2VzUHJvbWlzZTtcbiAgICBjb25zdCB7XG4gICAgICBzdHJlYW06IHN0aXRjaGFibGVTdHJlYW0sXG4gICAgICBhZGRTdHJlYW0sXG4gICAgICBjbG9zZTogY2xvc2VTdGl0Y2hhYmxlU3RyZWFtXG4gICAgfSA9IGNyZWF0ZVN0aXRjaGFibGVTdHJlYW0oKTtcbiAgICB0aGlzLm9yaWdpbmFsU3RyZWFtID0gc3RpdGNoYWJsZVN0cmVhbTtcbiAgICBjb25zdCBzdGVwUmVzdWx0cyA9IFtdO1xuICAgIGNvbnN0IHNlbGYgPSB0aGlzO1xuICAgIGZ1bmN0aW9uIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgc3RyZWFtOiBzdHJlYW0yLFxuICAgICAgc3RhcnRUaW1lc3RhbXAsXG4gICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjIsXG4gICAgICBjdXJyZW50U3RlcCxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICB1c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfSxcbiAgICAgIHN0ZXBUeXBlLFxuICAgICAgcHJldmlvdXNTdGVwVGV4dCA9IFwiXCIsXG4gICAgICBzdGVwUmVxdWVzdCxcbiAgICAgIGhhc0xlYWRpbmdXaGl0ZXNwYWNlXG4gICAgfSkge1xuICAgICAgY29uc3Qgc3RlcFRvb2xDYWxscyA9IFtdO1xuICAgICAgY29uc3Qgc3RlcFRvb2xSZXN1bHRzID0gW107XG4gICAgICBsZXQgc3RlcEZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICAgICAgbGV0IHN0ZXBVc2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiAwLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiAwLFxuICAgICAgICB0b3RhbFRva2VuczogMFxuICAgICAgfTtcbiAgICAgIGxldCBzdGVwUHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgIGxldCBzdGVwRmlyc3RDaHVuayA9IHRydWU7XG4gICAgICBsZXQgc3RlcFRleHQgPSBcIlwiO1xuICAgICAgbGV0IGZ1bGxTdGVwVGV4dCA9IHN0ZXBUeXBlID09PSBcImNvbnRpbnVlXCIgPyBwcmV2aW91c1N0ZXBUZXh0IDogXCJcIjtcbiAgICAgIGxldCBzdGVwTG9nUHJvYnM7XG4gICAgICBsZXQgc3RlcFJlc3BvbnNlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDMoKSxcbiAgICAgICAgdGltZXN0YW1wOiBjdXJyZW50RGF0ZSgpLFxuICAgICAgICBtb2RlbElkXG4gICAgICB9O1xuICAgICAgbGV0IGNodW5rQnVmZmVyID0gXCJcIjtcbiAgICAgIGxldCBjaHVua1RleHRQdWJsaXNoZWQgPSBmYWxzZTtcbiAgICAgIGxldCBpbldoaXRlc3BhY2VQcmVmaXggPSB0cnVlO1xuICAgICAgbGV0IGhhc1doaXRlc3BhY2VTdWZmaXggPSBmYWxzZTtcbiAgICAgIGFzeW5jIGZ1bmN0aW9uIHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICBjb250cm9sbGVyLFxuICAgICAgICBjaHVua1xuICAgICAgfSkge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBzdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGZ1bGxTdGVwVGV4dCArPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGNodW5rVGV4dFB1Ymxpc2hlZCA9IHRydWU7XG4gICAgICAgIGhhc1doaXRlc3BhY2VTdWZmaXggPSBjaHVuay50ZXh0RGVsdGEudHJpbUVuZCgpICE9PSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgfVxuICAgICAgYWRkU3RyZWFtKFxuICAgICAgICBzdHJlYW0yLnBpcGVUaHJvdWdoKFxuICAgICAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICAgICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgICAgIHZhciBfYTExLCBfYiwgX2M7XG4gICAgICAgICAgICAgIGlmIChzdGVwRmlyc3RDaHVuaykge1xuICAgICAgICAgICAgICAgIGNvbnN0IG1zVG9GaXJzdENodW5rID0gbm93MigpIC0gc3RhcnRUaW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgc3RlcEZpcnN0Q2h1bmsgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLmFkZEV2ZW50KFwiYWkuc3RyZWFtLmZpcnN0Q2h1bmtcIiwge1xuICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVuayxcbiAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWQ6XG4gICAgICAgICAgICAgICAgICBcImFpLnN0cmVhbS5tc1RvRmlyc3RDaHVua1wiOiBtc1RvRmlyc3RDaHVua1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuc2V0QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rLFxuICAgICAgICAgICAgICAgICAgLy8gZGVwcmVjYXRlZDpcbiAgICAgICAgICAgICAgICAgIFwiYWkuc3RyZWFtLm1zVG9GaXJzdENodW5rXCI6IG1zVG9GaXJzdENodW5rXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNodW5rLnR5cGUgPT09IFwidGV4dC1kZWx0YVwiICYmIGNodW5rLnRleHREZWx0YS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBpZiAoY29udGludWVTdGVwcykge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB0cmltbWVkQ2h1bmtUZXh0ID0gaW5XaGl0ZXNwYWNlUHJlZml4ICYmIGhhc0xlYWRpbmdXaGl0ZXNwYWNlID8gY2h1bmsudGV4dERlbHRhLnRyaW1TdGFydCgpIDogY2h1bmsudGV4dERlbHRhO1xuICAgICAgICAgICAgICAgICAgICBpZiAodHJpbW1lZENodW5rVGV4dC5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpbldoaXRlc3BhY2VQcmVmaXggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgKz0gdHJpbW1lZENodW5rVGV4dDtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXQgPSBzcGxpdE9uTGFzdFdoaXRlc3BhY2UoY2h1bmtCdWZmZXIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3BsaXQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgIGNodW5rQnVmZmVyID0gc3BsaXQuc3VmZml4O1xuICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IHNwbGl0LnByZWZpeCArIHNwbGl0LndoaXRlc3BhY2VcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgYXdhaXQgcHVibGlzaFRleHRDaHVuayh7IGNvbnRyb2xsZXIsIGNodW5rIH0pO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJ0b29sLWNhbGxcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMucHVzaChjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBUb29sUmVzdWx0cy5wdXNoKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIGF3YWl0IChvbkNodW5rID09IG51bGwgPyB2b2lkIDAgOiBvbkNodW5rKHsgY2h1bmsgfSkpO1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJyZXNwb25zZS1tZXRhZGF0YVwiOiB7XG4gICAgICAgICAgICAgICAgICBzdGVwUmVzcG9uc2UgPSB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiAoX2ExMSA9IGNodW5rLmlkKSAhPSBudWxsID8gX2ExMSA6IHN0ZXBSZXNwb25zZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdGltZXN0YW1wOiAoX2IgPSBjaHVuay50aW1lc3RhbXApICE9IG51bGwgPyBfYiA6IHN0ZXBSZXNwb25zZS50aW1lc3RhbXAsXG4gICAgICAgICAgICAgICAgICAgIG1vZGVsSWQ6IChfYyA9IGNodW5rLm1vZGVsSWQpICE9IG51bGwgPyBfYyA6IHN0ZXBSZXNwb25zZS5tb2RlbElkXG4gICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhc2UgXCJmaW5pc2hcIjoge1xuICAgICAgICAgICAgICAgICAgc3RlcFVzYWdlID0gY2h1bmsudXNhZ2U7XG4gICAgICAgICAgICAgICAgICBzdGVwRmluaXNoUmVhc29uID0gY2h1bmsuZmluaXNoUmVhc29uO1xuICAgICAgICAgICAgICAgICAgc3RlcFByb3ZpZGVyTWV0YWRhdGEgPSBjaHVuay5leHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBMb2dQcm9icyA9IGNodW5rLmxvZ3Byb2JzO1xuICAgICAgICAgICAgICAgICAgY29uc3QgbXNUb0ZpbmlzaCA9IG5vdzIoKSAtIHN0YXJ0VGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5hZGRFdmVudChcImFpLnN0cmVhbS5maW5pc2hcIik7XG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW4yLnNldEF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLm1zVG9GaW5pc2hcIjogbXNUb0ZpbmlzaCxcbiAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS5hdmdDb21wbGV0aW9uVG9rZW5zUGVyU2Vjb25kXCI6IDFlMyAqIHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zIC8gbXNUb0ZpbmlzaFxuICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjpcbiAgICAgICAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsLWRlbHRhXCI6IHtcbiAgICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShjaHVuayk7XG4gICAgICAgICAgICAgICAgICBhd2FpdCAob25DaHVuayA9PSBudWxsID8gdm9pZCAwIDogb25DaHVuayh7IGNodW5rIH0pKTtcbiAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXNlIFwiZXJyb3JcIjoge1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rKTtcbiAgICAgICAgICAgICAgICAgIHN0ZXBGaW5pc2hSZWFzb24gPSBcImVycm9yXCI7XG4gICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gY2h1bmtUeXBlO1xuICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIGNodW5rIHR5cGU6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIC8vIGludm9rZSBvbkZpbmlzaCBjYWxsYmFjayBhbmQgcmVzb2x2ZSB0b29sUmVzdWx0cyBwcm9taXNlIHdoZW4gdGhlIHN0cmVhbSBpcyBhYm91dCB0byBjbG9zZTpcbiAgICAgICAgICAgIGFzeW5jIGZsdXNoKGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgICAgICAgIGNvbnN0IHN0ZXBUb29sQ2FsbHNKc29uID0gc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwID8gSlNPTi5zdHJpbmdpZnkoc3RlcFRvb2xDYWxscykgOiB2b2lkIDA7XG4gICAgICAgICAgICAgIGxldCBuZXh0U3RlcFR5cGUgPSBcImRvbmVcIjtcbiAgICAgICAgICAgICAgaWYgKGN1cnJlbnRTdGVwICsgMSA8IG1heFN0ZXBzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgc3RlcEZpbmlzaFJlYXNvbiA9PT0gXCJsZW5ndGhcIiAmJiAvLyBvbmx5IHVzZSBjb250aW51ZSB3aGVuIHRoZXJlIGFyZSBubyB0b29sIGNhbGxzOlxuICAgICAgICAgICAgICAgIHN0ZXBUb29sQ2FsbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBuZXh0U3RlcFR5cGUgPSBcImNvbnRpbnVlXCI7XG4gICAgICAgICAgICAgICAgfSBlbHNlIGlmIChcbiAgICAgICAgICAgICAgICAgIC8vIHRoZXJlIGFyZSB0b29sIGNhbGxzOlxuICAgICAgICAgICAgICAgICAgc3RlcFRvb2xDYWxscy5sZW5ndGggPiAwICYmIC8vIGFsbCBjdXJyZW50IHRvb2wgY2FsbHMgaGF2ZSByZXN1bHRzOlxuICAgICAgICAgICAgICAgICAgc3RlcFRvb2xSZXN1bHRzLmxlbmd0aCA9PT0gc3RlcFRvb2xDYWxscy5sZW5ndGhcbiAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgIG5leHRTdGVwVHlwZSA9IFwidG9vbC1yZXN1bHRcIjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKGNvbnRpbnVlU3RlcHMgJiYgY2h1bmtCdWZmZXIubGVuZ3RoID4gMCAmJiAobmV4dFN0ZXBUeXBlICE9PSBcImNvbnRpbnVlXCIgfHwgLy8gd2hlbiB0aGUgbmV4dCBzdGVwIGlzIGEgcmVndWxhciBzdGVwLCBwdWJsaXNoIHRoZSBidWZmZXJcbiAgICAgICAgICAgICAgc3RlcFR5cGUgPT09IFwiY29udGludWVcIiAmJiAhY2h1bmtUZXh0UHVibGlzaGVkKSkge1xuICAgICAgICAgICAgICAgIGF3YWl0IHB1Ymxpc2hUZXh0Q2h1bmsoe1xuICAgICAgICAgICAgICAgICAgY29udHJvbGxlcixcbiAgICAgICAgICAgICAgICAgIGNodW5rOiB7XG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dC1kZWx0YVwiLFxuICAgICAgICAgICAgICAgICAgICB0ZXh0RGVsdGE6IGNodW5rQnVmZmVyXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2h1bmtCdWZmZXIgPSBcIlwiO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuMi5zZXRBdHRyaWJ1dGVzKFxuICAgICAgICAgICAgICAgICAgc2VsZWN0VGVsZW1ldHJ5QXR0cmlidXRlcyh7XG4gICAgICAgICAgICAgICAgICAgIHRlbGVtZXRyeSxcbiAgICAgICAgICAgICAgICAgICAgYXR0cmlidXRlczoge1xuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuZmluaXNoUmVhc29uXCI6IHN0ZXBGaW5pc2hSZWFzb24sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBzdGVwVGV4dCB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UubW9kZWxcIjogc3RlcFJlc3BvbnNlLm1vZGVsSWQsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50aW1lc3RhbXBcIjogc3RlcFJlc3BvbnNlLnRpbWVzdGFtcC50b0lTT1N0cmluZygpLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkudXNhZ2UucHJvbXB0VG9rZW5zXCI6IHN0ZXBVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IHN0ZXBVc2FnZS5jb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIGRlcHJlY2F0ZWRcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzdWx0LnRleHRcIjogeyBvdXRwdXQ6ICgpID0+IHN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXN1bHQudG9vbENhbGxzXCI6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG91dHB1dDogKCkgPT4gc3RlcFRvb2xDYWxsc0pzb25cbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIC8vIHN0YW5kYXJkaXplZCBnZW4tYWkgbGxtIHNwYW4gYXR0cmlidXRlczpcbiAgICAgICAgICAgICAgICAgICAgICBcImdlbl9haS5yZXNwb25zZS5maW5pc2hfcmVhc29uc1wiOiBbc3RlcEZpbmlzaFJlYXNvbl0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJnZW5fYWkucmVzcG9uc2UuaWRcIjogc3RlcFJlc3BvbnNlLmlkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnJlc3BvbnNlLm1vZGVsXCI6IHN0ZXBSZXNwb25zZS5tb2RlbElkLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLmlucHV0X3Rva2Vuc1wiOiBzdGVwVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgICAgICAgIFwiZ2VuX2FpLnVzYWdlLm91dHB1dF90b2tlbnNcIjogc3RlcFVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGRvU3RyZWFtU3BhbjIuZW5kKCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHtcbiAgICAgICAgICAgICAgICB0eXBlOiBcInN0ZXAtZmluaXNoXCIsXG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgIC4uLnN0ZXBSZXNwb25zZVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgaXNDb250aW51ZWQ6IG5leHRTdGVwVHlwZSA9PT0gXCJjb250aW51ZVwiXG4gICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICBpZiAoc3RlcFR5cGUgPT09IFwiY29udGludWVcIikge1xuICAgICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gcmVzcG9uc2VNZXNzYWdlc1tyZXNwb25zZU1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgbGFzdE1lc3NhZ2UuY29udGVudCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudCArPSBzdGVwVGV4dDtcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuY29udGVudC5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IFwidGV4dFwiXG4gICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlcy5wdXNoKFxuICAgICAgICAgICAgICAgICAgLi4udG9SZXNwb25zZU1lc3NhZ2VzKHtcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRvb2xzOiB0b29scyAhPSBudWxsID8gdG9vbHMgOiB7fSxcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgICAgICB0b29sUmVzdWx0czogc3RlcFRvb2xSZXN1bHRzXG4gICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgY29uc3QgY3VycmVudFN0ZXBSZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgc3RlcFR5cGUsXG4gICAgICAgICAgICAgICAgdGV4dDogc3RlcFRleHQsXG4gICAgICAgICAgICAgICAgdG9vbENhbGxzOiBzdGVwVG9vbENhbGxzLFxuICAgICAgICAgICAgICAgIHRvb2xSZXN1bHRzOiBzdGVwVG9vbFJlc3VsdHMsXG4gICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzdGVwVXNhZ2UsXG4gICAgICAgICAgICAgICAgd2FybmluZ3M6IHNlbGYud2FybmluZ3MsXG4gICAgICAgICAgICAgICAgbG9ncHJvYnM6IHN0ZXBMb2dQcm9icyxcbiAgICAgICAgICAgICAgICByZXF1ZXN0OiBzdGVwUmVxdWVzdCxcbiAgICAgICAgICAgICAgICByYXdSZXNwb25zZTogc2VsZi5yYXdSZXNwb25zZSxcbiAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlLFxuICAgICAgICAgICAgICAgICAgaGVhZGVyczogKF9hMTEgPSBzZWxmLnJhd1Jlc3BvbnNlKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgLy8gZGVlcCBjbG9uZSBtc2dzIHRvIGF2b2lkIG11dGF0aW5nIHBhc3QgbWVzc2FnZXMgaW4gbXVsdGktc3RlcDpcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJlc3BvbnNlTWVzc2FnZXMpKVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBuZXh0U3RlcFR5cGUgPT09IFwiY29udGludWVcIlxuICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICBzdGVwUmVzdWx0cy5wdXNoKGN1cnJlbnRTdGVwUmVzdWx0KTtcbiAgICAgICAgICAgICAgYXdhaXQgKG9uU3RlcEZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25TdGVwRmluaXNoKGN1cnJlbnRTdGVwUmVzdWx0KSk7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbWJpbmVkVXNhZ2UgPSB7XG4gICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiB1c2FnZS5wcm9tcHRUb2tlbnMgKyBzdGVwVXNhZ2UucHJvbXB0VG9rZW5zLFxuICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgKyBzdGVwVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICB0b3RhbFRva2VuczogdXNhZ2UudG90YWxUb2tlbnMgKyBzdGVwVXNhZ2UudG90YWxUb2tlbnNcbiAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgaWYgKG5leHRTdGVwVHlwZSAhPT0gXCJkb25lXCIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQsXG4gICAgICAgICAgICAgICAgICBkb1N0cmVhbVNwYW46IGRvU3RyZWFtU3BhbjMsXG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcE1zOiBzdGFydFRpbWVzdGFtcDJcbiAgICAgICAgICAgICAgICB9ID0gYXdhaXQgc3RhcnRTdGVwKHsgcmVzcG9uc2VNZXNzYWdlcyB9KTtcbiAgICAgICAgICAgICAgICBzZWxmLndhcm5pbmdzID0gcmVzdWx0Lndhcm5pbmdzO1xuICAgICAgICAgICAgICAgIHNlbGYucmF3UmVzcG9uc2UgPSByZXN1bHQucmF3UmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgYWRkU3RlcFN0cmVhbSh7XG4gICAgICAgICAgICAgICAgICBzdHJlYW06IHJlc3VsdC5zdHJlYW0sXG4gICAgICAgICAgICAgICAgICBzdGFydFRpbWVzdGFtcDogc3RhcnRUaW1lc3RhbXAyLFxuICAgICAgICAgICAgICAgICAgZG9TdHJlYW1TcGFuOiBkb1N0cmVhbVNwYW4zLFxuICAgICAgICAgICAgICAgICAgY3VycmVudFN0ZXA6IGN1cnJlbnRTdGVwICsgMSxcbiAgICAgICAgICAgICAgICAgIHJlc3BvbnNlTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIHN0ZXBUeXBlOiBuZXh0U3RlcFR5cGUsXG4gICAgICAgICAgICAgICAgICBwcmV2aW91c1N0ZXBUZXh0OiBmdWxsU3RlcFRleHQsXG4gICAgICAgICAgICAgICAgICBzdGVwUmVxdWVzdDogcmVzdWx0LnJlcXVlc3QsXG4gICAgICAgICAgICAgICAgICBoYXNMZWFkaW5nV2hpdGVzcGFjZTogaGFzV2hpdGVzcGFjZVN1ZmZpeFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh7XG4gICAgICAgICAgICAgICAgICB0eXBlOiBcImZpbmlzaFwiLFxuICAgICAgICAgICAgICAgICAgZmluaXNoUmVhc29uOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgdXNhZ2U6IGNvbWJpbmVkVXNhZ2UsXG4gICAgICAgICAgICAgICAgICBleHBlcmltZW50YWxfcHJvdmlkZXJNZXRhZGF0YTogc3RlcFByb3ZpZGVyTWV0YWRhdGEsXG4gICAgICAgICAgICAgICAgICBsb2dwcm9iczogc3RlcExvZ1Byb2JzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2U6IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uc3RlcFJlc3BvbnNlXG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgY2xvc2VTdGl0Y2hhYmxlU3RyZWFtKCk7XG4gICAgICAgICAgICAgICAgcm9vdFNwYW4uc2V0QXR0cmlidXRlcyhcbiAgICAgICAgICAgICAgICAgIHNlbGVjdFRlbGVtZXRyeUF0dHJpYnV0ZXMoe1xuICAgICAgICAgICAgICAgICAgICB0ZWxlbWV0cnksXG4gICAgICAgICAgICAgICAgICAgIGF0dHJpYnV0ZXM6IHtcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3BvbnNlLmZpbmlzaFJlYXNvblwiOiBzdGVwRmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgICAgICAgIFwiYWkucmVzcG9uc2UudGV4dFwiOiB7IG91dHB1dDogKCkgPT4gZnVsbFN0ZXBUZXh0IH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5yZXNwb25zZS50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5wcm9tcHRUb2tlbnNcIjogY29tYmluZWRVc2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS51c2FnZS5jb21wbGV0aW9uVG9rZW5zXCI6IGNvbWJpbmVkVXNhZ2UuY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICAgICAgICAgICAgICAvLyBkZXByZWNhdGVkXG4gICAgICAgICAgICAgICAgICAgICAgXCJhaS5maW5pc2hSZWFzb25cIjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50ZXh0XCI6IHsgb3V0cHV0OiAoKSA9PiBmdWxsU3RlcFRleHQgfSxcbiAgICAgICAgICAgICAgICAgICAgICBcImFpLnJlc3VsdC50b29sQ2FsbHNcIjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgb3V0cHV0OiAoKSA9PiBzdGVwVG9vbENhbGxzSnNvblxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIHJlc29sdmVVc2FnZShjb21iaW5lZFVzYWdlKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlRmluaXNoUmVhc29uKHN0ZXBGaW5pc2hSZWFzb24pO1xuICAgICAgICAgICAgICAgIHJlc29sdmVUZXh0KGZ1bGxTdGVwVGV4dCk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xDYWxscyhzdGVwVG9vbENhbGxzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUHJvdmlkZXJNZXRhZGF0YShzdGVwUHJvdmlkZXJNZXRhZGF0YSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVRvb2xSZXN1bHRzKHN0ZXBUb29sUmVzdWx0cyk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVJlcXVlc3Qoc3RlcFJlcXVlc3QpO1xuICAgICAgICAgICAgICAgIHJlc29sdmVSZXNwb25zZSh7XG4gICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICBoZWFkZXJzOiByYXdSZXNwb25zZSA9PSBudWxsID8gdm9pZCAwIDogcmF3UmVzcG9uc2UuaGVhZGVycyxcbiAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiByZXNwb25zZU1lc3NhZ2VzXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgcmVzb2x2ZVN0ZXBzKHN0ZXBSZXN1bHRzKTtcbiAgICAgICAgICAgICAgICByZXNvbHZlUmVzcG9uc2VNZXNzYWdlcyhyZXNwb25zZU1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBhd2FpdCAob25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHtcbiAgICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogc3RlcEZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICAgIGxvZ3Byb2JzOiBzdGVwTG9nUHJvYnMsXG4gICAgICAgICAgICAgICAgICB1c2FnZTogY29tYmluZWRVc2FnZSxcbiAgICAgICAgICAgICAgICAgIHRleHQ6IGZ1bGxTdGVwVGV4dCxcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsczogc3RlcFRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAgIC8vIFRoZSB0b29sIHJlc3VsdHMgYXJlIGluZmVycmVkIGFzIGEgbmV2ZXJbXSB0eXBlLCBiZWNhdXNlIHRoZXkgYXJlXG4gICAgICAgICAgICAgICAgICAvLyBvcHRpb25hbCBhbmQgdGhlIGV4ZWN1dGUgbWV0aG9kIHdpdGggYW4gaW5mZXJyZWQgcmVzdWx0IHR5cGUgaXNcbiAgICAgICAgICAgICAgICAgIC8vIG9wdGlvbmFsIGFzIHdlbGwuIFRoZXJlZm9yZSB3ZSBuZWVkIHRvIGNhc3QgdGhlIHRvb2xSZXN1bHRzIHRvIGFueS5cbiAgICAgICAgICAgICAgICAgIC8vIFRoZSB0eXBlIGV4cG9zZWQgdG8gdGhlIHVzZXJzIHdpbGwgYmUgY29ycmVjdGx5IGluZmVycmVkLlxuICAgICAgICAgICAgICAgICAgdG9vbFJlc3VsdHM6IHN0ZXBUb29sUmVzdWx0cyxcbiAgICAgICAgICAgICAgICAgIHJlcXVlc3Q6IHN0ZXBSZXF1ZXN0LFxuICAgICAgICAgICAgICAgICAgcmF3UmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICByZXNwb25zZToge1xuICAgICAgICAgICAgICAgICAgICAuLi5zdGVwUmVzcG9uc2UsXG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnM6IHJhd1Jlc3BvbnNlID09IG51bGwgPyB2b2lkIDAgOiByYXdSZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlczogcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHdhcm5pbmdzLFxuICAgICAgICAgICAgICAgICAgZXhwZXJpbWVudGFsX3Byb3ZpZGVyTWV0YWRhdGE6IHN0ZXBQcm92aWRlck1ldGFkYXRhLFxuICAgICAgICAgICAgICAgICAgc3RlcHM6IHN0ZXBSZXN1bHRzLFxuICAgICAgICAgICAgICAgICAgcmVzcG9uc2VNZXNzYWdlc1xuICAgICAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgICAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICByb290U3Bhbi5lbmQoKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgfVxuICAgIGFkZFN0ZXBTdHJlYW0oe1xuICAgICAgc3RyZWFtLFxuICAgICAgc3RhcnRUaW1lc3RhbXA6IHN0YXJ0VGltZXN0YW1wTXMsXG4gICAgICBkb1N0cmVhbVNwYW4sXG4gICAgICBjdXJyZW50U3RlcDogMCxcbiAgICAgIHJlc3BvbnNlTWVzc2FnZXM6IFtdLFxuICAgICAgdXNhZ2U6IHZvaWQgMCxcbiAgICAgIHN0ZXBUeXBlOiBcImluaXRpYWxcIixcbiAgICAgIHN0ZXBSZXF1ZXN0OiByZXF1ZXN0LFxuICAgICAgaGFzTGVhZGluZ1doaXRlc3BhY2U6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgLyoqXG4gIFNwbGl0IG91dCBhIG5ldyBzdHJlYW0gZnJvbSB0aGUgb3JpZ2luYWwgc3RyZWFtLlxuICBUaGUgb3JpZ2luYWwgc3RyZWFtIGlzIHJlcGxhY2VkIHRvIGFsbG93IGZvciBmdXJ0aGVyIHNwbGl0dGluZyxcbiAgc2luY2Ugd2UgZG8gbm90IGtub3cgaG93IG1hbnkgdGltZXMgdGhlIHN0cmVhbSB3aWxsIGJlIHNwbGl0LlxuICBcbiAgTm90ZTogdGhpcyBsZWFkcyB0byBidWZmZXJpbmcgdGhlIHN0cmVhbSBjb250ZW50IG9uIHRoZSBzZXJ2ZXIuXG4gIEhvd2V2ZXIsIHRoZSBMTE0gcmVzdWx0cyBhcmUgZXhwZWN0ZWQgdG8gYmUgc21hbGwgZW5vdWdoIHRvIG5vdCBjYXVzZSBpc3N1ZXMuXG4gICAgICovXG4gIHRlZVN0cmVhbSgpIHtcbiAgICBjb25zdCBbc3RyZWFtMSwgc3RyZWFtMl0gPSB0aGlzLm9yaWdpbmFsU3RyZWFtLnRlZSgpO1xuICAgIHRoaXMub3JpZ2luYWxTdHJlYW0gPSBzdHJlYW0yO1xuICAgIHJldHVybiBzdHJlYW0xO1xuICB9XG4gIGdldCB0ZXh0U3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmsudGV4dERlbHRhKTtcbiAgICAgICAgfSBlbHNlIGlmIChjaHVuay50eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKGNodW5rLmVycm9yKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGdldCBmdWxsU3RyZWFtKCkge1xuICAgIHJldHVybiBjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtKHRoaXMudGVlU3RyZWFtKCksIHtcbiAgICAgIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW0oY2FsbGJhY2tzID0ge30pIHtcbiAgICByZXR1cm4gdGhpcy50b0RhdGFTdHJlYW1JbnRlcm5hbCh7IGNhbGxiYWNrcyB9KTtcbiAgfVxuICB0b0RhdGFTdHJlYW1JbnRlcm5hbCh7XG4gICAgY2FsbGJhY2tzID0ge30sXG4gICAgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2UzID0gKCkgPT4gXCJcIixcbiAgICAvLyBtYXNrIGVycm9yIG1lc3NhZ2VzIGZvciBzYWZldHkgYnkgZGVmYXVsdFxuICAgIHNlbmRVc2FnZSA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgbGV0IGFnZ3JlZ2F0ZWRSZXNwb25zZSA9IFwiXCI7XG4gICAgY29uc3QgY2FsbGJhY2tUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgYXN5bmMgc3RhcnQoKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25TdGFydCgpO1xuICAgICAgfSxcbiAgICAgIGFzeW5jIHRyYW5zZm9ybShjaHVuaywgY29udHJvbGxlcikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoY2h1bmspO1xuICAgICAgICBpZiAoY2h1bmsudHlwZSA9PT0gXCJ0ZXh0LWRlbHRhXCIpIHtcbiAgICAgICAgICBjb25zdCB0ZXh0RGVsdGEgPSBjaHVuay50ZXh0RGVsdGE7XG4gICAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IHRleHREZWx0YTtcbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLm9uVG9rZW4pXG4gICAgICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Ub2tlbih0ZXh0RGVsdGEpO1xuICAgICAgICAgIGlmIChjYWxsYmFja3Mub25UZXh0KVxuICAgICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVGV4dCh0ZXh0RGVsdGEpO1xuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICAgIGlmIChjYWxsYmFja3Mub25Db21wbGV0aW9uKVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkNvbXBsZXRpb24oYWdncmVnYXRlZFJlc3BvbnNlKTtcbiAgICAgICAgaWYgKGNhbGxiYWNrcy5vbkZpbmFsKVxuICAgICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgY29uc3Qgc3RyZWFtUGFydHNUcmFuc2Zvcm1lciA9IG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAoY2h1bmssIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgY29uc3QgY2h1bmtUeXBlID0gY2h1bmsudHlwZTtcbiAgICAgICAgc3dpdGNoIChjaHVua1R5cGUpIHtcbiAgICAgICAgICBjYXNlIFwidGV4dC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoZm9ybWF0U3RyZWFtUGFydChcInRleHRcIiwgY2h1bmsudGV4dERlbHRhKSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1zdHJlYW1pbmctc3RhcnRcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWVcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcInRvb2wtY2FsbC1kZWx0YVwiOiB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQoXCJ0b29sX2NhbGxfZGVsdGFcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgYXJnc1RleHREZWx0YTogY2h1bmsuYXJnc1RleHREZWx0YVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1jYWxsXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcInRvb2xfY2FsbFwiLCB7XG4gICAgICAgICAgICAgICAgdG9vbENhbGxJZDogY2h1bmsudG9vbENhbGxJZCxcbiAgICAgICAgICAgICAgICB0b29sTmFtZTogY2h1bmsudG9vbE5hbWUsXG4gICAgICAgICAgICAgICAgYXJnczogY2h1bmsuYXJnc1xuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwidG9vbC1yZXN1bHRcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwidG9vbF9yZXN1bHRcIiwge1xuICAgICAgICAgICAgICAgIHRvb2xDYWxsSWQ6IGNodW5rLnRvb2xDYWxsSWQsXG4gICAgICAgICAgICAgICAgcmVzdWx0OiBjaHVuay5yZXN1bHRcbiAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImVycm9yXCIsIGdldEVycm9yTWVzc2FnZTMoY2h1bmsuZXJyb3IpKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwic3RlcC1maW5pc2hcIjoge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0KFwiZmluaXNoX3N0ZXBcIiwge1xuICAgICAgICAgICAgICAgIGZpbmlzaFJlYXNvbjogY2h1bmsuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgICAgIHVzYWdlOiBzZW5kVXNhZ2UgPyB7XG4gICAgICAgICAgICAgICAgICBwcm9tcHRUb2tlbnM6IGNodW5rLnVzYWdlLnByb21wdFRva2VucyxcbiAgICAgICAgICAgICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IGNodW5rLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnNcbiAgICAgICAgICAgICAgICB9IDogdm9pZCAwLFxuICAgICAgICAgICAgICAgIGlzQ29udGludWVkOiBjaHVuay5pc0NvbnRpbnVlZFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZmluaXNoXCI6IHtcbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgZm9ybWF0U3RyZWFtUGFydChcImZpbmlzaF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICBmaW5pc2hSZWFzb246IGNodW5rLmZpbmlzaFJlYXNvbixcbiAgICAgICAgICAgICAgICB1c2FnZTogc2VuZFVzYWdlID8ge1xuICAgICAgICAgICAgICAgICAgcHJvbXB0VG9rZW5zOiBjaHVuay51c2FnZS5wcm9tcHRUb2tlbnMsXG4gICAgICAgICAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiBjaHVuay51c2FnZS5jb21wbGV0aW9uVG9rZW5zXG4gICAgICAgICAgICAgICAgfSA6IHZvaWQgMFxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBjaHVua1R5cGU7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gY2h1bmsgdHlwZTogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXMuZnVsbFN0cmVhbS5waXBlVGhyb3VnaChjYWxsYmFja1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChzdHJlYW1QYXJ0c1RyYW5zZm9ybWVyKS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSk7XG4gIH1cbiAgcGlwZUFJU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCkge1xuICAgIHJldHVybiB0aGlzLnBpcGVEYXRhU3RyZWFtVG9SZXNwb25zZShyZXNwb25zZSwgaW5pdCk7XG4gIH1cbiAgcGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBvcHRpb25zKSB7XG4gICAgY29uc3QgaW5pdCA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IFwiaW5pdFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmluaXQgOiB7XG4gICAgICBoZWFkZXJzOiBcImhlYWRlcnNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5oZWFkZXJzIDogdm9pZCAwLFxuICAgICAgc3RhdHVzOiBcInN0YXR1c1wiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1cyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1c1RleHQ6IFwic3RhdHVzVGV4dFwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnN0YXR1c1RleHQgOiB2b2lkIDBcbiAgICB9O1xuICAgIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImRhdGFcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5kYXRhIDogdm9pZCAwO1xuICAgIGNvbnN0IGdldEVycm9yTWVzc2FnZTMgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImdldEVycm9yTWVzc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLmdldEVycm9yTWVzc2FnZSA6IHZvaWQgMDtcbiAgICBjb25zdCBzZW5kVXNhZ2UgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcInNlbmRVc2FnZVwiIGluIG9wdGlvbnMgPyBvcHRpb25zLnNlbmRVc2FnZSA6IHZvaWQgMDtcbiAgICB3cml0ZVRvU2VydmVyUmVzcG9uc2Uoe1xuICAgICAgcmVzcG9uc2UsXG4gICAgICBzdGF0dXM6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzLFxuICAgICAgc3RhdHVzVGV4dDogaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXNUZXh0LFxuICAgICAgaGVhZGVyczogcHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMoaW5pdCwge1xuICAgICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgIH0pLFxuICAgICAgc3RyZWFtOiB0aGlzLnRvRGF0YVN0cmVhbSh7IGRhdGEsIGdldEVycm9yTWVzc2FnZTogZ2V0RXJyb3JNZXNzYWdlMywgc2VuZFVzYWdlIH0pXG4gICAgfSk7XG4gIH1cbiAgcGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlKHJlc3BvbnNlLCBpbml0KSB7XG4gICAgd3JpdGVUb1NlcnZlclJlc3BvbnNlKHtcbiAgICAgIHJlc3BvbnNlLFxuICAgICAgc3RhdHVzOiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cyxcbiAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgIGhlYWRlcnM6IHByZXBhcmVPdXRnb2luZ0h0dHBIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KSxcbiAgICAgIHN0cmVhbTogdGhpcy50ZXh0U3RyZWFtLnBpcGVUaHJvdWdoKG5ldyBUZXh0RW5jb2RlclN0cmVhbSgpKVxuICAgIH0pO1xuICB9XG4gIHRvQUlTdHJlYW1SZXNwb25zZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucyk7XG4gIH1cbiAgdG9EYXRhU3RyZWFtKG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHJlYW0gPSB0aGlzLnRvRGF0YVN0cmVhbUludGVybmFsKHtcbiAgICAgIGdldEVycm9yTWVzc2FnZTogb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UsXG4gICAgICBzZW5kVXNhZ2U6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuc2VuZFVzYWdlXG4gICAgfSk7XG4gICAgcmV0dXJuIChvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGEpID8gbWVyZ2VTdHJlYW1zKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGF0YS5zdHJlYW0sIHN0cmVhbSkgOiBzdHJlYW07XG4gIH1cbiAgdG9EYXRhU3RyZWFtUmVzcG9uc2Uob3B0aW9ucykge1xuICAgIHZhciBfYTExO1xuICAgIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBcImluaXRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5pbml0IDoge1xuICAgICAgaGVhZGVyczogXCJoZWFkZXJzXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuaGVhZGVycyA6IHZvaWQgMCxcbiAgICAgIHN0YXR1czogXCJzdGF0dXNcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXMgOiB2b2lkIDAsXG4gICAgICBzdGF0dXNUZXh0OiBcInN0YXR1c1RleHRcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zdGF0dXNUZXh0IDogdm9pZCAwXG4gICAgfTtcbiAgICBjb25zdCBkYXRhID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJkYXRhXCIgaW4gb3B0aW9ucyA/IG9wdGlvbnMuZGF0YSA6IHZvaWQgMDtcbiAgICBjb25zdCBnZXRFcnJvck1lc3NhZ2UzID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJnZXRFcnJvck1lc3NhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5nZXRFcnJvck1lc3NhZ2UgOiB2b2lkIDA7XG4gICAgY29uc3Qgc2VuZFVzYWdlID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogXCJzZW5kVXNhZ2VcIiBpbiBvcHRpb25zID8gb3B0aW9ucy5zZW5kVXNhZ2UgOiB2b2lkIDA7XG4gICAgcmV0dXJuIG5ldyBSZXNwb25zZShcbiAgICAgIHRoaXMudG9EYXRhU3RyZWFtKHsgZGF0YSwgZ2V0RXJyb3JNZXNzYWdlOiBnZXRFcnJvck1lc3NhZ2UzLCBzZW5kVXNhZ2UgfSksXG4gICAgICB7XG4gICAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICAgIHN0YXR1c1RleHQ6IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzVGV4dCxcbiAgICAgICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiLFxuICAgICAgICAgIGRhdGFTdHJlYW1WZXJzaW9uOiBcInYxXCJcbiAgICAgICAgfSlcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIHRvVGV4dFN0cmVhbVJlc3BvbnNlKGluaXQpIHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gbmV3IFJlc3BvbnNlKHRoaXMudGV4dFN0cmVhbS5waXBlVGhyb3VnaChuZXcgVGV4dEVuY29kZXJTdHJlYW0oKSksIHtcbiAgICAgIHN0YXR1czogKF9hMTEgPSBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1cykgIT0gbnVsbCA/IF9hMTEgOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xudmFyIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0ID0gc3RyZWFtVGV4dDtcblxuLy8gY29yZS9taWRkbGV3YXJlL3dyYXAtbGFuZ3VhZ2UtbW9kZWwudHNcbnZhciBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwgPSAoe1xuICBtb2RlbCxcbiAgbWlkZGxld2FyZTogeyB0cmFuc2Zvcm1QYXJhbXMsIHdyYXBHZW5lcmF0ZSwgd3JhcFN0cmVhbSB9LFxuICBtb2RlbElkLFxuICBwcm92aWRlcklkXG59KSA9PiB7XG4gIGFzeW5jIGZ1bmN0aW9uIGRvVHJhbnNmb3JtKHtcbiAgICBwYXJhbXMsXG4gICAgdHlwZVxuICB9KSB7XG4gICAgcmV0dXJuIHRyYW5zZm9ybVBhcmFtcyA/IGF3YWl0IHRyYW5zZm9ybVBhcmFtcyh7IHBhcmFtcywgdHlwZSB9KSA6IHBhcmFtcztcbiAgfVxuICByZXR1cm4ge1xuICAgIHNwZWNpZmljYXRpb25WZXJzaW9uOiBcInYxXCIsXG4gICAgcHJvdmlkZXI6IHByb3ZpZGVySWQgIT0gbnVsbCA/IHByb3ZpZGVySWQgOiBtb2RlbC5wcm92aWRlcixcbiAgICBtb2RlbElkOiBtb2RlbElkICE9IG51bGwgPyBtb2RlbElkIDogbW9kZWwubW9kZWxJZCxcbiAgICBkZWZhdWx0T2JqZWN0R2VuZXJhdGlvbk1vZGU6IG1vZGVsLmRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSxcbiAgICBzdXBwb3J0c0ltYWdlVXJsczogbW9kZWwuc3VwcG9ydHNJbWFnZVVybHMsXG4gICAgc3VwcG9ydHNVcmw6IG1vZGVsLnN1cHBvcnRzVXJsLFxuICAgIHN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHM6IG1vZGVsLnN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMsXG4gICAgYXN5bmMgZG9HZW5lcmF0ZShwYXJhbXMpIHtcbiAgICAgIGNvbnN0IHRyYW5zZm9ybWVkUGFyYW1zID0gYXdhaXQgZG9UcmFuc2Zvcm0oeyBwYXJhbXMsIHR5cGU6IFwiZ2VuZXJhdGVcIiB9KTtcbiAgICAgIGNvbnN0IGRvR2VuZXJhdGUgPSBhc3luYyAoKSA9PiBtb2RlbC5kb0dlbmVyYXRlKHRyYW5zZm9ybWVkUGFyYW1zKTtcbiAgICAgIHJldHVybiB3cmFwR2VuZXJhdGUgPyB3cmFwR2VuZXJhdGUoeyBkb0dlbmVyYXRlLCBwYXJhbXM6IHRyYW5zZm9ybWVkUGFyYW1zLCBtb2RlbCB9KSA6IGRvR2VuZXJhdGUoKTtcbiAgICB9LFxuICAgIGFzeW5jIGRvU3RyZWFtKHBhcmFtcykge1xuICAgICAgY29uc3QgdHJhbnNmb3JtZWRQYXJhbXMgPSBhd2FpdCBkb1RyYW5zZm9ybSh7IHBhcmFtcywgdHlwZTogXCJzdHJlYW1cIiB9KTtcbiAgICAgIGNvbnN0IGRvU3RyZWFtID0gYXN5bmMgKCkgPT4gbW9kZWwuZG9TdHJlYW0odHJhbnNmb3JtZWRQYXJhbXMpO1xuICAgICAgcmV0dXJuIHdyYXBTdHJlYW0gPyB3cmFwU3RyZWFtKHsgZG9TdHJlYW0sIHBhcmFtczogdHJhbnNmb3JtZWRQYXJhbXMsIG1vZGVsIH0pIDogZG9TdHJlYW0oKTtcbiAgICB9XG4gIH07XG59O1xuXG4vLyBjb3JlL3JlZ2lzdHJ5L2N1c3RvbS1wcm92aWRlci50c1xuaW1wb3J0IHsgTm9TdWNoTW9kZWxFcnJvciBhcyBOb1N1Y2hNb2RlbEVycm9yMiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBleHBlcmltZW50YWxfY3VzdG9tUHJvdmlkZXIoe1xuICBsYW5ndWFnZU1vZGVscyxcbiAgdGV4dEVtYmVkZGluZ01vZGVscyxcbiAgZmFsbGJhY2tQcm92aWRlclxufSkge1xuICByZXR1cm4ge1xuICAgIGxhbmd1YWdlTW9kZWwobW9kZWxJZCkge1xuICAgICAgaWYgKGxhbmd1YWdlTW9kZWxzICE9IG51bGwgJiYgbW9kZWxJZCBpbiBsYW5ndWFnZU1vZGVscykge1xuICAgICAgICByZXR1cm4gbGFuZ3VhZ2VNb2RlbHNbbW9kZWxJZF07XG4gICAgICB9XG4gICAgICBpZiAoZmFsbGJhY2tQcm92aWRlcikge1xuICAgICAgICByZXR1cm4gZmFsbGJhY2tQcm92aWRlci5sYW5ndWFnZU1vZGVsKG1vZGVsSWQpO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IE5vU3VjaE1vZGVsRXJyb3IyKHsgbW9kZWxJZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9LFxuICAgIHRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKSB7XG4gICAgICBpZiAodGV4dEVtYmVkZGluZ01vZGVscyAhPSBudWxsICYmIG1vZGVsSWQgaW4gdGV4dEVtYmVkZGluZ01vZGVscykge1xuICAgICAgICByZXR1cm4gdGV4dEVtYmVkZGluZ01vZGVsc1ttb2RlbElkXTtcbiAgICAgIH1cbiAgICAgIGlmIChmYWxsYmFja1Byb3ZpZGVyKSB7XG4gICAgICAgIHJldHVybiBmYWxsYmFja1Byb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbChtb2RlbElkKTtcbiAgICAgIH1cbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yMih7IG1vZGVsSWQsIG1vZGVsVHlwZTogXCJ0ZXh0RW1iZWRkaW5nTW9kZWxcIiB9KTtcbiAgICB9XG4gIH07XG59XG5cbi8vIGNvcmUvcmVnaXN0cnkvbm8tc3VjaC1wcm92aWRlci1lcnJvci50c1xuaW1wb3J0IHsgQUlTREtFcnJvciBhcyBBSVNES0Vycm9yMTEsIE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjMgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TdWNoUHJvdmlkZXJFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDEwID0gU3ltYm9sLmZvcihtYXJrZXIxMCk7XG52YXIgX2ExMDtcbnZhciBOb1N1Y2hQcm92aWRlckVycm9yID0gY2xhc3MgZXh0ZW5kcyBOb1N1Y2hNb2RlbEVycm9yMyB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBwcm92aWRlcklkLFxuICAgIGF2YWlsYWJsZVByb3ZpZGVycyxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggcHJvdmlkZXI6ICR7cHJvdmlkZXJJZH0gKGF2YWlsYWJsZSBwcm92aWRlcnM6ICR7YXZhaWxhYmxlUHJvdmlkZXJzLmpvaW4oKX0pYFxuICB9KSB7XG4gICAgc3VwZXIoeyBlcnJvck5hbWU6IG5hbWUxMCwgbW9kZWxJZCwgbW9kZWxUeXBlLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICAgIHRoaXMucHJvdmlkZXJJZCA9IHByb3ZpZGVySWQ7XG4gICAgdGhpcy5hdmFpbGFibGVQcm92aWRlcnMgPSBhdmFpbGFibGVQcm92aWRlcnM7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvcjExLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTApO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaFByb3ZpZGVyRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTAgJiYgdHlwZW9mIGVycm9yLnByb3ZpZGVySWQgPT09IFwic3RyaW5nXCIgJiYgQXJyYXkuaXNBcnJheShlcnJvci5hdmFpbGFibGVQcm92aWRlcnMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBtb2RlbElkOiB0aGlzLm1vZGVsSWQsXG4gICAgICBtb2RlbFR5cGU6IHRoaXMubW9kZWxUeXBlLFxuICAgICAgcHJvdmlkZXJJZDogdGhpcy5wcm92aWRlcklkLFxuICAgICAgYXZhaWxhYmxlUHJvdmlkZXJzOiB0aGlzLmF2YWlsYWJsZVByb3ZpZGVyc1xuICAgIH07XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIGNvcmUvcmVnaXN0cnkvcHJvdmlkZXItcmVnaXN0cnkudHNcbmltcG9ydCB7IE5vU3VjaE1vZGVsRXJyb3IgYXMgTm9TdWNoTW9kZWxFcnJvcjQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkocHJvdmlkZXJzKSB7XG4gIGNvbnN0IHJlZ2lzdHJ5ID0gbmV3IERlZmF1bHRQcm92aWRlclJlZ2lzdHJ5KCk7XG4gIGZvciAoY29uc3QgW2lkLCBwcm92aWRlcl0gb2YgT2JqZWN0LmVudHJpZXMocHJvdmlkZXJzKSkge1xuICAgIHJlZ2lzdHJ5LnJlZ2lzdGVyUHJvdmlkZXIoeyBpZCwgcHJvdmlkZXIgfSk7XG4gIH1cbiAgcmV0dXJuIHJlZ2lzdHJ5O1xufVxudmFyIGV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5ID0gZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnk7XG52YXIgRGVmYXVsdFByb3ZpZGVyUmVnaXN0cnkgPSBjbGFzcyB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMucHJvdmlkZXJzID0ge307XG4gIH1cbiAgcmVnaXN0ZXJQcm92aWRlcih7XG4gICAgaWQsXG4gICAgcHJvdmlkZXJcbiAgfSkge1xuICAgIHRoaXMucHJvdmlkZXJzW2lkXSA9IHByb3ZpZGVyO1xuICB9XG4gIGdldFByb3ZpZGVyKGlkKSB7XG4gICAgY29uc3QgcHJvdmlkZXIgPSB0aGlzLnByb3ZpZGVyc1tpZF07XG4gICAgaWYgKHByb3ZpZGVyID09IG51bGwpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hQcm92aWRlckVycm9yKHtcbiAgICAgICAgbW9kZWxJZDogaWQsXG4gICAgICAgIG1vZGVsVHlwZTogXCJsYW5ndWFnZU1vZGVsXCIsXG4gICAgICAgIHByb3ZpZGVySWQ6IGlkLFxuICAgICAgICBhdmFpbGFibGVQcm92aWRlcnM6IE9iamVjdC5rZXlzKHRoaXMucHJvdmlkZXJzKVxuICAgICAgfSk7XG4gICAgfVxuICAgIHJldHVybiBwcm92aWRlcjtcbiAgfVxuICBzcGxpdElkKGlkLCBtb2RlbFR5cGUpIHtcbiAgICBjb25zdCBpbmRleCA9IGlkLmluZGV4T2YoXCI6XCIpO1xuICAgIGlmIChpbmRleCA9PT0gLTEpIHtcbiAgICAgIHRocm93IG5ldyBOb1N1Y2hNb2RlbEVycm9yNCh7XG4gICAgICAgIG1vZGVsSWQ6IGlkLFxuICAgICAgICBtb2RlbFR5cGUsXG4gICAgICAgIG1lc3NhZ2U6IGBJbnZhbGlkICR7bW9kZWxUeXBlfSBpZCBmb3IgcmVnaXN0cnk6ICR7aWR9IChtdXN0IGJlIGluIHRoZSBmb3JtYXQgXCJwcm92aWRlcklkOm1vZGVsSWRcIilgXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIFtpZC5zbGljZSgwLCBpbmRleCksIGlkLnNsaWNlKGluZGV4ICsgMSldO1xuICB9XG4gIGxhbmd1YWdlTW9kZWwoaWQpIHtcbiAgICB2YXIgX2ExMSwgX2I7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcImxhbmd1YWdlTW9kZWxcIik7XG4gICAgY29uc3QgbW9kZWwgPSAoX2IgPSAoX2ExMSA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCkpLmxhbmd1YWdlTW9kZWwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5jYWxsKF9hMTEsIG1vZGVsSWQpO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoeyBtb2RlbElkOiBpZCwgbW9kZWxUeXBlOiBcImxhbmd1YWdlTW9kZWxcIiB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIHRleHRFbWJlZGRpbmdNb2RlbChpZCkge1xuICAgIHZhciBfYTExLCBfYiwgX2M7XG4gICAgY29uc3QgW3Byb3ZpZGVySWQsIG1vZGVsSWRdID0gdGhpcy5zcGxpdElkKGlkLCBcInRleHRFbWJlZGRpbmdNb2RlbFwiKTtcbiAgICBjb25zdCBwcm92aWRlciA9IHRoaXMuZ2V0UHJvdmlkZXIocHJvdmlkZXJJZCk7XG4gICAgY29uc3QgbW9kZWwgPSAoX2MgPSAoX2ExMSA9IHByb3ZpZGVyLnRleHRFbWJlZGRpbmdNb2RlbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChwcm92aWRlciwgbW9kZWxJZCkpICE9IG51bGwgPyBfYyA6IFwidGV4dEVtYmVkZGluZ1wiIGluIHByb3ZpZGVyID8gKF9iID0gcHJvdmlkZXIudGV4dEVtYmVkZGluZykgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNhbGwocHJvdmlkZXIsIG1vZGVsSWQpIDogdm9pZCAwO1xuICAgIGlmIChtb2RlbCA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBuZXcgTm9TdWNoTW9kZWxFcnJvcjQoe1xuICAgICAgICBtb2RlbElkOiBpZCxcbiAgICAgICAgbW9kZWxUeXBlOiBcInRleHRFbWJlZGRpbmdNb2RlbFwiXG4gICAgICB9KTtcbiAgICB9XG4gICAgcmV0dXJuIG1vZGVsO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgYHRleHRFbWJlZGRpbmdNb2RlbGAgaW5zdGVhZC5cbiAgICovXG4gIHRleHRFbWJlZGRpbmcoaWQpIHtcbiAgICByZXR1cm4gdGhpcy50ZXh0RW1iZWRkaW5nTW9kZWwoaWQpO1xuICB9XG59O1xuXG4vLyBjb3JlL3Rvb2wvdG9vbC50c1xuZnVuY3Rpb24gdG9vbCh0b29sMikge1xuICByZXR1cm4gdG9vbDI7XG59XG5cbi8vIGNvcmUvdXRpbC9jb3NpbmUtc2ltaWxhcml0eS50c1xuZnVuY3Rpb24gY29zaW5lU2ltaWxhcml0eSh2ZWN0b3IxLCB2ZWN0b3IyKSB7XG4gIGlmICh2ZWN0b3IxLmxlbmd0aCAhPT0gdmVjdG9yMi5sZW5ndGgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgVmVjdG9ycyBtdXN0IGhhdmUgdGhlIHNhbWUgbGVuZ3RoICh2ZWN0b3IxOiAke3ZlY3RvcjEubGVuZ3RofSBlbGVtZW50cywgdmVjdG9yMjogJHt2ZWN0b3IyLmxlbmd0aH0gZWxlbWVudHMpYFxuICAgICk7XG4gIH1cbiAgcmV0dXJuIGRvdFByb2R1Y3QodmVjdG9yMSwgdmVjdG9yMikgLyAobWFnbml0dWRlKHZlY3RvcjEpICogbWFnbml0dWRlKHZlY3RvcjIpKTtcbn1cbmZ1bmN0aW9uIGRvdFByb2R1Y3QodmVjdG9yMSwgdmVjdG9yMikge1xuICByZXR1cm4gdmVjdG9yMS5yZWR1Y2UoXG4gICAgKGFjY3VtdWxhdG9yLCB2YWx1ZSwgaW5kZXgpID0+IGFjY3VtdWxhdG9yICsgdmFsdWUgKiB2ZWN0b3IyW2luZGV4XSxcbiAgICAwXG4gICk7XG59XG5mdW5jdGlvbiBtYWduaXR1ZGUodmVjdG9yKSB7XG4gIHJldHVybiBNYXRoLnNxcnQoZG90UHJvZHVjdCh2ZWN0b3IsIHZlY3RvcikpO1xufVxuXG4vLyBzdHJlYW1zL2FpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlUGFyc2VyXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXJcIjtcbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSB7XG4gIGNvbnN0IHRleHREZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGxldCBldmVudFNvdXJjZVBhcnNlcjtcbiAgcmV0dXJuIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIGV2ZW50U291cmNlUGFyc2VyID0gY3JlYXRlUGFyc2VyKFxuICAgICAgICAoZXZlbnQpID0+IHtcbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQgJiYgZXZlbnQudHlwZSA9PT0gXCJldmVudFwiICYmIGV2ZW50LmRhdGEgPT09IFwiW0RPTkVdXCIgfHwgLy8gUmVwbGljYXRlIGRvZXNuJ3Qgc2VuZCBbRE9ORV0gYnV0IGRvZXMgc2VuZCBhICdkb25lJyBldmVudFxuICAgICAgICAgIC8vIEBzZWUgaHR0cHM6Ly9yZXBsaWNhdGUuY29tL2RvY3Mvc3RyZWFtaW5nXG4gICAgICAgICAgZXZlbnQuZXZlbnQgPT09IFwiZG9uZVwiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLnRlcm1pbmF0ZSgpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoXCJkYXRhXCIgaW4gZXZlbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IHBhcnNlZE1lc3NhZ2UgPSBjdXN0b21QYXJzZXIgPyBjdXN0b21QYXJzZXIoZXZlbnQuZGF0YSwge1xuICAgICAgICAgICAgICBldmVudDogZXZlbnQuZXZlbnRcbiAgICAgICAgICAgIH0pIDogZXZlbnQuZGF0YTtcbiAgICAgICAgICAgIGlmIChwYXJzZWRNZXNzYWdlKVxuICAgICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUocGFyc2VkTWVzc2FnZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApO1xuICAgIH0sXG4gICAgdHJhbnNmb3JtKGNodW5rKSB7XG4gICAgICBldmVudFNvdXJjZVBhcnNlci5mZWVkKHRleHREZWNvZGVyLmRlY29kZShjaHVuaykpO1xuICAgIH1cbiAgfSk7XG59XG5mdW5jdGlvbiBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikge1xuICBjb25zdCB0ZXh0RW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBsZXQgYWdncmVnYXRlZFJlc3BvbnNlID0gXCJcIjtcbiAgY29uc3QgY2FsbGJhY2tzID0gY2IgfHwge307XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgIGlmIChjYWxsYmFja3Mub25TdGFydClcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uU3RhcnQoKTtcbiAgICB9LFxuICAgIGFzeW5jIHRyYW5zZm9ybShtZXNzYWdlLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBjb250ZW50ID0gdHlwZW9mIG1lc3NhZ2UgPT09IFwic3RyaW5nXCIgPyBtZXNzYWdlIDogbWVzc2FnZS5jb250ZW50O1xuICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHRleHRFbmNvZGVyLmVuY29kZShjb250ZW50KSk7XG4gICAgICBhZ2dyZWdhdGVkUmVzcG9uc2UgKz0gY29udGVudDtcbiAgICAgIGlmIChjYWxsYmFja3Mub25Ub2tlbilcbiAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uVG9rZW4oY29udGVudCk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uVGV4dCAmJiB0eXBlb2YgbWVzc2FnZSA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25UZXh0KG1lc3NhZ2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgYXN5bmMgZmx1c2goKSB7XG4gICAgICBjb25zdCBpc09wZW5BSUNhbGxiYWNrcyA9IGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcyk7XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uQ29tcGxldGlvbikge1xuICAgICAgICBhd2FpdCBjYWxsYmFja3Mub25Db21wbGV0aW9uKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgIWlzT3BlbkFJQ2FsbGJhY2tzKSB7XG4gICAgICAgIGF3YWl0IGNhbGxiYWNrcy5vbkZpbmFsKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIGlzT2ZUeXBlT3BlbkFJU3RyZWFtQ2FsbGJhY2tzKGNhbGxiYWNrcykge1xuICByZXR1cm4gXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGxcIiBpbiBjYWxsYmFja3M7XG59XG5mdW5jdGlvbiB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpIHtcbiAgbGV0IGlzU3RyZWFtU3RhcnQgPSB0cnVlO1xuICByZXR1cm4gKHRleHQpID0+IHtcbiAgICBpZiAoaXNTdHJlYW1TdGFydCkge1xuICAgICAgdGV4dCA9IHRleHQudHJpbVN0YXJ0KCk7XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgaXNTdHJlYW1TdGFydCA9IGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmZ1bmN0aW9uIEFJU3RyZWFtKHJlc3BvbnNlLCBjdXN0b21QYXJzZXIsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgaWYgKHJlc3BvbnNlLmJvZHkpIHtcbiAgICAgIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gICAgICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAgICAgYXN5bmMgc3RhcnQoY29udHJvbGxlcikge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKCFkb25lKSB7XG4gICAgICAgICAgICBjb25zdCBlcnJvclRleHQgPSBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUodmFsdWUpO1xuICAgICAgICAgICAgY29udHJvbGxlci5lcnJvcihuZXcgRXJyb3IoYFJlc3BvbnNlIGVycm9yOiAke2Vycm9yVGV4dH1gKSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICAgIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVycm9yKG5ldyBFcnJvcihcIlJlc3BvbnNlIGVycm9yOiBObyByZXNwb25zZSBib2R5XCIpKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuICB9XG4gIGNvbnN0IHJlc3BvbnNlQm9keVN0cmVhbSA9IHJlc3BvbnNlLmJvZHkgfHwgY3JlYXRlRW1wdHlSZWFkYWJsZVN0cmVhbSgpO1xuICByZXR1cm4gcmVzcG9uc2VCb2R5U3RyZWFtLnBpcGVUaHJvdWdoKGNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIoY3VzdG9tUGFyc2VyKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSk7XG59XG5mdW5jdGlvbiBjcmVhdGVFbXB0eVJlYWRhYmxlU3RyZWFtKCkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoaXRlcmFibGUpIHtcbiAgbGV0IGl0ID0gaXRlcmFibGVbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgY29uc3QgeyBkb25lLCB2YWx1ZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpXG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKHZhbHVlKTtcbiAgICB9LFxuICAgIGFzeW5jIGNhbmNlbChyZWFzb24pIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgYXdhaXQgKChfYTExID0gaXQucmV0dXJuKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jYWxsKGl0LCByZWFzb24pKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbS1kYXRhLnRzXG5pbXBvcnQgeyBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQyIH0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcblxuLy8gdXRpbC9jb25zdGFudHMudHNcbnZhciBIQU5HSU5HX1NUUkVBTV9XQVJOSU5HX1RJTUVfTVMgPSAxNSAqIDFlMztcblxuLy8gc3RyZWFtcy9zdHJlYW0tZGF0YS50c1xudmFyIFN0cmVhbURhdGEyID0gY2xhc3Mge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICB0aGlzLmNvbnRyb2xsZXIgPSBudWxsO1xuICAgIHRoaXMuaXNDbG9zZWQgPSBmYWxzZTtcbiAgICB0aGlzLndhcm5pbmdUaW1lb3V0ID0gbnVsbDtcbiAgICBjb25zdCBzZWxmID0gdGhpcztcbiAgICB0aGlzLnN0cmVhbSA9IG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBzdGFydDogYXN5bmMgKGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgc2VsZi5jb250cm9sbGVyID0gY29udHJvbGxlcjtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSBcImRldmVsb3BtZW50XCIpIHtcbiAgICAgICAgICBzZWxmLndhcm5pbmdUaW1lb3V0ID0gc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiVGhlIGRhdGEgc3RyZWFtIGlzIGhhbmdpbmcuIERpZCB5b3UgZm9yZ2V0IHRvIGNsb3NlIGl0IHdpdGggYGRhdGEuY2xvc2UoKWA/XCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSwgSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHB1bGw6IChjb250cm9sbGVyKSA9PiB7XG4gICAgICB9LFxuICAgICAgY2FuY2VsOiAocmVhc29uKSA9PiB7XG4gICAgICAgIHRoaXMuaXNDbG9zZWQgPSB0cnVlO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGFzeW5jIGNsb3NlKCkge1xuICAgIGlmICh0aGlzLmlzQ2xvc2VkKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJEYXRhIFN0cmVhbSBoYXMgYWxyZWFkeSBiZWVuIGNsb3NlZC5cIik7XG4gICAgfVxuICAgIGlmICghdGhpcy5jb250cm9sbGVyKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJTdHJlYW0gY29udHJvbGxlciBpcyBub3QgaW5pdGlhbGl6ZWQuXCIpO1xuICAgIH1cbiAgICB0aGlzLmNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICB0aGlzLmlzQ2xvc2VkID0gdHJ1ZTtcbiAgICBpZiAodGhpcy53YXJuaW5nVGltZW91dCkge1xuICAgICAgY2xlYXJUaW1lb3V0KHRoaXMud2FybmluZ1RpbWVvdXQpO1xuICAgIH1cbiAgfVxuICBhcHBlbmQodmFsdWUpIHtcbiAgICBpZiAodGhpcy5pc0Nsb3NlZCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiRGF0YSBTdHJlYW0gaGFzIGFscmVhZHkgYmVlbiBjbG9zZWQuXCIpO1xuICAgIH1cbiAgICBpZiAoIXRoaXMuY29udHJvbGxlcikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiU3RyZWFtIGNvbnRyb2xsZXIgaXMgbm90IGluaXRpYWxpemVkLlwiKTtcbiAgICB9XG4gICAgdGhpcy5jb250cm9sbGVyLmVucXVldWUoXG4gICAgICB0aGlzLmVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQyKFwiZGF0YVwiLCBbdmFsdWVdKSlcbiAgICApO1xuICB9XG4gIGFwcGVuZE1lc3NhZ2VBbm5vdGF0aW9uKHZhbHVlKSB7XG4gICAgaWYgKHRoaXMuaXNDbG9zZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIkRhdGEgU3RyZWFtIGhhcyBhbHJlYWR5IGJlZW4gY2xvc2VkLlwiKTtcbiAgICB9XG4gICAgaWYgKCF0aGlzLmNvbnRyb2xsZXIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIlN0cmVhbSBjb250cm9sbGVyIGlzIG5vdCBpbml0aWFsaXplZC5cIik7XG4gICAgfVxuICAgIHRoaXMuY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgdGhpcy5lbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgW3ZhbHVlXSkpXG4gICAgKTtcbiAgfVxufTtcbmZ1bmN0aW9uIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpIHtcbiAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIHJldHVybiBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICB0cmFuc2Zvcm06IGFzeW5jIChjaHVuaywgY29udHJvbGxlcikgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZSA9IGRlY29kZXIuZGVjb2RlKGNodW5rKTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShlbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MihcInRleHRcIiwgbWVzc2FnZSkpKTtcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9TdHJlYW1EYXRhID0gY2xhc3MgZXh0ZW5kcyBTdHJlYW1EYXRhMiB7XG59O1xuXG4vLyBzdHJlYW1zL2FudGhyb3BpYy1zdHJlYW0udHNcbmZ1bmN0aW9uIHBhcnNlQW50aHJvcGljU3RyZWFtKCkge1xuICBsZXQgcHJldmlvdXMgPSBcIlwiO1xuICByZXR1cm4gKGRhdGEpID0+IHtcbiAgICBjb25zdCBqc29uID0gSlNPTi5wYXJzZShkYXRhKTtcbiAgICBpZiAoXCJlcnJvclwiIGluIGpzb24pIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgJHtqc29uLmVycm9yLnR5cGV9OiAke2pzb24uZXJyb3IubWVzc2FnZX1gKTtcbiAgICB9XG4gICAgaWYgKCEoXCJjb21wbGV0aW9uXCIgaW4ganNvbikpIHtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IGpzb24uY29tcGxldGlvbjtcbiAgICBpZiAoIXByZXZpb3VzIHx8IHRleHQubGVuZ3RoID4gcHJldmlvdXMubGVuZ3RoICYmIHRleHQuc3RhcnRzV2l0aChwcmV2aW91cykpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gdGV4dC5zbGljZShwcmV2aW91cy5sZW5ndGgpO1xuICAgICAgcHJldmlvdXMgPSB0ZXh0O1xuICAgICAgcmV0dXJuIGRlbHRhO1xuICAgIH1cbiAgICByZXR1cm4gdGV4dDtcbiAgfTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcImNvbXBsZXRpb25cIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgdGV4dCA9IGNodW5rLmNvbXBsZXRpb247XG4gICAgICBpZiAodGV4dClcbiAgICAgICAgeWllbGQgdGV4dDtcbiAgICB9IGVsc2UgaWYgKFwiZGVsdGFcIiBpbiBjaHVuaykge1xuICAgICAgY29uc3QgeyBkZWx0YSB9ID0gY2h1bms7XG4gICAgICBpZiAoXCJ0ZXh0XCIgaW4gZGVsdGEpIHtcbiAgICAgICAgY29uc3QgdGV4dCA9IGRlbHRhLnRleHQ7XG4gICAgICAgIGlmICh0ZXh0KVxuICAgICAgICAgIHlpZWxkIHRleHQ7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBbnRocm9waWNTdHJlYW0ocmVzLCBjYikge1xuICBpZiAoU3ltYm9sLmFzeW5jSXRlcmF0b3IgaW4gcmVzKSB7XG4gICAgcmV0dXJuIHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZShyZXMpKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYikpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gQUlTdHJlYW0ocmVzLCBwYXJzZUFudGhyb3BpY1N0cmVhbSgpLCBjYikucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKVxuICAgICk7XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9hc3Npc3RhbnQtcmVzcG9uc2UudHNcbmltcG9ydCB7XG4gIGZvcm1hdFN0cmVhbVBhcnQgYXMgZm9ybWF0U3RyZWFtUGFydDNcbn0gZnJvbSBcIkBhaS1zZGsvdWktdXRpbHNcIjtcbmZ1bmN0aW9uIEFzc2lzdGFudFJlc3BvbnNlKHsgdGhyZWFkSWQsIG1lc3NhZ2VJZCB9LCBwcm9jZXNzMikge1xuICBjb25zdCBzdHJlYW0gPSBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHN0YXJ0KGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgICAgIGNvbnN0IHNlbmRNZXNzYWdlID0gKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9tZXNzYWdlXCIsIG1lc3NhZ2UpKVxuICAgICAgICApO1xuICAgICAgfTtcbiAgICAgIGNvbnN0IHNlbmREYXRhTWVzc2FnZSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoZm9ybWF0U3RyZWFtUGFydDMoXCJkYXRhX21lc3NhZ2VcIiwgbWVzc2FnZSkpXG4gICAgICAgICk7XG4gICAgICB9O1xuICAgICAgY29uc3Qgc2VuZEVycm9yID0gKGVycm9yTWVzc2FnZSkgPT4ge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQzKFwiZXJyb3JcIiwgZXJyb3JNZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgIH07XG4gICAgICBjb25zdCBmb3J3YXJkU3RyZWFtID0gYXN5bmMgKHN0cmVhbTIpID0+IHtcbiAgICAgICAgdmFyIF9hMTIsIF9iO1xuICAgICAgICBsZXQgcmVzdWx0ID0gdm9pZCAwO1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHZhbHVlIG9mIHN0cmVhbTIpIHtcbiAgICAgICAgICBzd2l0Y2ggKHZhbHVlLmV2ZW50KSB7XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLm1lc3NhZ2UuY3JlYXRlZFwiOiB7XG4gICAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgICAgICAgICB0ZXh0RW5jb2Rlci5lbmNvZGUoXG4gICAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcImFzc2lzdGFudF9tZXNzYWdlXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmRhdGEuaWQsXG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFt7IHR5cGU6IFwidGV4dFwiLCB0ZXh0OiB7IHZhbHVlOiBcIlwiIH0gfV1cbiAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQubWVzc2FnZS5kZWx0YVwiOiB7XG4gICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSAoX2ExMiA9IHZhbHVlLmRhdGEuZGVsdGEuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTJbMF07XG4gICAgICAgICAgICAgIGlmICgoY29udGVudCA9PSBudWxsID8gdm9pZCAwIDogY29udGVudC50eXBlKSA9PT0gXCJ0ZXh0XCIgJiYgKChfYiA9IGNvbnRlbnQudGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLnZhbHVlKSAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0MyhcInRleHRcIiwgY29udGVudC50ZXh0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlIFwidGhyZWFkLnJ1bi5jb21wbGV0ZWRcIjpcbiAgICAgICAgICAgIGNhc2UgXCJ0aHJlYWQucnVuLnJlcXVpcmVzX2FjdGlvblwiOiB7XG4gICAgICAgICAgICAgIHJlc3VsdCA9IHZhbHVlLmRhdGE7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfTtcbiAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZShcbiAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKFxuICAgICAgICAgIGZvcm1hdFN0cmVhbVBhcnQzKFwiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiLCB7XG4gICAgICAgICAgICB0aHJlYWRJZCxcbiAgICAgICAgICAgIG1lc3NhZ2VJZFxuICAgICAgICAgIH0pXG4gICAgICAgIClcbiAgICAgICk7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBwcm9jZXNzMih7XG4gICAgICAgICAgdGhyZWFkSWQsXG4gICAgICAgICAgbWVzc2FnZUlkLFxuICAgICAgICAgIHNlbmRNZXNzYWdlLFxuICAgICAgICAgIHNlbmREYXRhTWVzc2FnZSxcbiAgICAgICAgICBmb3J3YXJkU3RyZWFtXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgc2VuZEVycm9yKChfYTExID0gZXJyb3IubWVzc2FnZSkgIT0gbnVsbCA/IF9hMTEgOiBgJHtlcnJvcn1gKTtcbiAgICAgIH0gZmluYWxseSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIHB1bGwoY29udHJvbGxlcikge1xuICAgIH0sXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBuZXcgUmVzcG9uc2Uoc3RyZWFtLCB7XG4gICAgc3RhdHVzOiAyMDAsXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCJcbiAgICB9XG4gIH0pO1xufVxudmFyIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSA9IEFzc2lzdGFudFJlc3BvbnNlO1xuXG4vLyBzdHJlYW1zL2F3cy1iZWRyb2NrLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaykge1xuICB2YXIgX2ExMSwgX2I7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiAoX2ExMSA9IHJlc3BvbnNlLmJvZHkpICE9IG51bGwgPyBfYTExIDogW10pIHtcbiAgICBjb25zdCBieXRlcyA9IChfYiA9IGNodW5rLmNodW5rKSA9PSBudWxsID8gdm9pZCAwIDogX2IuYnl0ZXM7XG4gICAgaWYgKGJ5dGVzICE9IG51bGwpIHtcbiAgICAgIGNvbnN0IGNodW5rVGV4dCA9IGRlY29kZXIuZGVjb2RlKGJ5dGVzKTtcbiAgICAgIGNvbnN0IGNodW5rSlNPTiA9IEpTT04ucGFyc2UoY2h1bmtUZXh0KTtcbiAgICAgIGNvbnN0IGRlbHRhID0gZXh0cmFjdFRleHREZWx0YUZyb21DaHVuayhjaHVua0pTT04pO1xuICAgICAgaWYgKGRlbHRhICE9IG51bGwpIHtcbiAgICAgICAgeWllbGQgZGVsdGE7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljTWVzc2FnZXNTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IHtcbiAgICB2YXIgX2ExMTtcbiAgICByZXR1cm4gKF9hMTEgPSBjaHVuay5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEudGV4dDtcbiAgfSk7XG59XG5mdW5jdGlvbiBBV1NCZWRyb2NrQW50aHJvcGljU3RyZWFtKHJlc3BvbnNlLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIEFXU0JlZHJvY2tTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcywgKGNodW5rKSA9PiBjaHVuay5jb21wbGV0aW9uKTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tDb2hlcmVTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rID09IG51bGwgPyB2b2lkIDAgOiBjaHVuay50ZXh0KTtcbn1cbmZ1bmN0aW9uIEFXU0JlZHJvY2tMbGFtYTJTdHJlYW0ocmVzcG9uc2UsIGNhbGxiYWNrcykge1xuICByZXR1cm4gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCAoY2h1bmspID0+IGNodW5rLmdlbmVyYXRpb24pO1xufVxuZnVuY3Rpb24gQVdTQmVkcm9ja1N0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzLCBleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKFxuICAgIGFzRGVsdGFJdGVyYWJsZShyZXNwb25zZSwgZXh0cmFjdFRleHREZWx0YUZyb21DaHVuaylcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvY29oZXJlLXN0cmVhbS50c1xudmFyIHV0ZjhEZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKFwidXRmLThcIik7XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzTGluZXMobGluZXMsIGNvbnRyb2xsZXIpIHtcbiAgZm9yIChjb25zdCBsaW5lIG9mIGxpbmVzKSB7XG4gICAgY29uc3QgeyB0ZXh0LCBpc19maW5pc2hlZCB9ID0gSlNPTi5wYXJzZShsaW5lKTtcbiAgICBpZiAoIWlzX2ZpbmlzaGVkKSB7XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9XG59XG5hc3luYyBmdW5jdGlvbiByZWFkQW5kUHJvY2Vzc0xpbmVzKHJlYWRlciwgY29udHJvbGxlcikge1xuICBsZXQgc2VnbWVudCA9IFwiXCI7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZTogY2h1bmssIGRvbmUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKGRvbmUpIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBzZWdtZW50ICs9IHV0ZjhEZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IHNlZ21lbnQuc3BsaXQoL1xcclxcbnxcXG58XFxyL2cpO1xuICAgIHNlZ21lbnQgPSBsaW5lc0FycmF5LnBvcCgpIHx8IFwiXCI7XG4gICAgYXdhaXQgcHJvY2Vzc0xpbmVzKGxpbmVzQXJyYXksIGNvbnRyb2xsZXIpO1xuICB9XG4gIGlmIChzZWdtZW50KSB7XG4gICAgY29uc3QgbGluZXNBcnJheSA9IFtzZWdtZW50XTtcbiAgICBhd2FpdCBwcm9jZXNzTGluZXMobGluZXNBcnJheSwgY29udHJvbGxlcik7XG4gIH1cbiAgY29udHJvbGxlci5jbG9zZSgpO1xufVxuZnVuY3Rpb24gY3JlYXRlUGFyc2VyMihyZXMpIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHJlYWRlciA9IChfYTExID0gcmVzLmJvZHkpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmdldFJlYWRlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBzdGFydChjb250cm9sbGVyKSB7XG4gICAgICBpZiAoIXJlYWRlcikge1xuICAgICAgICBjb250cm9sbGVyLmNsb3NlKCk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGF3YWl0IHJlYWRBbmRQcm9jZXNzTGluZXMocmVhZGVyLCBjb250cm9sbGVyKTtcbiAgICB9XG4gIH0pO1xufVxuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUyKHN0cmVhbSkge1xuICBmb3IgYXdhaXQgKGNvbnN0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChjaHVuay5ldmVudFR5cGUgPT09IFwidGV4dC1nZW5lcmF0aW9uXCIpIHtcbiAgICAgIGNvbnN0IHRleHQgPSBjaHVuay50ZXh0O1xuICAgICAgaWYgKHRleHQpXG4gICAgICAgIHlpZWxkIHRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBDb2hlcmVTdHJlYW0ocmVhZGVyLCBjYWxsYmFja3MpIHtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlYWRlcikge1xuICAgIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUyKHJlYWRlcikpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gY3JlYXRlUGFyc2VyMihyZWFkZXIpLnBpcGVUaHJvdWdoKGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyKGNhbGxiYWNrcykpLnBpcGVUaHJvdWdoKGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpKTtcbiAgfVxufVxuXG4vLyBzdHJlYW1zL2dvb2dsZS1nZW5lcmF0aXZlLWFpLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24qIHN0cmVhbWFibGUzKHJlc3BvbnNlKSB7XG4gIHZhciBfYTExLCBfYiwgX2M7XG4gIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgcmVzcG9uc2Uuc3RyZWFtKSB7XG4gICAgY29uc3QgcGFydHMgPSAoX2MgPSAoX2IgPSAoX2ExMSA9IGNodW5rLmNhbmRpZGF0ZXMpID09IG51bGwgPyB2b2lkIDAgOiBfYTExWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2IuY29udGVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9jLnBhcnRzO1xuICAgIGlmIChwYXJ0cyA9PT0gdm9pZCAwKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgY29uc3QgZmlyc3RQYXJ0ID0gcGFydHNbMF07XG4gICAgaWYgKHR5cGVvZiBmaXJzdFBhcnQudGV4dCA9PT0gXCJzdHJpbmdcIikge1xuICAgICAgeWllbGQgZmlyc3RQYXJ0LnRleHQ7XG4gICAgfVxuICB9XG59XG5mdW5jdGlvbiBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0ocmVzcG9uc2UsIGNiKSB7XG4gIHJldHVybiByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlKHN0cmVhbWFibGUzKHJlc3BvbnNlKSkucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2IpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvaHVnZ2luZ2ZhY2Utc3RyZWFtLnRzXG5mdW5jdGlvbiBjcmVhdGVQYXJzZXIzKHJlcykge1xuICBjb25zdCB0cmltU3RhcnRPZlN0cmVhbSA9IHRyaW1TdGFydE9mU3RyZWFtSGVscGVyKCk7XG4gIHJldHVybiBuZXcgUmVhZGFibGVTdHJlYW0oe1xuICAgIGFzeW5jIHB1bGwoY29udHJvbGxlcikge1xuICAgICAgdmFyIF9hMTEsIF9iO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgcmVzLm5leHQoKTtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKChfYiA9IChfYTExID0gdmFsdWUudG9rZW4pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLnRleHQpICE9IG51bGwgPyBfYiA6IFwiXCIpO1xuICAgICAgaWYgKCF0ZXh0KVxuICAgICAgICByZXR1cm47XG4gICAgICBpZiAodmFsdWUuZ2VuZXJhdGVkX3RleHQgIT0gbnVsbCAmJiB2YWx1ZS5nZW5lcmF0ZWRfdGV4dC5sZW5ndGggPiAwKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGlmICh0ZXh0ID09PSBcIjwvcz5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kb2Z0ZXh0fD5cIiB8fCB0ZXh0ID09PSBcIjx8ZW5kfD5cIikge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb250cm9sbGVyLmVucXVldWUodGV4dCk7XG4gICAgfVxuICB9KTtcbn1cbmZ1bmN0aW9uIEh1Z2dpbmdGYWNlU3RyZWFtKHJlcywgY2FsbGJhY2tzKSB7XG4gIHJldHVybiBjcmVhdGVQYXJzZXIzKHJlcykucGlwZVRocm91Z2goY3JlYXRlQ2FsbGJhY2tzVHJhbnNmb3JtZXIoY2FsbGJhY2tzKSkucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xufVxuXG4vLyBzdHJlYW1zL2lua2VlcC1zdHJlYW0udHNcbmZ1bmN0aW9uIElua2VlcFN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiUmVzcG9uc2UgYm9keSBpcyBudWxsXCIpO1xuICB9XG4gIGxldCBjaGF0X3Nlc3Npb25faWQgPSBcIlwiO1xuICBsZXQgcmVjb3Jkc19jaXRlZDtcbiAgY29uc3QgaW5rZWVwRXZlbnRQYXJzZXIgPSAoZGF0YSwgb3B0aW9ucykgPT4ge1xuICAgIHZhciBfYTExLCBfYjtcbiAgICBjb25zdCB7IGV2ZW50IH0gPSBvcHRpb25zO1xuICAgIGlmIChldmVudCA9PT0gXCJyZWNvcmRzX2NpdGVkXCIpIHtcbiAgICAgIHJlY29yZHNfY2l0ZWQgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgKF9hMTEgPSBjYWxsYmFja3MgPT0gbnVsbCA/IHZvaWQgMCA6IGNhbGxiYWNrcy5vblJlY29yZHNDaXRlZCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChjYWxsYmFja3MsIHJlY29yZHNfY2l0ZWQpO1xuICAgIH1cbiAgICBpZiAoZXZlbnQgPT09IFwibWVzc2FnZV9jaHVua1wiKSB7XG4gICAgICBjb25zdCBpbmtlZXBNZXNzYWdlQ2h1bmsgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgY2hhdF9zZXNzaW9uX2lkID0gKF9iID0gaW5rZWVwTWVzc2FnZUNodW5rLmNoYXRfc2Vzc2lvbl9pZCkgIT0gbnVsbCA/IF9iIDogY2hhdF9zZXNzaW9uX2lkO1xuICAgICAgcmV0dXJuIGlua2VlcE1lc3NhZ2VDaHVuay5jb250ZW50X2NodW5rO1xuICAgIH1cbiAgICByZXR1cm47XG4gIH07XG4gIGxldCB7IG9uUmVjb3Jkc0NpdGVkLCAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyB9ID0gY2FsbGJhY2tzIHx8IHt9O1xuICBwYXNzVGhyb3VnaENhbGxiYWNrcyA9IHtcbiAgICAuLi5wYXNzVGhyb3VnaENhbGxiYWNrcyxcbiAgICBvbkZpbmFsOiAoY29tcGxldGlvbikgPT4ge1xuICAgICAgdmFyIF9hMTE7XG4gICAgICBjb25zdCBpbmtlZXBPbkZpbmFsTWV0YWRhdGEgPSB7XG4gICAgICAgIGNoYXRfc2Vzc2lvbl9pZCxcbiAgICAgICAgcmVjb3Jkc19jaXRlZFxuICAgICAgfTtcbiAgICAgIChfYTExID0gY2FsbGJhY2tzID09IG51bGwgPyB2b2lkIDAgOiBjYWxsYmFja3Mub25GaW5hbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY2FsbChjYWxsYmFja3MsIGNvbXBsZXRpb24sIGlua2VlcE9uRmluYWxNZXRhZGF0YSk7XG4gICAgfVxuICB9O1xuICByZXR1cm4gQUlTdHJlYW0ocmVzLCBpbmtlZXBFdmVudFBhcnNlciwgcGFzc1Rocm91Z2hDYWxsYmFja3MpLnBpcGVUaHJvdWdoKFxuICAgIGNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lcigpXG4gICk7XG59XG5cbi8vIHN0cmVhbXMvbGFuZ2NoYWluLWFkYXB0ZXIudHNcbnZhciBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzID0ge307XG5fX2V4cG9ydChsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzLCB7XG4gIHRvQUlTdHJlYW06ICgpID0+IHRvQUlTdHJlYW0sXG4gIHRvRGF0YVN0cmVhbTogKCkgPT4gdG9EYXRhU3RyZWFtLFxuICB0b0RhdGFTdHJlYW1SZXNwb25zZTogKCkgPT4gdG9EYXRhU3RyZWFtUmVzcG9uc2Vcbn0pO1xuZnVuY3Rpb24gdG9BSVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gdG9EYXRhU3RyZWFtKHN0cmVhbSwgY2FsbGJhY2tzKTtcbn1cbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbShzdHJlYW0sIGNhbGxiYWNrcykge1xuICByZXR1cm4gc3RyZWFtLnBpcGVUaHJvdWdoKFxuICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgdHJhbnNmb3JtOiBhc3luYyAodmFsdWUsIGNvbnRyb2xsZXIpID0+IHtcbiAgICAgICAgdmFyIF9hMTE7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoXCJldmVudFwiIGluIHZhbHVlKSB7XG4gICAgICAgICAgaWYgKHZhbHVlLmV2ZW50ID09PSBcIm9uX2NoYXRfbW9kZWxfc3RyZWFtXCIpIHtcbiAgICAgICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayhcbiAgICAgICAgICAgICAgKF9hMTEgPSB2YWx1ZS5kYXRhKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5jaHVuayxcbiAgICAgICAgICAgICAgY29udHJvbGxlclxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGZvcndhcmRBSU1lc3NhZ2VDaHVuayh2YWx1ZSwgY29udHJvbGxlcik7XG4gICAgICB9XG4gICAgfSlcbiAgKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZShzdHJlYW0sIG9wdGlvbnMpIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IGRhdGFTdHJlYW0gPSB0b0RhdGFTdHJlYW0oc3RyZWFtLCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNhbGxiYWNrcyk7XG4gIGNvbnN0IGRhdGEgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmRhdGE7XG4gIGNvbnN0IGluaXQgPSBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmluaXQ7XG4gIGNvbnN0IHJlc3BvbnNlU3RyZWFtID0gZGF0YSA/IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgZGF0YVN0cmVhbSkgOiBkYXRhU3RyZWFtO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlU3RyZWFtLCB7XG4gICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiBmb3J3YXJkQUlNZXNzYWdlQ2h1bmsoY2h1bmssIGNvbnRyb2xsZXIpIHtcbiAgaWYgKHR5cGVvZiBjaHVuay5jb250ZW50ID09PSBcInN0cmluZ1wiKSB7XG4gICAgY29udHJvbGxlci5lbnF1ZXVlKGNodW5rLmNvbnRlbnQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IGNvbnRlbnQgPSBjaHVuay5jb250ZW50O1xuICAgIGZvciAoY29uc3QgaXRlbSBvZiBjb250ZW50KSB7XG4gICAgICBpZiAoaXRlbS50eXBlID09PSBcInRleHRcIikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoaXRlbS50ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLy8gc3RyZWFtcy9sbGFtYWluZGV4LWFkYXB0ZXIudHNcbnZhciBsbGFtYWluZGV4X2FkYXB0ZXJfZXhwb3J0cyA9IHt9O1xuX19leHBvcnQobGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMsIHtcbiAgdG9EYXRhU3RyZWFtOiAoKSA9PiB0b0RhdGFTdHJlYW0yLFxuICB0b0RhdGFTdHJlYW1SZXNwb25zZTogKCkgPT4gdG9EYXRhU3RyZWFtUmVzcG9uc2UyXG59KTtcbmZ1bmN0aW9uIHRvRGF0YVN0cmVhbTIoc3RyZWFtLCBjYWxsYmFja3MpIHtcbiAgcmV0dXJuIHRvUmVhZGFibGVTdHJlYW0oc3RyZWFtKS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5mdW5jdGlvbiB0b0RhdGFTdHJlYW1SZXNwb25zZTIoc3RyZWFtLCBvcHRpb25zID0ge30pIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHsgaW5pdCwgZGF0YSwgY2FsbGJhY2tzIH0gPSBvcHRpb25zO1xuICBjb25zdCBkYXRhU3RyZWFtID0gdG9EYXRhU3RyZWFtMihzdHJlYW0sIGNhbGxiYWNrcyk7XG4gIGNvbnN0IHJlc3BvbnNlU3RyZWFtID0gZGF0YSA/IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgZGF0YVN0cmVhbSkgOiBkYXRhU3RyZWFtO1xuICByZXR1cm4gbmV3IFJlc3BvbnNlKHJlc3BvbnNlU3RyZWFtLCB7XG4gICAgc3RhdHVzOiAoX2ExMSA9IGluaXQgPT0gbnVsbCA/IHZvaWQgMCA6IGluaXQuc3RhdHVzKSAhPSBudWxsID8gX2ExMSA6IDIwMCxcbiAgICBzdGF0dXNUZXh0OiBpbml0ID09IG51bGwgPyB2b2lkIDAgOiBpbml0LnN0YXR1c1RleHQsXG4gICAgaGVhZGVyczogcHJlcGFyZVJlc3BvbnNlSGVhZGVycyhpbml0LCB7XG4gICAgICBjb250ZW50VHlwZTogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgICBkYXRhU3RyZWFtVmVyc2lvbjogXCJ2MVwiXG4gICAgfSlcbiAgfSk7XG59XG5mdW5jdGlvbiB0b1JlYWRhYmxlU3RyZWFtKHJlcykge1xuICBjb25zdCBpdCA9IHJlc1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHZhciBfYTExO1xuICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXQubmV4dCgpO1xuICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjb25zdCB0ZXh0ID0gdHJpbVN0YXJ0T2ZTdHJlYW0oKF9hMTEgPSB2YWx1ZS5kZWx0YSkgIT0gbnVsbCA/IF9hMTEgOiBcIlwiKTtcbiAgICAgIGlmICh0ZXh0KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh0ZXh0KTtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xufVxuXG4vLyBzdHJlYW1zL2xhbmdjaGFpbi1zdHJlYW0udHNcbmZ1bmN0aW9uIExhbmdDaGFpblN0cmVhbShjYWxsYmFja3MpIHtcbiAgY29uc3Qgc3RyZWFtID0gbmV3IFRyYW5zZm9ybVN0cmVhbSgpO1xuICBjb25zdCB3cml0ZXIgPSBzdHJlYW0ud3JpdGFibGUuZ2V0V3JpdGVyKCk7XG4gIGNvbnN0IHJ1bnMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpO1xuICBjb25zdCBoYW5kbGVFcnJvciA9IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgIHJ1bnMuZGVsZXRlKHJ1bklkKTtcbiAgICBhd2FpdCB3cml0ZXIucmVhZHk7XG4gICAgYXdhaXQgd3JpdGVyLmFib3J0KGUpO1xuICB9O1xuICBjb25zdCBoYW5kbGVTdGFydCA9IGFzeW5jIChydW5JZCkgPT4ge1xuICAgIHJ1bnMuYWRkKHJ1bklkKTtcbiAgfTtcbiAgY29uc3QgaGFuZGxlRW5kID0gYXN5bmMgKHJ1bklkKSA9PiB7XG4gICAgcnVucy5kZWxldGUocnVuSWQpO1xuICAgIGlmIChydW5zLnNpemUgPT09IDApIHtcbiAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgIGF3YWl0IHdyaXRlci5jbG9zZSgpO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBzdHJlYW06IHN0cmVhbS5yZWFkYWJsZS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSksXG4gICAgd3JpdGVyLFxuICAgIGhhbmRsZXJzOiB7XG4gICAgICBoYW5kbGVMTE1OZXdUb2tlbjogYXN5bmMgKHRva2VuKSA9PiB7XG4gICAgICAgIGF3YWl0IHdyaXRlci5yZWFkeTtcbiAgICAgICAgYXdhaXQgd3JpdGVyLndyaXRlKHRva2VuKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1TdGFydDogYXN5bmMgKF9sbG0sIF9wcm9tcHRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlTExNRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVMTE1FcnJvcjogYXN5bmMgKGUsIHJ1bklkKSA9PiB7XG4gICAgICAgIGF3YWl0IGhhbmRsZUVycm9yKGUsIHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpblN0YXJ0OiBhc3luYyAoX2NoYWluLCBfaW5wdXRzLCBydW5JZCkgPT4ge1xuICAgICAgICBoYW5kbGVTdGFydChydW5JZCk7XG4gICAgICB9LFxuICAgICAgaGFuZGxlQ2hhaW5FbmQ6IGFzeW5jIChfb3V0cHV0cywgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVDaGFpbkVycm9yOiBhc3luYyAoZSwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRXJyb3IoZSwgcnVuSWQpO1xuICAgICAgfSxcbiAgICAgIGhhbmRsZVRvb2xTdGFydDogYXN5bmMgKF90b29sLCBfaW5wdXQsIHJ1bklkKSA9PiB7XG4gICAgICAgIGhhbmRsZVN0YXJ0KHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRW5kOiBhc3luYyAoX291dHB1dCwgcnVuSWQpID0+IHtcbiAgICAgICAgYXdhaXQgaGFuZGxlRW5kKHJ1bklkKTtcbiAgICAgIH0sXG4gICAgICBoYW5kbGVUb29sRXJyb3I6IGFzeW5jIChlLCBydW5JZCkgPT4ge1xuICAgICAgICBhd2FpdCBoYW5kbGVFcnJvcihlLCBydW5JZCk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG4vLyBzdHJlYW1zL21pc3RyYWwtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiogc3RyZWFtYWJsZTQoc3RyZWFtKSB7XG4gIHZhciBfYTExLCBfYjtcbiAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBzdHJlYW0pIHtcbiAgICBjb25zdCBjb250ZW50ID0gKF9iID0gKF9hMTEgPSBjaHVuay5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX2ExMS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9iLmNvbnRlbnQ7XG4gICAgaWYgKGNvbnRlbnQgPT09IHZvaWQgMCB8fCBjb250ZW50ID09PSBcIlwiKSB7XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgeWllbGQgY29udGVudDtcbiAgfVxufVxuZnVuY3Rpb24gTWlzdHJhbFN0cmVhbShyZXNwb25zZSwgY2FsbGJhY2tzKSB7XG4gIGNvbnN0IHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTQocmVzcG9uc2UpKTtcbiAgcmV0dXJuIHN0cmVhbS5waXBlVGhyb3VnaChjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihjYWxsYmFja3MpKS5waXBlVGhyb3VnaChjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIoKSk7XG59XG5cbi8vIHN0cmVhbXMvb3BlbmFpLXN0cmVhbS50c1xuaW1wb3J0IHtcbiAgY3JlYXRlQ2h1bmtEZWNvZGVyLFxuICBmb3JtYXRTdHJlYW1QYXJ0IGFzIGZvcm1hdFN0cmVhbVBhcnQ0XG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5mdW5jdGlvbiBwYXJzZU9wZW5BSVN0cmVhbSgpIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIHJldHVybiAoZGF0YSkgPT4gZXh0cmFjdChKU09OLnBhcnNlKGRhdGEpKTtcbn1cbmFzeW5jIGZ1bmN0aW9uKiBzdHJlYW1hYmxlNShzdHJlYW0pIHtcbiAgY29uc3QgZXh0cmFjdCA9IGNodW5rVG9UZXh0KCk7XG4gIGZvciBhd2FpdCAobGV0IGNodW5rIG9mIHN0cmVhbSkge1xuICAgIGlmIChcInByb21wdEZpbHRlclJlc3VsdHNcIiBpbiBjaHVuaykge1xuICAgICAgY2h1bmsgPSB7XG4gICAgICAgIGlkOiBjaHVuay5pZCxcbiAgICAgICAgY3JlYXRlZDogY2h1bmsuY3JlYXRlZC5nZXREYXRlKCksXG4gICAgICAgIG9iamVjdDogY2h1bmsub2JqZWN0LFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgbW9kZWw6IGNodW5rLm1vZGVsLFxuICAgICAgICAvLyBub3QgZXhwb3NlZCBieSBBenVyZSBBUElcbiAgICAgICAgY2hvaWNlczogY2h1bmsuY2hvaWNlcy5tYXAoKGNob2ljZSkgPT4ge1xuICAgICAgICAgIHZhciBfYTExLCBfYiwgX2MsIF9kLCBfZSwgX2YsIF9nO1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBkZWx0YToge1xuICAgICAgICAgICAgICBjb250ZW50OiAoX2ExMSA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hMTEuY29udGVudCxcbiAgICAgICAgICAgICAgZnVuY3Rpb25fY2FsbDogKF9iID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2IuZnVuY3Rpb25DYWxsLFxuICAgICAgICAgICAgICByb2xlOiAoX2MgPSBjaG9pY2UuZGVsdGEpID09IG51bGwgPyB2b2lkIDAgOiBfYy5yb2xlLFxuICAgICAgICAgICAgICB0b29sX2NhbGxzOiAoKF9lID0gKF9kID0gY2hvaWNlLmRlbHRhKSA9PSBudWxsID8gdm9pZCAwIDogX2QudG9vbENhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2UubGVuZ3RoKSA/IChfZyA9IChfZiA9IGNob2ljZS5kZWx0YSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9mLnRvb2xDYWxscykgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm1hcCgodG9vbENhbGwsIGluZGV4KSA9PiAoe1xuICAgICAgICAgICAgICAgIGluZGV4LFxuICAgICAgICAgICAgICAgIGlkOiB0b29sQ2FsbC5pZCxcbiAgICAgICAgICAgICAgICBmdW5jdGlvbjogdG9vbENhbGwuZnVuY3Rpb24sXG4gICAgICAgICAgICAgICAgdHlwZTogdG9vbENhbGwudHlwZVxuICAgICAgICAgICAgICB9KSkgOiB2b2lkIDBcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaW5pc2hfcmVhc29uOiBjaG9pY2UuZmluaXNoUmVhc29uLFxuICAgICAgICAgICAgaW5kZXg6IGNob2ljZS5pbmRleFxuICAgICAgICAgIH07XG4gICAgICAgIH0pXG4gICAgICB9O1xuICAgIH1cbiAgICBjb25zdCB0ZXh0ID0gZXh0cmFjdChjaHVuayk7XG4gICAgaWYgKHRleHQpXG4gICAgICB5aWVsZCB0ZXh0O1xuICB9XG59XG5mdW5jdGlvbiBjaHVua1RvVGV4dCgpIHtcbiAgY29uc3QgdHJpbVN0YXJ0T2ZTdHJlYW0gPSB0cmltU3RhcnRPZlN0cmVhbUhlbHBlcigpO1xuICBsZXQgaXNGdW5jdGlvblN0cmVhbWluZ0luO1xuICByZXR1cm4gKGpzb24pID0+IHtcbiAgICB2YXIgX2ExMSwgX2IsIF9jLCBfZCwgX2UsIF9mLCBfZywgX2gsIF9pLCBfaiwgX2ssIF9sLCBfbSwgX24sIF9vLCBfcCwgX3EsIF9yO1xuICAgIGlmIChpc0NoYXRDb21wbGV0aW9uQ2h1bmsoanNvbikpIHtcbiAgICAgIGNvbnN0IGRlbHRhID0gKF9hMTEgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfYTExLmRlbHRhO1xuICAgICAgaWYgKChfYiA9IGRlbHRhLmZ1bmN0aW9uX2NhbGwpID09IG51bGwgPyB2b2lkIDAgOiBfYi5uYW1lKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IHRydWU7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICBjb250ZW50OiBge1wiZnVuY3Rpb25fY2FsbFwiOiB7XCJuYW1lXCI6IFwiJHtkZWx0YS5mdW5jdGlvbl9jYWxsLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2UgPSAoX2QgPSAoX2MgPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2NbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfZC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9lLm5hbWUpIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgdG9vbENhbGwgPSBkZWx0YS50b29sX2NhbGxzWzBdO1xuICAgICAgICBpZiAodG9vbENhbGwuaW5kZXggPT09IDApIHtcbiAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXNUZXh0OiBmYWxzZSxcbiAgICAgICAgICAgIGNvbnRlbnQ6IGB7XCJ0b29sX2NhbGxzXCI6WyB7XCJpZFwiOiBcIiR7dG9vbENhbGwuaWR9XCIsIFwidHlwZVwiOiBcImZ1bmN0aW9uXCIsIFwiZnVuY3Rpb25cIjoge1wibmFtZVwiOiBcIiR7KF9mID0gdG9vbENhbGwuZnVuY3Rpb24pID09IG51bGwgPyB2b2lkIDAgOiBfZi5uYW1lfVwiLCBcImFyZ3VtZW50c1wiOiBcImBcbiAgICAgICAgICB9O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpc1RleHQ6IGZhbHNlLFxuICAgICAgICAgICAgY29udGVudDogYFwifX0sIHtcImlkXCI6IFwiJHt0b29sQ2FsbC5pZH1cIiwgXCJ0eXBlXCI6IFwiZnVuY3Rpb25cIiwgXCJmdW5jdGlvblwiOiB7XCJuYW1lXCI6IFwiJHsoX2cgPSB0b29sQ2FsbC5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9nLm5hbWV9XCIsIFwiYXJndW1lbnRzXCI6IFwiYFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoKF9oID0gZGVsdGEuZnVuY3Rpb25fY2FsbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9oLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX2kgPSBkZWx0YS5mdW5jdGlvbl9jYWxsKSA9PSBudWxsID8gdm9pZCAwIDogX2kuYXJndW1lbnRzKVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIGlmICgoX2wgPSAoX2sgPSAoX2ogPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX2pbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfay5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9sLmFyZ3VtZW50cykge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogY2xlYW51cEFyZ3VtZW50cygoX28gPSAoX24gPSAoX20gPSBkZWx0YS50b29sX2NhbGxzKSA9PSBudWxsID8gdm9pZCAwIDogX21bMF0pID09IG51bGwgPyB2b2lkIDAgOiBfbi5mdW5jdGlvbikgPT0gbnVsbCA/IHZvaWQgMCA6IF9vLmFyZ3VtZW50cylcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSBpZiAoaXNGdW5jdGlvblN0cmVhbWluZ0luICYmICgoKF9wID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3AuZmluaXNoX3JlYXNvbikgPT09IFwiZnVuY3Rpb25fY2FsbFwiIHx8ICgoX3EgPSBqc29uLmNob2ljZXNbMF0pID09IG51bGwgPyB2b2lkIDAgOiBfcS5maW5pc2hfcmVhc29uKSA9PT0gXCJzdG9wXCIpKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX0nXG4gICAgICAgIH07XG4gICAgICB9IGVsc2UgaWYgKGlzRnVuY3Rpb25TdHJlYW1pbmdJbiAmJiAoKF9yID0ganNvbi5jaG9pY2VzWzBdKSA9PSBudWxsID8gdm9pZCAwIDogX3IuZmluaXNoX3JlYXNvbikgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIGlzVGV4dDogZmFsc2UsXG4gICAgICAgICAgY29udGVudDogJ1wifX1dfSdcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgdGV4dCA9IHRyaW1TdGFydE9mU3RyZWFtKFxuICAgICAgaXNDaGF0Q29tcGxldGlvbkNodW5rKGpzb24pICYmIGpzb24uY2hvaWNlc1swXS5kZWx0YS5jb250ZW50ID8ganNvbi5jaG9pY2VzWzBdLmRlbHRhLmNvbnRlbnQgOiBpc0NvbXBsZXRpb24oanNvbikgPyBqc29uLmNob2ljZXNbMF0udGV4dCA6IFwiXCJcbiAgICApO1xuICAgIHJldHVybiB0ZXh0O1xuICB9O1xuICBmdW5jdGlvbiBjbGVhbnVwQXJndW1lbnRzKGFyZ3VtZW50Q2h1bmspIHtcbiAgICBsZXQgZXNjYXBlZFBhcnRpYWxKc29uID0gYXJndW1lbnRDaHVuay5yZXBsYWNlKC9cXFxcL2csIFwiXFxcXFxcXFxcIikucmVwbGFjZSgvXFwvL2csIFwiXFxcXC9cIikucmVwbGFjZSgvXCIvZywgJ1xcXFxcIicpLnJlcGxhY2UoL1xcbi9nLCBcIlxcXFxuXCIpLnJlcGxhY2UoL1xcci9nLCBcIlxcXFxyXCIpLnJlcGxhY2UoL1xcdC9nLCBcIlxcXFx0XCIpLnJlcGxhY2UoL1xcZi9nLCBcIlxcXFxmXCIpO1xuICAgIHJldHVybiBgJHtlc2NhcGVkUGFydGlhbEpzb259YDtcbiAgfVxufVxudmFyIF9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wgPSBTeW1ib2woXG4gIFwiaW50ZXJuYWxfb3BlbmFpX2ZuX21lc3NhZ2VzXCJcbik7XG5mdW5jdGlvbiBpc0NoYXRDb21wbGV0aW9uQ2h1bmsoZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwiZGVsdGFcIiBpbiBkYXRhLmNob2ljZXNbMF07XG59XG5mdW5jdGlvbiBpc0NvbXBsZXRpb24oZGF0YSkge1xuICByZXR1cm4gXCJjaG9pY2VzXCIgaW4gZGF0YSAmJiBkYXRhLmNob2ljZXMgJiYgZGF0YS5jaG9pY2VzWzBdICYmIFwidGV4dFwiIGluIGRhdGEuY2hvaWNlc1swXTtcbn1cbmZ1bmN0aW9uIE9wZW5BSVN0cmVhbShyZXMsIGNhbGxiYWNrcykge1xuICBjb25zdCBjYiA9IGNhbGxiYWNrcztcbiAgbGV0IHN0cmVhbTtcbiAgaWYgKFN5bWJvbC5hc3luY0l0ZXJhdG9yIGluIHJlcykge1xuICAgIHN0cmVhbSA9IHJlYWRhYmxlRnJvbUFzeW5jSXRlcmFibGUoc3RyZWFtYWJsZTUocmVzKSkucGlwZVRocm91Z2goXG4gICAgICBjcmVhdGVDYWxsYmFja3NUcmFuc2Zvcm1lcihcbiAgICAgICAgKGNiID09IG51bGwgPyB2b2lkIDAgOiBjYi5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHx8IChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uVG9vbENhbGwpID8ge1xuICAgICAgICAgIC4uLmNiLFxuICAgICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgICB9IDoge1xuICAgICAgICAgIC4uLmNiXG4gICAgICAgIH1cbiAgICAgIClcbiAgICApO1xuICB9IGVsc2Uge1xuICAgIHN0cmVhbSA9IEFJU3RyZWFtKFxuICAgICAgcmVzLFxuICAgICAgcGFyc2VPcGVuQUlTdHJlYW0oKSxcbiAgICAgIChjYiA9PSBudWxsID8gdm9pZCAwIDogY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB8fCAoY2IgPT0gbnVsbCA/IHZvaWQgMCA6IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSA/IHtcbiAgICAgICAgLi4uY2IsXG4gICAgICAgIG9uRmluYWw6IHZvaWQgMFxuICAgICAgfSA6IHtcbiAgICAgICAgLi4uY2JcbiAgICAgIH1cbiAgICApO1xuICB9XG4gIGlmIChjYiAmJiAoY2IuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHx8IGNiLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyID0gY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIoY2IpO1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goZnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIpO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBzdHJlYW0ucGlwZVRocm91Z2goY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKCkpO1xuICB9XG59XG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbkNhbGxUcmFuc2Zvcm1lcihjYWxsYmFja3MpIHtcbiAgY29uc3QgdGV4dEVuY29kZXIgPSBuZXcgVGV4dEVuY29kZXIoKTtcbiAgbGV0IGlzRmlyc3RDaHVuayA9IHRydWU7XG4gIGxldCBhZ2dyZWdhdGVkUmVzcG9uc2UgPSBcIlwiO1xuICBsZXQgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gXCJcIjtcbiAgbGV0IGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZXMgPSBjYWxsYmFja3NbX19pbnRlcm5hbF9fT3BlbkFJRm5NZXNzYWdlc1N5bWJvbF0gfHwgW107XG4gIGNvbnN0IGRlY29kZSA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICByZXR1cm4gbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgYXN5bmMgdHJhbnNmb3JtKGNodW5rLCBjb250cm9sbGVyKSB7XG4gICAgICBjb25zdCBtZXNzYWdlID0gZGVjb2RlKGNodW5rKTtcbiAgICAgIGFnZ3JlZ2F0ZWRGaW5hbENvbXBsZXRpb25SZXNwb25zZSArPSBtZXNzYWdlO1xuICAgICAgY29uc3Qgc2hvdWxkSGFuZGxlQXNGdW5jdGlvbiA9IGlzRmlyc3RDaHVuayAmJiAobWVzc2FnZS5zdGFydHNXaXRoKCd7XCJmdW5jdGlvbl9jYWxsXCI6JykgfHwgbWVzc2FnZS5zdGFydHNXaXRoKCd7XCJ0b29sX2NhbGxzXCI6JykpO1xuICAgICAgaWYgKHNob3VsZEhhbmRsZUFzRnVuY3Rpb24pIHtcbiAgICAgICAgaXNGdW5jdGlvblN0cmVhbWluZ0luID0gdHJ1ZTtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICAgIGlzRmlyc3RDaHVuayA9IGZhbHNlO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoIWlzRnVuY3Rpb25TdHJlYW1pbmdJbikge1xuICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgdGV4dEVuY29kZXIuZW5jb2RlKGZvcm1hdFN0cmVhbVBhcnQ0KFwidGV4dFwiLCBtZXNzYWdlKSlcbiAgICAgICAgKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYWdncmVnYXRlZFJlc3BvbnNlICs9IG1lc3NhZ2U7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyBmbHVzaChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBpZiAoIWlzRmlyc3RDaHVuayAmJiBpc0Z1bmN0aW9uU3RyZWFtaW5nSW4gJiYgKGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgfHwgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSkge1xuICAgICAgICAgIGlzRnVuY3Rpb25TdHJlYW1pbmdJbiA9IGZhbHNlO1xuICAgICAgICAgIGNvbnN0IHBheWxvYWQgPSBKU09OLnBhcnNlKGFnZ3JlZ2F0ZWRSZXNwb25zZSk7XG4gICAgICAgICAgbGV0IG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICBdO1xuICAgICAgICAgIGxldCBmdW5jdGlvblJlc3BvbnNlID0gdm9pZCAwO1xuICAgICAgICAgIGlmIChjYWxsYmFja3MuZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKSB7XG4gICAgICAgICAgICBpZiAocGF5bG9hZC5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGFyZ3VtZW50c1BheWxvYWQgPSBKU09OLnBhcnNlKFxuICAgICAgICAgICAgICBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgZnVuY3Rpb25SZXNwb25zZSA9IGF3YWl0IGNhbGxiYWNrcy5leHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwoXG4gICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICBhcmd1bWVudHM6IGFyZ3VtZW50c1BheWxvYWRcbiAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgKHJlc3VsdCkgPT4ge1xuICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgLi4uZnVuY3Rpb25DYWxsTWVzc2FnZXMsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgIGZ1bmN0aW9uX2NhbGw6IHBheWxvYWQuZnVuY3Rpb25fY2FsbFxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICBuYW1lOiBwYXlsb2FkLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkocmVzdWx0KVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgcmV0dXJuIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSB7XG4gICAgICAgICAgICAgIHRvb2xzOiBbXVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbDIgb2YgcGF5bG9hZC50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIHRvb2xDYWxscy50b29scy5wdXNoKHtcbiAgICAgICAgICAgICAgICBpZDogdG9vbDIuaWQsXG4gICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgIGZ1bmM6IHtcbiAgICAgICAgICAgICAgICAgIG5hbWU6IHRvb2wyLmZ1bmN0aW9uLm5hbWUsXG4gICAgICAgICAgICAgICAgICBhcmd1bWVudHM6IEpTT04ucGFyc2UodG9vbDIuZnVuY3Rpb24uYXJndW1lbnRzKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsZXQgcmVzcG9uc2VJbmRleCA9IDA7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBmdW5jdGlvblJlc3BvbnNlID0gYXdhaXQgY2FsbGJhY2tzLmV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKFxuICAgICAgICAgICAgICAgIHRvb2xDYWxscyxcbiAgICAgICAgICAgICAgICAocmVzdWx0KSA9PiB7XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdG9vbF9jYWxsX2lkLCBmdW5jdGlvbl9uYW1lLCB0b29sX2NhbGxfcmVzdWx0IH0gPSByZXN1bHQ7XG4gICAgICAgICAgICAgICAgICAgIG5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzID0gW1xuICAgICAgICAgICAgICAgICAgICAgIC4uLm5ld0Z1bmN0aW9uQ2FsbE1lc3NhZ2VzLFxuICAgICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgYXBwZW5kIHRoZSBhc3Npc3RhbnQgbWVzc2FnZSBpZiBpdCdzIHRoZSBmaXJzdCByZXNwb25zZVxuICAgICAgICAgICAgICAgICAgICAgIC4uLnJlc3BvbnNlSW5kZXggPT09IDAgPyBbXG4gICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHRvb2xfY2FsbHM6IHBheWxvYWQudG9vbF9jYWxscy5tYXAoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgKHRjKSA9PiAoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWQ6IHRjLmlkLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdHlwZTogXCJmdW5jdGlvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZnVuY3Rpb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmFtZTogdGMuZnVuY3Rpb24ubmFtZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2Ugc2VuZCB0aGUgYXJndW1lbnRzIGFuIG9iamVjdCB0byB0aGUgdXNlciwgYnV0IGFzIHRoZSBBUEkgZXhwZWN0cyBhIHN0cmluZywgd2UgbmVlZCB0byBzdHJpbmdpZnkgaXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXJndW1lbnRzOiBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0Yy5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBdIDogW10sXG4gICAgICAgICAgICAgICAgICAgICAgLy8gQXBwZW5kIHRoZSBmdW5jdGlvbiBjYWxsIHJlc3VsdCBtZXNzYWdlXG4gICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgcm9sZTogXCJ0b29sXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICB0b29sX2NhbGxfaWQsXG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBmdW5jdGlvbl9uYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkodG9vbF9jYWxsX3Jlc3VsdClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF07XG4gICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlSW5kZXgrKztcbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIHJldHVybiBuZXdGdW5jdGlvbkNhbGxNZXNzYWdlcztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvciBjYWxsaW5nIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsOlwiLCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKCFmdW5jdGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShcbiAgICAgICAgICAgICAgICBmb3JtYXRTdHJlYW1QYXJ0NChcbiAgICAgICAgICAgICAgICAgIHBheWxvYWQuZnVuY3Rpb25fY2FsbCA/IFwiZnVuY3Rpb25fY2FsbFwiIDogXCJ0b29sX2NhbGxzXCIsXG4gICAgICAgICAgICAgICAgICAvLyBwYXJzZSB0byBwcmV2ZW50IGRvdWJsZS1lbmNvZGluZzpcbiAgICAgICAgICAgICAgICAgIEpTT04ucGFyc2UoYWdncmVnYXRlZFJlc3BvbnNlKVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9IGVsc2UgaWYgKHR5cGVvZiBmdW5jdGlvblJlc3BvbnNlID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHRleHRFbmNvZGVyLmVuY29kZShmb3JtYXRTdHJlYW1QYXJ0NChcInRleHRcIiwgZnVuY3Rpb25SZXNwb25zZSkpXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlID0gZnVuY3Rpb25SZXNwb25zZTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgZmlsdGVyZWRDYWxsYmFja3MgPSB7XG4gICAgICAgICAgICAuLi5jYWxsYmFja3MsXG4gICAgICAgICAgICBvblN0YXJ0OiB2b2lkIDBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGNhbGxiYWNrcy5vbkZpbmFsID0gdm9pZCAwO1xuICAgICAgICAgIGNvbnN0IG9wZW5BSVN0cmVhbSA9IE9wZW5BSVN0cmVhbShmdW5jdGlvblJlc3BvbnNlLCB7XG4gICAgICAgICAgICAuLi5maWx0ZXJlZENhbGxiYWNrcyxcbiAgICAgICAgICAgIFtfX2ludGVybmFsX19PcGVuQUlGbk1lc3NhZ2VzU3ltYm9sXTogbmV3RnVuY3Rpb25DYWxsTWVzc2FnZXNcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBjb25zdCByZWFkZXIgPSBvcGVuQUlTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gICAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBpZiAoY2FsbGJhY2tzLm9uRmluYWwgJiYgYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKSB7XG4gICAgICAgICAgYXdhaXQgY2FsbGJhY2tzLm9uRmluYWwoYWdncmVnYXRlZEZpbmFsQ29tcGxldGlvblJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfSk7XG59XG5cbi8vIHN0cmVhbXMvcmVwbGljYXRlLXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gUmVwbGljYXRlU3RyZWFtKHJlcywgY2IsIG9wdGlvbnMpIHtcbiAgdmFyIF9hMTE7XG4gIGNvbnN0IHVybCA9IChfYTExID0gcmVzLnVybHMpID09IG51bGwgPyB2b2lkIDAgOiBfYTExLnN0cmVhbTtcbiAgaWYgKCF1cmwpIHtcbiAgICBpZiAocmVzLmVycm9yKVxuICAgICAgdGhyb3cgbmV3IEVycm9yKHJlcy5lcnJvcik7XG4gICAgZWxzZVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyBzdHJlYW0gVVJMIGluIFJlcGxpY2F0ZSByZXNwb25zZVwiKTtcbiAgfVxuICBjb25zdCBldmVudFN0cmVhbSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgIG1ldGhvZDogXCJHRVRcIixcbiAgICBoZWFkZXJzOiB7XG4gICAgICBBY2NlcHQ6IFwidGV4dC9ldmVudC1zdHJlYW1cIixcbiAgICAgIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVyc1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiBBSVN0cmVhbShldmVudFN0cmVhbSwgdm9pZCAwLCBjYikucGlwZVRocm91Z2goXG4gICAgY3JlYXRlU3RyZWFtRGF0YVRyYW5zZm9ybWVyKClcbiAgKTtcbn1cblxuLy8gc3RyZWFtcy9zdHJlYW0tdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIHN0cmVhbVRvUmVzcG9uc2UocmVzLCByZXNwb25zZSwgaW5pdCwgZGF0YSkge1xuICB2YXIgX2ExMTtcbiAgcmVzcG9uc2Uud3JpdGVIZWFkKChfYTExID0gaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5zdGF0dXMpICE9IG51bGwgPyBfYTExIDogMjAwLCB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJ0ZXh0L3BsYWluOyBjaGFyc2V0PXV0Zi04XCIsXG4gICAgLi4uaW5pdCA9PSBudWxsID8gdm9pZCAwIDogaW5pdC5oZWFkZXJzXG4gIH0pO1xuICBsZXQgcHJvY2Vzc2VkU3RyZWFtID0gcmVzO1xuICBpZiAoZGF0YSkge1xuICAgIHByb2Nlc3NlZFN0cmVhbSA9IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgcmVzKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSBwcm9jZXNzZWRTdHJlYW0uZ2V0UmVhZGVyKCk7XG4gIGZ1bmN0aW9uIHJlYWQoKSB7XG4gICAgcmVhZGVyLnJlYWQoKS50aGVuKCh7IGRvbmUsIHZhbHVlIH0pID0+IHtcbiAgICAgIGlmIChkb25lKSB7XG4gICAgICAgIHJlc3BvbnNlLmVuZCgpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICByZXNwb25zZS53cml0ZSh2YWx1ZSk7XG4gICAgICByZWFkKCk7XG4gICAgfSk7XG4gIH1cbiAgcmVhZCgpO1xufVxuXG4vLyBzdHJlYW1zL3N0cmVhbWluZy10ZXh0LXJlc3BvbnNlLnRzXG52YXIgU3RyZWFtaW5nVGV4dFJlc3BvbnNlID0gY2xhc3MgZXh0ZW5kcyBSZXNwb25zZSB7XG4gIGNvbnN0cnVjdG9yKHJlcywgaW5pdCwgZGF0YSkge1xuICAgIGxldCBwcm9jZXNzZWRTdHJlYW0gPSByZXM7XG4gICAgaWYgKGRhdGEpIHtcbiAgICAgIHByb2Nlc3NlZFN0cmVhbSA9IG1lcmdlU3RyZWFtcyhkYXRhLnN0cmVhbSwgcmVzKTtcbiAgICB9XG4gICAgc3VwZXIocHJvY2Vzc2VkU3RyZWFtLCB7XG4gICAgICAuLi5pbml0LFxuICAgICAgc3RhdHVzOiAyMDAsXG4gICAgICBoZWFkZXJzOiBwcmVwYXJlUmVzcG9uc2VIZWFkZXJzKGluaXQsIHtcbiAgICAgICAgY29udGVudFR5cGU6IFwidGV4dC9wbGFpbjsgY2hhcnNldD11dGYtOFwiXG4gICAgICB9KVxuICAgIH0pO1xuICB9XG59O1xuXG4vLyBzdHJlYW1zL2luZGV4LnRzXG52YXIgZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkSW1wbDtcbnZhciBuYW5vaWQgPSBnZW5lcmF0ZUlkSW1wbDtcbmV4cG9ydCB7XG4gIEFJU0RLRXJyb3IxMCBhcyBBSVNES0Vycm9yLFxuICBBSVN0cmVhbSxcbiAgQVBJQ2FsbEVycm9yMiBhcyBBUElDYWxsRXJyb3IsXG4gIEFXU0JlZHJvY2tBbnRocm9waWNNZXNzYWdlc1N0cmVhbSxcbiAgQVdTQmVkcm9ja0FudGhyb3BpY1N0cmVhbSxcbiAgQVdTQmVkcm9ja0NvaGVyZVN0cmVhbSxcbiAgQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSxcbiAgQVdTQmVkcm9ja1N0cmVhbSxcbiAgQW50aHJvcGljU3RyZWFtLFxuICBBc3Npc3RhbnRSZXNwb25zZSxcbiAgQ29oZXJlU3RyZWFtLFxuICBEb3dubG9hZEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0sXG4gIEh1Z2dpbmdGYWNlU3RyZWFtLFxuICBJbmtlZXBTdHJlYW0sXG4gIEludmFsaWRBcmd1bWVudEVycm9yLFxuICBJbnZhbGlkRGF0YUNvbnRlbnRFcnJvcixcbiAgSW52YWxpZE1lc3NhZ2VSb2xlRXJyb3IsXG4gIEludmFsaWRQcm9tcHRFcnJvcjIgYXMgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEludmFsaWRUb29sQXJndW1lbnRzRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBsYW5nY2hhaW5fYWRhcHRlcl9leHBvcnRzIGFzIExhbmdDaGFpbkFkYXB0ZXIsXG4gIExhbmdDaGFpblN0cmVhbSxcbiAgbGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMgYXMgTGxhbWFJbmRleEFkYXB0ZXIsXG4gIExvYWRBUElLZXlFcnJvcixcbiAgTWVzc2FnZUNvbnZlcnNpb25FcnJvcixcbiAgTWlzdHJhbFN0cmVhbSxcbiAgTm9Db250ZW50R2VuZXJhdGVkRXJyb3IsXG4gIE5vT2JqZWN0R2VuZXJhdGVkRXJyb3IsXG4gIE5vU3VjaE1vZGVsRXJyb3IsXG4gIE5vU3VjaFByb3ZpZGVyRXJyb3IsXG4gIE5vU3VjaFRvb2xFcnJvcixcbiAgT3BlbkFJU3RyZWFtLFxuICBSZXBsaWNhdGVTdHJlYW0sXG4gIFJldHJ5RXJyb3IsXG4gIFN0cmVhbURhdGEyIGFzIFN0cmVhbURhdGEsXG4gIFN0cmVhbWluZ1RleHRSZXNwb25zZSxcbiAgVHlwZVZhbGlkYXRpb25FcnJvcjIgYXMgVHlwZVZhbGlkYXRpb25FcnJvcixcbiAgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIGFzIFVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yLFxuICBjb252ZXJ0VG9Db3JlTWVzc2FnZXMsXG4gIGNvc2luZVNpbWlsYXJpdHksXG4gIGNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyLFxuICBjcmVhdGVFdmVudFN0cmVhbVRyYW5zZm9ybWVyLFxuICBjcmVhdGVTdHJlYW1EYXRhVHJhbnNmb3JtZXIsXG4gIGVtYmVkLFxuICBlbWJlZE1hbnksXG4gIGV4cGVyaW1lbnRhbF9Bc3Npc3RhbnRSZXNwb25zZSxcbiAgZXhwZXJpbWVudGFsX1N0cmVhbURhdGEsXG4gIGV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5LFxuICBleHBlcmltZW50YWxfY3JlYXRlUHJvdmlkZXJSZWdpc3RyeSxcbiAgZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyLFxuICBleHBlcmltZW50YWxfZ2VuZXJhdGVPYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9nZW5lcmF0ZVRleHQsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QsXG4gIGV4cGVyaW1lbnRhbF9zdHJlYW1UZXh0LFxuICBleHBlcmltZW50YWxfd3JhcExhbmd1YWdlTW9kZWwsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQyIGFzIGdlbmVyYXRlSWQsXG4gIGdlbmVyYXRlT2JqZWN0LFxuICBnZW5lcmF0ZVRleHQsXG4gIGpzb25TY2hlbWEsXG4gIG5hbm9pZCxcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2UsXG4gIHJlYWREYXRhU3RyZWFtLFxuICByZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlLFxuICBzdHJlYW1PYmplY3QsXG4gIHN0cmVhbVRleHQsXG4gIHN0cmVhbVRvUmVzcG9uc2UsXG4gIHRvb2wsXG4gIHRyaW1TdGFydE9mU3RyZWFtSGVscGVyXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJfX2RlZlByb3AiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9fZXhwb3J0IiwidGFyZ2V0IiwiYWxsIiwibmFtZTExIiwiZ2V0IiwiZW51bWVyYWJsZSIsImZvcm1hdFN0cmVhbVBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJyZWFkRGF0YVN0cmVhbSIsInByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSIsImdlbmVyYXRlSWQiLCJnZW5lcmF0ZUlkSW1wbCIsImpzb25TY2hlbWEiLCJBUElDYWxsRXJyb3IiLCJnZXRFcnJvck1lc3NhZ2UiLCJpc0Fib3J0RXJyb3IiLCJkZWxheSIsImRlbGF5SW5NcyIsIlByb21pc2UiLCJyZXNvbHZlIiwic2V0VGltZW91dCIsIkFJU0RLRXJyb3IiLCJuYW1lIiwibWFya2VyIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiX2EiLCJSZXRyeUVycm9yIiwiY29uc3RydWN0b3IiLCJtZXNzYWdlIiwicmVhc29uIiwiZXJyb3JzIiwibGFzdEVycm9yIiwibGVuZ3RoIiwiaXNJbnN0YW5jZSIsImVycm9yIiwiaGFzTWFya2VyIiwiaXNSZXRyeUVycm9yIiwiRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJ0b0pTT04iLCJyZXRyeVdpdGhFeHBvbmVudGlhbEJhY2tvZmYiLCJtYXhSZXRyaWVzIiwiaW5pdGlhbERlbGF5SW5NcyIsImJhY2tvZmZGYWN0b3IiLCJmIiwiX3JldHJ5V2l0aEV4cG9uZW50aWFsQmFja29mZiIsImVycm9yTWVzc2FnZSIsIm5ld0Vycm9ycyIsInRyeU51bWJlciIsImlzQVBJQ2FsbEVycm9yIiwiaXNSZXRyeWFibGUiLCJhc3NlbWJsZU9wZXJhdGlvbk5hbWUiLCJvcGVyYXRpb25JZCIsInRlbGVtZXRyeSIsImZ1bmN0aW9uSWQiLCJnZXRCYXNlVGVsZW1ldHJ5QXR0cmlidXRlcyIsIm1vZGVsIiwic2V0dGluZ3MiLCJoZWFkZXJzIiwiX2ExMSIsInByb3ZpZGVyIiwibW9kZWxJZCIsImVudHJpZXMiLCJyZWR1Y2UiLCJhdHRyaWJ1dGVzIiwia2V5IiwidmFsdWUiLCJtZXRhZGF0YSIsInRyYWNlIiwibm9vcFRyYWNlciIsInN0YXJ0U3BhbiIsIm5vb3BTcGFuIiwic3RhcnRBY3RpdmVTcGFuIiwiYXJnMSIsImFyZzIiLCJhcmczIiwic3BhbkNvbnRleHQiLCJub29wU3BhbkNvbnRleHQiLCJzZXRBdHRyaWJ1dGUiLCJzZXRBdHRyaWJ1dGVzIiwiYWRkRXZlbnQiLCJhZGRMaW5rIiwiYWRkTGlua3MiLCJzZXRTdGF0dXMiLCJ1cGRhdGVOYW1lIiwiZW5kIiwiaXNSZWNvcmRpbmciLCJyZWNvcmRFeGNlcHRpb24iLCJ0cmFjZUlkIiwic3BhbklkIiwidHJhY2VGbGFncyIsImdldFRyYWNlciIsImlzRW5hYmxlZCIsInRyYWNlciIsIlNwYW5TdGF0dXNDb2RlIiwicmVjb3JkU3BhbiIsImZuIiwiZW5kV2hlbkRvbmUiLCJzcGFuIiwicmVzdWx0Iiwic3RhY2siLCJjb2RlIiwiRVJST1IiLCJzZWxlY3RUZWxlbWV0cnlBdHRyaWJ1dGVzIiwiYXR0cmlidXRlczIiLCJpbnB1dCIsInJlY29yZElucHV0cyIsIm91dHB1dCIsInJlY29yZE91dHB1dHMiLCJlbWJlZCIsImFib3J0U2lnbmFsIiwiZXhwZXJpbWVudGFsX3RlbGVtZXRyeSIsImJhc2VUZWxlbWV0cnlBdHRyaWJ1dGVzIiwiSlNPTiIsInN0cmluZ2lmeSIsInJldHJ5IiwiZW1iZWRkaW5nIiwidXNhZ2UiLCJyYXdSZXNwb25zZSIsImRvRW1iZWRTcGFuIiwibW9kZWxSZXNwb25zZSIsImRvRW1iZWQiLCJ2YWx1ZXMiLCJlbWJlZGRpbmcyIiwiZW1iZWRkaW5ncyIsInVzYWdlMiIsInRva2VucyIsIk5hTiIsIm1hcCIsImVtYmVkZGluZzMiLCJEZWZhdWx0RW1iZWRSZXN1bHQiLCJvcHRpb25zIiwic3BsaXRBcnJheSIsImFycmF5IiwiY2h1bmtTaXplIiwiaSIsInB1c2giLCJzbGljZSIsImVtYmVkTWFueSIsIm1heEVtYmVkZGluZ3NQZXJDYWxsIiwiZW1iZWRkaW5nczIiLCJlbWJlZGRpbmdzMyIsIkRlZmF1bHRFbWJlZE1hbnlSZXN1bHQiLCJ2YWx1ZUNodW5rcyIsImNodW5rIiwicmVzcG9uc2VFbWJlZGRpbmdzIiwiY3JlYXRlSWRHZW5lcmF0b3IiLCJzYWZlUGFyc2VKU09OIiwiQUlTREtFcnJvcjIiLCJuYW1lMiIsIm1hcmtlcjIiLCJzeW1ib2wyIiwiX2EyIiwiRG93bmxvYWRFcnJvciIsInVybCIsInN0YXR1c0NvZGUiLCJzdGF0dXNUZXh0IiwiY2F1c2UiLCJpc0Rvd25sb2FkRXJyb3IiLCJkb3dubG9hZCIsImZldGNoSW1wbGVtZW50YXRpb24iLCJmZXRjaCIsInVybFRleHQiLCJ0b1N0cmluZyIsInJlc3BvbnNlIiwib2siLCJzdGF0dXMiLCJkYXRhIiwiVWludDhBcnJheSIsImFycmF5QnVmZmVyIiwibWltZVR5cGUiLCJtaW1lVHlwZVNpZ25hdHVyZXMiLCJieXRlcyIsImRldGVjdEltYWdlTWltZVR5cGUiLCJpbWFnZSIsImV2ZXJ5IiwiYnl0ZSIsImluZGV4IiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJBSVNES0Vycm9yMyIsIm5hbWUzIiwibWFya2VyMyIsInN5bWJvbDMiLCJfYTMiLCJJbnZhbGlkRGF0YUNvbnRlbnRFcnJvciIsImNvbnRlbnQiLCJpc0ludmFsaWREYXRhQ29udGVudEVycm9yIiwieiIsImRhdGFDb250ZW50U2NoZW1hIiwidW5pb24iLCJzdHJpbmciLCJpbnN0YW5jZW9mIiwiQXJyYXlCdWZmZXIiLCJjdXN0b20iLCJfYiIsImdsb2JhbFRoaXMiLCJCdWZmZXIiLCJpc0J1ZmZlciIsImNvbnZlcnREYXRhQ29udGVudFRvQmFzZTY0U3RyaW5nIiwiY29udmVydERhdGFDb250ZW50VG9VaW50OEFycmF5IiwiY29udmVydFVpbnQ4QXJyYXlUb1RleHQiLCJ1aW50OEFycmF5IiwiVGV4dERlY29kZXIiLCJkZWNvZGUiLCJBSVNES0Vycm9yNCIsIm5hbWU0IiwibWFya2VyNCIsInN5bWJvbDQiLCJfYTQiLCJJbnZhbGlkTWVzc2FnZVJvbGVFcnJvciIsInJvbGUiLCJpc0ludmFsaWRNZXNzYWdlUm9sZUVycm9yIiwic3BsaXREYXRhVXJsIiwiZGF0YVVybCIsImhlYWRlciIsImJhc2U2NENvbnRlbnQiLCJzcGxpdCIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxQcm9tcHQiLCJwcm9tcHQiLCJtb2RlbFN1cHBvcnRzSW1hZ2VVcmxzIiwibW9kZWxTdXBwb3J0c1VybCIsImRvd25sb2FkSW1wbGVtZW50YXRpb24iLCJkb3dubG9hZGVkQXNzZXRzIiwiZG93bmxvYWRBc3NldHMiLCJtZXNzYWdlcyIsInN5c3RlbSIsImNvbnZlcnRUb0xhbmd1YWdlTW9kZWxNZXNzYWdlIiwicHJvdmlkZXJNZXRhZGF0YSIsImV4cGVyaW1lbnRhbF9wcm92aWRlck1ldGFkYXRhIiwidHlwZSIsInRleHQiLCJwYXJ0IiwiY29udmVydFBhcnRUb0xhbmd1YWdlTW9kZWxQYXJ0IiwiZmlsdGVyIiwicmVzdCIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsImV4cGVyaW1lbnRhbF9jb250ZW50IiwiaXNFcnJvciIsIl9leGhhdXN0aXZlQ2hlY2siLCJ1cmxzIiwiZmxhdCIsInN0YXJ0c1dpdGgiLCJVUkwiLCJkb3dubG9hZGVkSW1hZ2VzIiwiZnJvbUVudHJpZXMiLCJub3JtYWxpemVkRGF0YSIsInByb3RvY29sIiwiZGF0YVVybE1pbWVUeXBlIiwiZG93bmxvYWRlZEZpbGUiLCJBSVNES0Vycm9yNSIsIm5hbWU1IiwibWFya2VyNSIsInN5bWJvbDUiLCJfYTUiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsInBhcmFtZXRlciIsImlzSW52YWxpZEFyZ3VtZW50RXJyb3IiLCJwcmVwYXJlQ2FsbFNldHRpbmdzIiwibWF4VG9rZW5zIiwidGVtcGVyYXR1cmUiLCJ0b3BQIiwidG9wSyIsInByZXNlbmNlUGVuYWx0eSIsImZyZXF1ZW5jeVBlbmFsdHkiLCJzdG9wU2VxdWVuY2VzIiwic2VlZCIsIk51bWJlciIsImlzSW50ZWdlciIsIkludmFsaWRQcm9tcHRFcnJvciIsInNhZmVWYWxpZGF0ZVR5cGVzIiwiejciLCJ6NiIsInozIiwiejIiLCJqc29uVmFsdWVTY2hlbWEiLCJsYXp5IiwibnVsbCIsIm51bWJlciIsImJvb2xlYW4iLCJyZWNvcmQiLCJwcm92aWRlck1ldGFkYXRhU2NoZW1hIiwiejUiLCJ6NCIsInRvb2xSZXN1bHRDb250ZW50U2NoZW1hIiwib2JqZWN0IiwibGl0ZXJhbCIsIm9wdGlvbmFsIiwidGV4dFBhcnRTY2hlbWEiLCJpbWFnZVBhcnRTY2hlbWEiLCJmaWxlUGFydFNjaGVtYSIsInRvb2xDYWxsUGFydFNjaGVtYSIsImFyZ3MiLCJ1bmtub3duIiwidG9vbFJlc3VsdFBhcnRTY2hlbWEiLCJjb3JlU3lzdGVtTWVzc2FnZVNjaGVtYSIsImNvcmVVc2VyTWVzc2FnZVNjaGVtYSIsImNvcmVBc3Npc3RhbnRNZXNzYWdlU2NoZW1hIiwiY29yZVRvb2xNZXNzYWdlU2NoZW1hIiwiY29yZU1lc3NhZ2VTY2hlbWEiLCJkZXRlY3RQcm9tcHRUeXBlIiwiY2hhcmFjdGVyaXN0aWNzIiwiZGV0ZWN0U2luZ2xlTWVzc2FnZUNoYXJhY3RlcmlzdGljcyIsInNvbWUiLCJjIiwiaW5jbHVkZXMiLCJhdHRhY2htZW50c1RvUGFydHMiLCJhdHRhY2htZW50cyIsIl9jIiwicGFydHMiLCJhdHRhY2htZW50IiwiY29udGVudFR5cGUiLCJBSVNES0Vycm9yNiIsIm5hbWU2IiwibWFya2VyNiIsInN5bWJvbDYiLCJfYTYiLCJNZXNzYWdlQ29udmVyc2lvbkVycm9yIiwib3JpZ2luYWxNZXNzYWdlIiwiY29udmVydFRvQ29yZU1lc3NhZ2VzIiwidG9vbHMiLCJjb3JlTWVzc2FnZXMiLCJ0b29sSW52b2NhdGlvbnMiLCJleHBlcmltZW50YWxfYXR0YWNobWVudHMiLCJ0b29sSW52b2NhdGlvbiIsInRvb2wyIiwiZXhwZXJpbWVudGFsX3RvVG9vbFJlc3VsdENvbnRlbnQiLCJzdGFuZGFyZGl6ZVByb21wdCIsInByb21wdFR5cGUiLCJ2YWxpZGF0aW9uUmVzdWx0Iiwic2NoZW1hIiwic3VjY2VzcyIsImNhbGN1bGF0ZUxhbmd1YWdlTW9kZWxVc2FnZSIsInByb21wdFRva2VucyIsImNvbXBsZXRpb25Ub2tlbnMiLCJ0b3RhbFRva2VucyIsInByZXBhcmVSZXNwb25zZUhlYWRlcnMiLCJpbml0IiwiZGF0YVN0cmVhbVZlcnNpb24iLCJIZWFkZXJzIiwiaGFzIiwic2V0IiwiREVGQVVMVF9TQ0hFTUFfUFJFRklYIiwiREVGQVVMVF9TQ0hFTUFfU1VGRklYIiwiREVGQVVMVF9HRU5FUklDX1NVRkZJWCIsImluamVjdEpzb25JbnN0cnVjdGlvbiIsInNjaGVtYVByZWZpeCIsInNjaGVtYVN1ZmZpeCIsImxpbmUiLCJqb2luIiwiQUlTREtFcnJvcjciLCJuYW1lNyIsIm1hcmtlcjciLCJzeW1ib2w3IiwiX2E3IiwiTm9PYmplY3RHZW5lcmF0ZWRFcnJvciIsImlzTm9PYmplY3RHZW5lcmF0ZWRFcnJvciIsImlzSlNPTkFycmF5IiwiaXNKU09OT2JqZWN0IiwiVHlwZVZhbGlkYXRpb25FcnJvciIsIlVuc3VwcG9ydGVkRnVuY3Rpb25hbGl0eUVycm9yIiwic2FmZVZhbGlkYXRlVHlwZXMyIiwiYXNTY2hlbWEiLCJjcmVhdGVBc3luY0l0ZXJhYmxlU3RyZWFtIiwic291cmNlIiwidHJhbnNmb3JtZXIiLCJ0cmFuc2Zvcm1lZFN0cmVhbSIsInBpcGVUaHJvdWdoIiwiVHJhbnNmb3JtU3RyZWFtIiwiYXN5bmNJdGVyYXRvciIsInJlYWRlciIsImdldFJlYWRlciIsIm5leHQiLCJkb25lIiwicmVhZCIsIm5vU2NoZW1hT3V0cHV0U3RyYXRlZ3kiLCJ2YWxpZGF0ZVBhcnRpYWxSZXN1bHQiLCJ0ZXh0RGVsdGEiLCJwYXJ0aWFsIiwidmFsaWRhdGVGaW5hbFJlc3VsdCIsImNyZWF0ZUVsZW1lbnRTdHJlYW0iLCJmdW5jdGlvbmFsaXR5Iiwib2JqZWN0T3V0cHV0U3RyYXRlZ3kiLCJhcnJheU91dHB1dFN0cmF0ZWd5IiwiJHNjaGVtYSIsIml0ZW1TY2hlbWEiLCJwcm9wZXJ0aWVzIiwiZWxlbWVudHMiLCJpdGVtcyIsInJlcXVpcmVkIiwiYWRkaXRpb25hbFByb3BlcnRpZXMiLCJsYXRlc3RPYmplY3QiLCJpc0ZpcnN0RGVsdGEiLCJpc0ZpbmFsRGVsdGEiLCJpbnB1dEFycmF5IiwicmVzdWx0QXJyYXkiLCJlbGVtZW50IiwicHVibGlzaGVkRWxlbWVudENvdW50Iiwib3JpZ2luYWxTdHJlYW0iLCJwdWJsaXNoZWRFbGVtZW50cyIsInRyYW5zZm9ybSIsImNvbnRyb2xsZXIiLCJlbnF1ZXVlIiwiZW51bU91dHB1dFN0cmF0ZWd5IiwiZW51bVZhbHVlcyIsImVudW0iLCJnZXRPdXRwdXRTdHJhdGVneSIsInZhbGlkYXRlT2JqZWN0R2VuZXJhdGlvbklucHV0IiwibW9kZSIsInNjaGVtYU5hbWUiLCJzY2hlbWFEZXNjcmlwdGlvbiIsIm9yaWdpbmFsR2VuZXJhdGVJZCIsInByZWZpeCIsInNpemUiLCJnZW5lcmF0ZU9iamVjdCIsImlucHV0U2NoZW1hIiwiX2ludGVybmFsIiwiZ2VuZXJhdGVJZDMiLCJjdXJyZW50RGF0ZSIsIkRhdGUiLCJvdXRwdXRTdHJhdGVneSIsImRlZmF1bHRPYmplY3RHZW5lcmF0aW9uTW9kZSIsImZpbmlzaFJlYXNvbiIsIndhcm5pbmdzIiwicmVxdWVzdCIsImxvZ3Byb2JzIiwicmVzdWx0UHJvdmlkZXJNZXRhZGF0YSIsInN0YW5kYXJkaXplZFByb21wdCIsInN1cHBvcnRzU3RydWN0dXJlZE91dHB1dHMiLCJwcm9tcHRNZXNzYWdlcyIsInN1cHBvcnRzSW1hZ2VVcmxzIiwic3VwcG9ydHNVcmwiLCJnZW5lcmF0ZVJlc3VsdCIsInNwYW4yIiwiX2ExMiIsIl9iMiIsIl9kIiwiX2UiLCJfZiIsInJlc3VsdDIiLCJkb0dlbmVyYXRlIiwiZGVzY3JpcHRpb24iLCJpbnB1dEZvcm1hdCIsInJlc3BvbnNlRGF0YSIsImlkIiwidGltZXN0YW1wIiwidG9JU09TdHJpbmciLCJvYmplY3RUZXh0IiwiX2ciLCJfaCIsInRvb2wiLCJwYXJhbWV0ZXJzIiwidG9vbENhbGxzIiwicGFyc2VSZXN1bHQiLCJEZWZhdWx0R2VuZXJhdGVPYmplY3RSZXN1bHQiLCJ0b0pzb25SZXNwb25zZSIsIlJlc3BvbnNlIiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlT2JqZWN0IiwiY3JlYXRlSWRHZW5lcmF0b3IyIiwiaXNEZWVwRXF1YWxEYXRhIiwicGFyc2VQYXJ0aWFsSnNvbiIsImNyZWF0ZVJlc29sdmFibGVQcm9taXNlIiwicmVqZWN0IiwicHJvbWlzZSIsInJlcyIsInJlaiIsIkRlbGF5ZWRQcm9taXNlIiwiX3Jlc29sdmUiLCJfcmVqZWN0IiwiY2FsbCIsIm5vdyIsInBlcmZvcm1hbmNlIiwicHJlcGFyZU91dGdvaW5nSHR0cEhlYWRlcnMiLCJ3cml0ZVRvU2VydmVyUmVzcG9uc2UiLCJzdHJlYW0iLCJ3cml0ZUhlYWQiLCJ3cml0ZSIsIm9yaWdpbmFsR2VuZXJhdGVJZDIiLCJzdHJlYW1PYmplY3QiLCJvbkZpbmlzaCIsIm5vdzIiLCJyb290U3BhbiIsImNhbGxPcHRpb25zIiwiYXJnc1RleHREZWx0YSIsImRvU3RyZWFtU3BhbiIsInN0YXJ0VGltZXN0YW1wTXMiLCJkb1N0cmVhbVNwYW4yIiwiZG9TdHJlYW0iLCJEZWZhdWx0U3RyZWFtT2JqZWN0UmVzdWx0Iiwib2JqZWN0UHJvbWlzZSIsInJlc29sdmVVc2FnZSIsInVzYWdlUHJvbWlzZSIsInJlc29sdmVSZXNwb25zZSIsInJlc3BvbnNlUHJvbWlzZSIsInJlc29sdmVQcm92aWRlck1ldGFkYXRhIiwicHJvdmlkZXJNZXRhZGF0YVByb21pc2UiLCJhY2N1bXVsYXRlZFRleHQiLCJsYXRlc3RPYmplY3RKc29uIiwiaXNGaXJzdENodW5rIiwic2VsZiIsIm1zVG9GaXJzdENodW5rIiwiY3VycmVudE9iamVjdEpzb24iLCJzdGF0ZSIsInBhcnNlU3RhdGUiLCJmbHVzaCIsImZpbmFsVXNhZ2UiLCJlcnJvcjIiLCJwYXJ0aWFsT2JqZWN0U3RyZWFtIiwiZWxlbWVudFN0cmVhbSIsInRleHRTdHJlYW0iLCJmdWxsU3RyZWFtIiwicGlwZVRleHRTdHJlYW1Ub1Jlc3BvbnNlIiwiVGV4dEVuY29kZXJTdHJlYW0iLCJ0b1RleHRTdHJlYW1SZXNwb25zZSIsImV4cGVyaW1lbnRhbF9zdHJlYW1PYmplY3QiLCJjcmVhdGVJZEdlbmVyYXRvcjMiLCJBSVNES0Vycm9yMTAiLCJBUElDYWxsRXJyb3IyIiwiRW1wdHlSZXNwb25zZUJvZHlFcnJvciIsIkludmFsaWRQcm9tcHRFcnJvcjIiLCJJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IiLCJKU09OUGFyc2VFcnJvciIsIkxvYWRBUElLZXlFcnJvciIsIk5vQ29udGVudEdlbmVyYXRlZEVycm9yIiwiTm9TdWNoTW9kZWxFcnJvciIsIlR5cGVWYWxpZGF0aW9uRXJyb3IyIiwiVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IyIiwiQUlTREtFcnJvcjgiLCJnZXRFcnJvck1lc3NhZ2UyIiwibmFtZTgiLCJtYXJrZXI4Iiwic3ltYm9sOCIsIl9hOCIsIkludmFsaWRUb29sQXJndW1lbnRzRXJyb3IiLCJ0b29sQXJncyIsImlzSW52YWxpZFRvb2xBcmd1bWVudHNFcnJvciIsIkFJU0RLRXJyb3I5IiwibmFtZTkiLCJtYXJrZXI5Iiwic3ltYm9sOSIsIl9hOSIsIk5vU3VjaFRvb2xFcnJvciIsImF2YWlsYWJsZVRvb2xzIiwiaXNOb1N1Y2hUb29sRXJyb3IiLCJhc1NjaGVtYTIiLCJpc05vbkVtcHR5T2JqZWN0Iiwia2V5cyIsInByZXBhcmVUb29sc0FuZFRvb2xDaG9pY2UiLCJ0b29sQ2hvaWNlIiwiYWN0aXZlVG9vbHMiLCJmaWx0ZXJlZFRvb2xzIiwidG9vbFR5cGUiLCJleGhhdXN0aXZlQ2hlY2siLCJsYXN0V2hpdGVzcGFjZVJlZ2V4cCIsInNwbGl0T25MYXN0V2hpdGVzcGFjZSIsIm1hdGNoIiwid2hpdGVzcGFjZSIsInN1ZmZpeCIsInJlbW92ZVRleHRBZnRlckxhc3RXaGl0ZXNwYWNlIiwic2FmZVBhcnNlSlNPTjIiLCJzYWZlVmFsaWRhdGVUeXBlczMiLCJhc1NjaGVtYTMiLCJwYXJzZVRvb2xDYWxsIiwidG9vbENhbGwiLCJ0cmltIiwidG9SZXNwb25zZU1lc3NhZ2VzIiwidG9vbFJlc3VsdHMiLCJyZXNwb25zZU1lc3NhZ2VzIiwidG9vbFJlc3VsdCIsIm9yaWdpbmFsR2VuZXJhdGVJZDMiLCJnZW5lcmF0ZVRleHQiLCJtYXhBdXRvbWF0aWNSb3VuZHRyaXBzIiwibWF4VG9vbFJvdW5kdHJpcHMiLCJtYXhTdGVwcyIsImV4cGVyaW1lbnRhbF9jb250aW51YXRpb25TdGVwcyIsImV4cGVyaW1lbnRhbF9jb250aW51ZVN0ZXBzIiwiY29udGludWVTdGVwcyIsImV4cGVyaW1lbnRhbF9hY3RpdmVUb29scyIsIm9uU3RlcEZpbmlzaCIsImluaXRpYWxQcm9tcHQiLCJjYWxsU2V0dGluZ3MiLCJjdXJyZW50TW9kZWxSZXNwb25zZSIsImN1cnJlbnRUb29sQ2FsbHMiLCJjdXJyZW50VG9vbFJlc3VsdHMiLCJzdGVwQ291bnQiLCJzdGVwcyIsInN0ZXBUeXBlIiwicHJvbXB0Rm9ybWF0IiwiX2MyIiwiX2QyIiwiX2UyIiwiX2YyIiwibW9kZWxUb29sQ2FsbCIsImV4ZWN1dGVUb29scyIsImN1cnJlbnRVc2FnZSIsIm5leHRTdGVwVHlwZSIsIm9yaWdpbmFsVGV4dCIsInN0ZXBUZXh0TGVhZGluZ1doaXRlc3BhY2VUcmltbWVkIiwidHJpbUVuZCIsInRyaW1TdGFydCIsInN0ZXBUZXh0IiwibGFzdE1lc3NhZ2UiLCJjdXJyZW50U3RlcFJlc3VsdCIsInBhcnNlIiwiaXNDb250aW51ZWQiLCJEZWZhdWx0R2VuZXJhdGVUZXh0UmVzdWx0IiwiZXhlY3V0ZSIsImlnbm9yZWQiLCJyb3VuZHRyaXBzIiwiZXhwZXJpbWVudGFsX2dlbmVyYXRlVGV4dCIsImNyZWF0ZUlkR2VuZXJhdG9yNCIsImNyZWF0ZVN0aXRjaGFibGVTdHJlYW0iLCJpbm5lclN0cmVhbVJlYWRlcnMiLCJpc0Nsb3NlZCIsInByb2Nlc3NQdWxsIiwiY2xvc2UiLCJzaGlmdCIsIlJlYWRhYmxlU3RyZWFtIiwic3RhcnQiLCJjb250cm9sbGVyUGFyYW0iLCJwdWxsIiwiY2FuY2VsIiwiYWRkU3RyZWFtIiwiaW5uZXJTdHJlYW0iLCJtZXJnZVN0cmVhbXMiLCJzdHJlYW0xIiwic3RyZWFtMiIsInJlYWRlcjEiLCJyZWFkZXIyIiwibGFzdFJlYWQxIiwibGFzdFJlYWQyIiwic3RyZWFtMURvbmUiLCJzdHJlYW0yRG9uZSIsInJlYWRTdHJlYW0xIiwicmVhZFN0cmVhbTIiLCJyYWNlIiwidGhlbiIsInJ1blRvb2xzVHJhbnNmb3JtYXRpb24iLCJnZW5lcmF0b3JTdHJlYW0iLCJ0b29sQ2FsbFN0cmVhbWluZyIsInRvb2xSZXN1bHRzU3RyZWFtQ29udHJvbGxlciIsInRvb2xSZXN1bHRzU3RyZWFtIiwiYWN0aXZlVG9vbENhbGxzIiwib3V0c3RhbmRpbmdUb29sUmVzdWx0cyIsIlNldCIsImNhbkNsb3NlIiwiZmluaXNoQ2h1bmsiLCJhdHRlbXB0Q2xvc2UiLCJmb3J3YXJkU3RyZWFtIiwiY2h1bmtUeXBlIiwidG9vbEV4ZWN1dGlvbklkIiwiYWRkIiwiZGVsZXRlIiwicGlwZVRvIiwiV3JpdGFibGVTdHJlYW0iLCJvcmlnaW5hbEdlbmVyYXRlSWQ0Iiwic3RyZWFtVGV4dCIsImV4cGVyaW1lbnRhbF90b29sQ2FsbFN0cmVhbWluZyIsIm9uQ2h1bmsiLCJzdGFydFN0ZXAiLCJ3YXJuaW5nczIiLCJyYXdSZXNwb25zZTIiLCJyZXF1ZXN0MiIsInN0YXJ0VGltZXN0YW1wTXMyIiwiZG9TdHJlYW1TcGFuMyIsIkRlZmF1bHRTdHJlYW1UZXh0UmVzdWx0IiwicmVzb2x2ZUZpbmlzaFJlYXNvbiIsImZpbmlzaFJlYXNvblByb21pc2UiLCJyZXNvbHZlVGV4dCIsInRleHRQcm9taXNlIiwicmVzb2x2ZVRvb2xDYWxscyIsInRvb2xDYWxsc1Byb21pc2UiLCJyZXNvbHZlVG9vbFJlc3VsdHMiLCJ0b29sUmVzdWx0c1Byb21pc2UiLCJyZXNvbHZlU3RlcHMiLCJzdGVwc1Byb21pc2UiLCJyZXNvbHZlUmVxdWVzdCIsInJlcXVlc3RQcm9taXNlIiwicmVzb2x2ZVJlc3BvbnNlTWVzc2FnZXMiLCJyZXNwb25zZU1lc3NhZ2VzUHJvbWlzZSIsInN0aXRjaGFibGVTdHJlYW0iLCJjbG9zZVN0aXRjaGFibGVTdHJlYW0iLCJzdGVwUmVzdWx0cyIsImFkZFN0ZXBTdHJlYW0iLCJzdGFydFRpbWVzdGFtcCIsImN1cnJlbnRTdGVwIiwicHJldmlvdXNTdGVwVGV4dCIsInN0ZXBSZXF1ZXN0IiwiaGFzTGVhZGluZ1doaXRlc3BhY2UiLCJzdGVwVG9vbENhbGxzIiwic3RlcFRvb2xSZXN1bHRzIiwic3RlcEZpbmlzaFJlYXNvbiIsInN0ZXBVc2FnZSIsInN0ZXBQcm92aWRlck1ldGFkYXRhIiwic3RlcEZpcnN0Q2h1bmsiLCJmdWxsU3RlcFRleHQiLCJzdGVwTG9nUHJvYnMiLCJzdGVwUmVzcG9uc2UiLCJjaHVua0J1ZmZlciIsImNodW5rVGV4dFB1Ymxpc2hlZCIsImluV2hpdGVzcGFjZVByZWZpeCIsImhhc1doaXRlc3BhY2VTdWZmaXgiLCJwdWJsaXNoVGV4dENodW5rIiwidHJpbW1lZENodW5rVGV4dCIsIm1zVG9GaW5pc2giLCJzdGVwVG9vbENhbGxzSnNvbiIsImNvbWJpbmVkVXNhZ2UiLCJzdGFydFRpbWVzdGFtcDIiLCJ0ZWVTdHJlYW0iLCJ0ZWUiLCJ0b0FJU3RyZWFtIiwiY2FsbGJhY2tzIiwidG9EYXRhU3RyZWFtSW50ZXJuYWwiLCJnZXRFcnJvck1lc3NhZ2UzIiwic2VuZFVzYWdlIiwiYWdncmVnYXRlZFJlc3BvbnNlIiwiY2FsbGJhY2tUcmFuc2Zvcm1lciIsIm9uU3RhcnQiLCJvblRva2VuIiwib25UZXh0Iiwib25Db21wbGV0aW9uIiwib25GaW5hbCIsInN0cmVhbVBhcnRzVHJhbnNmb3JtZXIiLCJwaXBlQUlTdHJlYW1Ub1Jlc3BvbnNlIiwicGlwZURhdGFTdHJlYW1Ub1Jlc3BvbnNlIiwidG9EYXRhU3RyZWFtIiwidG9BSVN0cmVhbVJlc3BvbnNlIiwidG9EYXRhU3RyZWFtUmVzcG9uc2UiLCJleHBlcmltZW50YWxfc3RyZWFtVGV4dCIsImV4cGVyaW1lbnRhbF93cmFwTGFuZ3VhZ2VNb2RlbCIsIm1pZGRsZXdhcmUiLCJ0cmFuc2Zvcm1QYXJhbXMiLCJ3cmFwR2VuZXJhdGUiLCJ3cmFwU3RyZWFtIiwicHJvdmlkZXJJZCIsImRvVHJhbnNmb3JtIiwicGFyYW1zIiwic3BlY2lmaWNhdGlvblZlcnNpb24iLCJ0cmFuc2Zvcm1lZFBhcmFtcyIsIk5vU3VjaE1vZGVsRXJyb3IyIiwiZXhwZXJpbWVudGFsX2N1c3RvbVByb3ZpZGVyIiwibGFuZ3VhZ2VNb2RlbHMiLCJ0ZXh0RW1iZWRkaW5nTW9kZWxzIiwiZmFsbGJhY2tQcm92aWRlciIsImxhbmd1YWdlTW9kZWwiLCJtb2RlbFR5cGUiLCJ0ZXh0RW1iZWRkaW5nTW9kZWwiLCJBSVNES0Vycm9yMTEiLCJOb1N1Y2hNb2RlbEVycm9yMyIsIm5hbWUxMCIsIm1hcmtlcjEwIiwic3ltYm9sMTAiLCJfYTEwIiwiTm9TdWNoUHJvdmlkZXJFcnJvciIsImF2YWlsYWJsZVByb3ZpZGVycyIsImVycm9yTmFtZSIsImlzTm9TdWNoUHJvdmlkZXJFcnJvciIsIk5vU3VjaE1vZGVsRXJyb3I0IiwiZXhwZXJpbWVudGFsX2NyZWF0ZVByb3ZpZGVyUmVnaXN0cnkiLCJwcm92aWRlcnMiLCJyZWdpc3RyeSIsIkRlZmF1bHRQcm92aWRlclJlZ2lzdHJ5IiwicmVnaXN0ZXJQcm92aWRlciIsImV4cGVyaW1lbnRhbF9jcmVhdGVNb2RlbFJlZ2lzdHJ5IiwiZ2V0UHJvdmlkZXIiLCJzcGxpdElkIiwiaW5kZXhPZiIsInRleHRFbWJlZGRpbmciLCJjb3NpbmVTaW1pbGFyaXR5IiwidmVjdG9yMSIsInZlY3RvcjIiLCJkb3RQcm9kdWN0IiwibWFnbml0dWRlIiwiYWNjdW11bGF0b3IiLCJ2ZWN0b3IiLCJNYXRoIiwic3FydCIsImNyZWF0ZVBhcnNlciIsImNyZWF0ZUV2ZW50U3RyZWFtVHJhbnNmb3JtZXIiLCJjdXN0b21QYXJzZXIiLCJ0ZXh0RGVjb2RlciIsImV2ZW50U291cmNlUGFyc2VyIiwiZXZlbnQiLCJ0ZXJtaW5hdGUiLCJwYXJzZWRNZXNzYWdlIiwiZmVlZCIsImNyZWF0ZUNhbGxiYWNrc1RyYW5zZm9ybWVyIiwiY2IiLCJ0ZXh0RW5jb2RlciIsIlRleHRFbmNvZGVyIiwiZW5jb2RlIiwiaXNPcGVuQUlDYWxsYmFja3MiLCJpc09mVHlwZU9wZW5BSVN0cmVhbUNhbGxiYWNrcyIsInRyaW1TdGFydE9mU3RyZWFtSGVscGVyIiwiaXNTdHJlYW1TdGFydCIsIkFJU3RyZWFtIiwiYm9keSIsImVycm9yVGV4dCIsInJlc3BvbnNlQm9keVN0cmVhbSIsImNyZWF0ZUVtcHR5UmVhZGFibGVTdHJlYW0iLCJyZWFkYWJsZUZyb21Bc3luY0l0ZXJhYmxlIiwiaXRlcmFibGUiLCJpdCIsInJldHVybiIsImZvcm1hdFN0cmVhbVBhcnQyIiwiSEFOR0lOR19TVFJFQU1fV0FSTklOR19USU1FX01TIiwiU3RyZWFtRGF0YTIiLCJlbmNvZGVyIiwid2FybmluZ1RpbWVvdXQiLCJwcm9jZXNzIiwiY29uc29sZSIsIndhcm4iLCJjbGVhclRpbWVvdXQiLCJhcHBlbmQiLCJhcHBlbmRNZXNzYWdlQW5ub3RhdGlvbiIsImNyZWF0ZVN0cmVhbURhdGFUcmFuc2Zvcm1lciIsImRlY29kZXIiLCJleHBlcmltZW50YWxfU3RyZWFtRGF0YSIsInBhcnNlQW50aHJvcGljU3RyZWFtIiwicHJldmlvdXMiLCJqc29uIiwiY29tcGxldGlvbiIsImRlbHRhIiwic3RyZWFtYWJsZSIsIkFudGhyb3BpY1N0cmVhbSIsImZvcm1hdFN0cmVhbVBhcnQzIiwiQXNzaXN0YW50UmVzcG9uc2UiLCJ0aHJlYWRJZCIsIm1lc3NhZ2VJZCIsInByb2Nlc3MyIiwic2VuZE1lc3NhZ2UiLCJzZW5kRGF0YU1lc3NhZ2UiLCJzZW5kRXJyb3IiLCJleHBlcmltZW50YWxfQXNzaXN0YW50UmVzcG9uc2UiLCJhc0RlbHRhSXRlcmFibGUiLCJleHRyYWN0VGV4dERlbHRhRnJvbUNodW5rIiwiY2h1bmtUZXh0IiwiY2h1bmtKU09OIiwiQVdTQmVkcm9ja0FudGhyb3BpY01lc3NhZ2VzU3RyZWFtIiwiQVdTQmVkcm9ja1N0cmVhbSIsIkFXU0JlZHJvY2tBbnRocm9waWNTdHJlYW0iLCJBV1NCZWRyb2NrQ29oZXJlU3RyZWFtIiwiQVdTQmVkcm9ja0xsYW1hMlN0cmVhbSIsImdlbmVyYXRpb24iLCJ1dGY4RGVjb2RlciIsInByb2Nlc3NMaW5lcyIsImxpbmVzIiwiaXNfZmluaXNoZWQiLCJyZWFkQW5kUHJvY2Vzc0xpbmVzIiwic2VnbWVudCIsImxpbmVzQXJyYXkiLCJwb3AiLCJjcmVhdGVQYXJzZXIyIiwic3RyZWFtYWJsZTIiLCJldmVudFR5cGUiLCJDb2hlcmVTdHJlYW0iLCJzdHJlYW1hYmxlMyIsImNhbmRpZGF0ZXMiLCJmaXJzdFBhcnQiLCJHb29nbGVHZW5lcmF0aXZlQUlTdHJlYW0iLCJjcmVhdGVQYXJzZXIzIiwidHJpbVN0YXJ0T2ZTdHJlYW0iLCJ0b2tlbiIsImdlbmVyYXRlZF90ZXh0IiwiSHVnZ2luZ0ZhY2VTdHJlYW0iLCJJbmtlZXBTdHJlYW0iLCJjaGF0X3Nlc3Npb25faWQiLCJyZWNvcmRzX2NpdGVkIiwiaW5rZWVwRXZlbnRQYXJzZXIiLCJvblJlY29yZHNDaXRlZCIsImlua2VlcE1lc3NhZ2VDaHVuayIsImNvbnRlbnRfY2h1bmsiLCJwYXNzVGhyb3VnaENhbGxiYWNrcyIsImlua2VlcE9uRmluYWxNZXRhZGF0YSIsImxhbmdjaGFpbl9hZGFwdGVyX2V4cG9ydHMiLCJmb3J3YXJkQUlNZXNzYWdlQ2h1bmsiLCJkYXRhU3RyZWFtIiwicmVzcG9uc2VTdHJlYW0iLCJpdGVtIiwibGxhbWFpbmRleF9hZGFwdGVyX2V4cG9ydHMiLCJ0b0RhdGFTdHJlYW0yIiwidG9EYXRhU3RyZWFtUmVzcG9uc2UyIiwidG9SZWFkYWJsZVN0cmVhbSIsIkxhbmdDaGFpblN0cmVhbSIsIndyaXRlciIsIndyaXRhYmxlIiwiZ2V0V3JpdGVyIiwicnVucyIsImhhbmRsZUVycm9yIiwiZSIsInJ1bklkIiwicmVhZHkiLCJhYm9ydCIsImhhbmRsZVN0YXJ0IiwiaGFuZGxlRW5kIiwicmVhZGFibGUiLCJoYW5kbGVycyIsImhhbmRsZUxMTU5ld1Rva2VuIiwiaGFuZGxlTExNU3RhcnQiLCJfbGxtIiwiX3Byb21wdHMiLCJoYW5kbGVMTE1FbmQiLCJfb3V0cHV0IiwiaGFuZGxlTExNRXJyb3IiLCJoYW5kbGVDaGFpblN0YXJ0IiwiX2NoYWluIiwiX2lucHV0cyIsImhhbmRsZUNoYWluRW5kIiwiX291dHB1dHMiLCJoYW5kbGVDaGFpbkVycm9yIiwiaGFuZGxlVG9vbFN0YXJ0IiwiX3Rvb2wiLCJfaW5wdXQiLCJoYW5kbGVUb29sRW5kIiwiaGFuZGxlVG9vbEVycm9yIiwic3RyZWFtYWJsZTQiLCJjaG9pY2VzIiwiTWlzdHJhbFN0cmVhbSIsImNyZWF0ZUNodW5rRGVjb2RlciIsImZvcm1hdFN0cmVhbVBhcnQ0IiwicGFyc2VPcGVuQUlTdHJlYW0iLCJleHRyYWN0IiwiY2h1bmtUb1RleHQiLCJzdHJlYW1hYmxlNSIsImNyZWF0ZWQiLCJnZXREYXRlIiwiY2hvaWNlIiwiZnVuY3Rpb25fY2FsbCIsImZ1bmN0aW9uQ2FsbCIsInRvb2xfY2FsbHMiLCJmdW5jdGlvbiIsImZpbmlzaF9yZWFzb24iLCJpc0Z1bmN0aW9uU3RyZWFtaW5nSW4iLCJfaSIsIl9qIiwiX2siLCJfbCIsIl9tIiwiX24iLCJfbyIsIl9wIiwiX3EiLCJfciIsImlzQ2hhdENvbXBsZXRpb25DaHVuayIsImlzVGV4dCIsImFyZ3VtZW50cyIsImNsZWFudXBBcmd1bWVudHMiLCJpc0NvbXBsZXRpb24iLCJhcmd1bWVudENodW5rIiwiZXNjYXBlZFBhcnRpYWxKc29uIiwicmVwbGFjZSIsIl9faW50ZXJuYWxfX09wZW5BSUZuTWVzc2FnZXNTeW1ib2wiLCJPcGVuQUlTdHJlYW0iLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsImZ1bmN0aW9uQ2FsbFRyYW5zZm9ybWVyIiwiY3JlYXRlRnVuY3Rpb25DYWxsVHJhbnNmb3JtZXIiLCJhZ2dyZWdhdGVkRmluYWxDb21wbGV0aW9uUmVzcG9uc2UiLCJmdW5jdGlvbkNhbGxNZXNzYWdlcyIsInNob3VsZEhhbmRsZUFzRnVuY3Rpb24iLCJwYXlsb2FkIiwibmV3RnVuY3Rpb25DYWxsTWVzc2FnZXMiLCJmdW5jdGlvblJlc3BvbnNlIiwiYXJndW1lbnRzUGF5bG9hZCIsImZ1bmMiLCJyZXNwb25zZUluZGV4IiwidG9vbF9jYWxsX2lkIiwiZnVuY3Rpb25fbmFtZSIsInRvb2xfY2FsbF9yZXN1bHQiLCJ0YyIsImZpbHRlcmVkQ2FsbGJhY2tzIiwib3BlbkFJU3RyZWFtIiwiUmVwbGljYXRlU3RyZWFtIiwiZXZlbnRTdHJlYW0iLCJtZXRob2QiLCJBY2NlcHQiLCJzdHJlYW1Ub1Jlc3BvbnNlIiwicHJvY2Vzc2VkU3RyZWFtIiwiU3RyZWFtaW5nVGV4dFJlc3BvbnNlIiwiZ2VuZXJhdGVJZDIiLCJuYW5vaWQiLCJMYW5nQ2hhaW5BZGFwdGVyIiwiTGxhbWFJbmRleEFkYXB0ZXIiLCJTdHJlYW1EYXRhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/ai/dist/index.mjs\n");

/***/ })

};
;