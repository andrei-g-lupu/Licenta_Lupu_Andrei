"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@ai-sdk";
exports.ids = ["vendor-chunks/@ai-sdk"];
exports.modules = {

/***/ "(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncGeneratorToReadableStream: () => (/* binding */ convertAsyncGeneratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isParseableJson: () => (/* binding */ isParseableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(ssr)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(ssr)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(ssr)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n  return headers.reduce(\n    (combinedHeaders, currentHeaders) => ({\n      ...combinedHeaders,\n      ...currentHeaders != null ? currentHeaders : {}\n    }),\n    {}\n  );\n}\n\n// src/convert-async-generator-to-readable-stream.ts\nfunction convertAsyncGeneratorToReadableStream(stream) {\n  return new ReadableStream({\n    /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */\n    async pull(controller) {\n      try {\n        const { value, done } = await stream.next();\n        if (done) {\n          controller.close();\n        } else {\n          controller.enqueue(value);\n        }\n      } catch (error) {\n        controller.error(error);\n      }\n    },\n    /**\n     * Called when the consumer cancels the stream.\n     */\n    cancel() {\n    }\n  });\n}\n\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n  const headers = {};\n  response.headers.forEach((value, key) => {\n    headers[key] = value;\n  });\n  return headers;\n}\n\n// src/generate-id.ts\n\n\nvar createIdGenerator = ({\n  prefix,\n  size: defaultSize = 7,\n  alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\",\n  separator = \"-\"\n} = {}) => {\n  const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n  if (prefix == null) {\n    return generator;\n  }\n  if (alphabet.includes(separator)) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n      argument: \"separator\",\n      message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n    });\n  }\n  return (size) => `${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n  return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n\n// src/load-api-key.ts\n\nfunction loadApiKey({\n  apiKey,\n  environmentVariableName,\n  apiKeyParameterName = \"apiKey\",\n  description\n}) {\n  if (typeof apiKey === \"string\") {\n    return apiKey;\n  }\n  if (apiKey != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  apiKey = process.env[environmentVariableName];\n  if (apiKey == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof apiKey !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n      message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return apiKey;\n}\n\n// src/load-setting.ts\n\nfunction loadSetting({\n  settingValue,\n  environmentVariableName,\n  settingName,\n  description\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string.`\n    });\n  }\n  if (typeof process === \"undefined\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n    });\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n    });\n  }\n  if (typeof settingValue !== \"string\") {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n      message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n    });\n  }\n  return settingValue;\n}\n\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({\n  settingValue,\n  environmentVariableName\n}) {\n  if (typeof settingValue === \"string\") {\n    return settingValue;\n  }\n  if (settingValue != null || typeof process === \"undefined\") {\n    return void 0;\n  }\n  settingValue = process.env[environmentVariableName];\n  if (settingValue == null || typeof settingValue !== \"string\") {\n    return void 0;\n  }\n  return settingValue;\n}\n\n// src/parse-json.ts\n\n\n\n// src/validate-types.ts\n\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n  return { [validatorSymbol]: true, validate };\n}\nfunction isValidator(value) {\n  return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n  return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n  return validator((value) => {\n    const result = zodSchema.safeParse(value);\n    return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n  });\n}\n\n// src/validate-types.ts\nfunction validateTypes({\n  value,\n  schema: inputSchema\n}) {\n  const result = safeValidateTypes({ value, schema: inputSchema });\n  if (!result.success) {\n    throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error });\n  }\n  return result.value;\n}\nfunction safeValidateTypes({\n  value,\n  schema\n}) {\n  const validator2 = asValidator(schema);\n  try {\n    if (validator2.validate == null) {\n      return { success: true, value };\n    }\n    const result = validator2.validate(value);\n    if (result.success) {\n      return result;\n    }\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: result.error })\n    };\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({ value, cause: error })\n    };\n  }\n}\n\n// src/parse-json.ts\nfunction parseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return value;\n    }\n    return validateTypes({ value, schema });\n  } catch (error) {\n    if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error)) {\n      throw error;\n    }\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error });\n  }\n}\nfunction safeParseJSON({\n  text,\n  schema\n}) {\n  try {\n    const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n    if (schema == null) {\n      return {\n        success: true,\n        value\n      };\n    }\n    return safeValidateTypes({ value, schema });\n  } catch (error) {\n    return {\n      success: false,\n      error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({ text, cause: error })\n    };\n  }\n}\nfunction isParsableJson(input) {\n  try {\n    secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n    return true;\n  } catch (e) {\n    return false;\n  }\n}\nvar isParseableJson = isParsableJson;\n\n// src/post-to-api.ts\n\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n  return Object.fromEntries(\n    Object.entries(record).filter(([_key, value]) => value != null)\n  );\n}\n\n// src/post-to-api.ts\nvar getOriginalFetch = () => globalThis.fetch;\nvar postJsonToApi = async ({\n  url,\n  headers,\n  body,\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n}) => postToApi({\n  url,\n  headers: {\n    \"Content-Type\": \"application/json\",\n    ...headers\n  },\n  body: {\n    content: JSON.stringify(body),\n    values: body\n  },\n  failedResponseHandler,\n  successfulResponseHandler,\n  abortSignal,\n  fetch\n});\nvar postToApi = async ({\n  url,\n  headers = {},\n  body,\n  successfulResponseHandler,\n  failedResponseHandler,\n  abortSignal,\n  fetch = getOriginalFetch()\n}) => {\n  try {\n    const response = await fetch(url, {\n      method: \"POST\",\n      headers: removeUndefinedEntries(headers),\n      body: body.content,\n      signal: abortSignal\n    });\n    const responseHeaders = extractResponseHeaders(response);\n    if (!response.ok) {\n      let errorInformation;\n      try {\n        errorInformation = await failedResponseHandler({\n          response,\n          url,\n          requestBodyValues: body.values\n        });\n      } catch (error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: \"Failed to process error response\",\n          cause: error,\n          statusCode: response.status,\n          url,\n          responseHeaders,\n          requestBodyValues: body.values\n        });\n      }\n      throw errorInformation.value;\n    }\n    try {\n      return await successfulResponseHandler({\n        response,\n        url,\n        requestBodyValues: body.values\n      });\n    } catch (error) {\n      if (error instanceof Error) {\n        if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n          throw error;\n        }\n      }\n      throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: \"Failed to process successful response\",\n        cause: error,\n        statusCode: response.status,\n        url,\n        responseHeaders,\n        requestBodyValues: body.values\n      });\n    }\n  } catch (error) {\n    if (isAbortError(error)) {\n      throw error;\n    }\n    if (error instanceof TypeError && error.message === \"fetch failed\") {\n      const cause = error.cause;\n      if (cause != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n          message: `Cannot connect to API: ${cause.message}`,\n          cause,\n          url,\n          requestBodyValues: body.values,\n          isRetryable: true\n          // retry when network error\n        });\n      }\n    }\n    throw error;\n  }\n};\n\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({\n  errorSchema,\n  errorToMessage,\n  isRetryable\n}) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const responseHeaders = extractResponseHeaders(response);\n  if (responseBody.trim() === \"\") {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n  try {\n    const parsedError = parseJSON({\n      text: responseBody,\n      schema: errorSchema\n    });\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: errorToMessage(parsedError),\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        data: parsedError,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n      })\n    };\n  } catch (parseError) {\n    return {\n      responseHeaders,\n      value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n        message: response.statusText,\n        url,\n        requestBodyValues,\n        statusCode: response.status,\n        responseHeaders,\n        responseBody,\n        isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n      })\n    };\n  }\n};\nvar createEventSourceResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(\n      new TransformStream({\n        transform({ data }, controller) {\n          if (data === \"[DONE]\") {\n            return;\n          }\n          controller.enqueue(\n            safeParseJSON({\n              text: data,\n              schema: chunkSchema\n            })\n          );\n        }\n      })\n    )\n  };\n};\nvar createJsonStreamResponseHandler = (chunkSchema) => async ({ response }) => {\n  const responseHeaders = extractResponseHeaders(response);\n  if (response.body == null) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n  }\n  let buffer = \"\";\n  return {\n    responseHeaders,\n    value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(\n      new TransformStream({\n        transform(chunkText, controller) {\n          if (chunkText.endsWith(\"\\n\")) {\n            controller.enqueue(\n              safeParseJSON({\n                text: buffer + chunkText,\n                schema: chunkSchema\n              })\n            );\n            buffer = \"\";\n          } else {\n            buffer += chunkText;\n          }\n        }\n      })\n    )\n  };\n};\nvar createJsonResponseHandler = (responseSchema) => async ({ response, url, requestBodyValues }) => {\n  const responseBody = await response.text();\n  const parsedResult = safeParseJSON({\n    text: responseBody,\n    schema: responseSchema\n  });\n  const responseHeaders = extractResponseHeaders(response);\n  if (!parsedResult.success) {\n    throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n      message: \"Invalid JSON response\",\n      cause: parsedResult.error,\n      statusCode: response.status,\n      responseHeaders,\n      responseBody,\n      url,\n      requestBodyValues\n    });\n  }\n  return {\n    responseHeaders,\n    value: parsedResult.value\n  };\n};\n\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n  const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n  const latin1string = atob(base64Url);\n  return Uint8Array.from(latin1string, (byte) => byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n  let latin1string = \"\";\n  for (let i = 0; i < array.length; i++) {\n    latin1string += String.fromCodePoint(array[i]);\n  }\n  return btoa(latin1string);\n}\n\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n  return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlLG9DQUFvQztBQUNuRCxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGNBQWM7QUFDOUI7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7O0FBRUE7QUFDd0Q7QUFDTDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ04sb0JBQW9CLGlFQUFjO0FBQ2xDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyxrRUFBb0I7QUFDbEM7QUFDQSxpQ0FBaUMsVUFBVSxzQ0FBc0MsU0FBUztBQUMxRixLQUFLO0FBQ0w7QUFDQSxzQkFBc0IsT0FBTyxFQUFFLFVBQVUsRUFBRSxnQkFBZ0I7QUFDM0Q7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZTtBQUM3QixrQkFBa0IsYUFBYTtBQUMvQixLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsNkRBQWU7QUFDN0Isa0JBQWtCLGFBQWEseUNBQXlDLG9CQUFvQjtBQUM1RixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2REFBZTtBQUM3QixrQkFBa0IsYUFBYSx5Q0FBeUMsb0JBQW9CLHFCQUFxQix5QkFBeUI7QUFDMUksS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDZEQUFlO0FBQzdCLGtCQUFrQixhQUFhLDZDQUE2Qyx5QkFBeUI7QUFDckcsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNvRDtBQUNwRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBZ0I7QUFDOUIsa0JBQWtCLGFBQWE7QUFDL0IsS0FBSztBQUNMO0FBQ0E7QUFDQSxjQUFjLDhEQUFnQjtBQUM5QixrQkFBa0IsYUFBYSx5Q0FBeUMsWUFBWTtBQUNwRixLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw4REFBZ0I7QUFDOUIsa0JBQWtCLGFBQWEseUNBQXlDLFlBQVkscUJBQXFCLHlCQUF5QjtBQUNsSSxLQUFLO0FBQ0w7QUFDQTtBQUNBLGNBQWMsOERBQWdCO0FBQzlCLGtCQUFrQixhQUFhLDZDQUE2Qyx5QkFBeUI7QUFDckcsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFJMEI7QUFDaUI7O0FBRTNDO0FBQ3VEOztBQUV2RDtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsb0NBQW9DLElBQUk7QUFDdEUsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELHFDQUFxQyw0QkFBNEI7QUFDakU7QUFDQSxVQUFVLGlFQUFtQixRQUFRLDRCQUE0QjtBQUNqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxpRUFBbUIsUUFBUSw0QkFBNEI7QUFDcEU7QUFDQSxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWEsaUVBQW1CLFFBQVEscUJBQXFCO0FBQzdEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBLGtCQUFrQixvREFBZ0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCLGVBQWU7QUFDMUMsSUFBSTtBQUNKLFFBQVEsNERBQWMsNEJBQTRCLGlFQUFvQjtBQUN0RTtBQUNBO0FBQ0EsY0FBYyw0REFBYyxHQUFHLG9CQUFvQjtBQUNuRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0Esa0JBQWtCLG9EQUFnQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsZUFBZTtBQUM5QyxJQUFJO0FBQ0o7QUFDQTtBQUNBLGFBQWEsNERBQWMsdUNBQXVDLDREQUFjLEdBQUcsb0JBQW9CO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLG9EQUFnQjtBQUNwQjtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNnRDs7QUFFaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsUUFBUTtBQUNSLG1DQUFtQywwREFBWTtBQUMvQztBQUNBO0FBQ0Esa0JBQWtCLDBEQUFZO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQLE1BQU07QUFDTjtBQUNBLG1DQUFtQywwREFBWTtBQUMvQztBQUNBO0FBQ0E7QUFDQSxnQkFBZ0IsMERBQVk7QUFDNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQiwwREFBWTtBQUM5Qiw2Q0FBNkMsY0FBYztBQUMzRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDeUY7QUFHdEQ7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGNBQWMsa0NBQWtDO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSxpQkFBaUIsMERBQWE7QUFDOUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsaUJBQWlCLDBEQUFhO0FBQzlCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSxVQUFVO0FBQzNFO0FBQ0E7QUFDQSxjQUFjLG9FQUFzQixHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBLDhFQUE4RSw4RUFBdUI7QUFDckc7QUFDQSxvQkFBb0IsTUFBTTtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBLGdFQUFnRSxVQUFVO0FBQzFFO0FBQ0E7QUFDQSxjQUFjLG9FQUFzQixHQUFHO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWU7QUFDZjtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBO0FBQ0E7QUFDQSw2REFBNkQsa0NBQWtDO0FBQy9GO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxjQUFjLDBEQUFhO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLE1BQU0sYUFBYTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFnQ0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJzdF9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvcHJvdmlkZXItdXRpbHMvZGlzdC9pbmRleC5tanM/MjUyNCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvY29tYmluZS1oZWFkZXJzLnRzXG5mdW5jdGlvbiBjb21iaW5lSGVhZGVycyguLi5oZWFkZXJzKSB7XG4gIHJldHVybiBoZWFkZXJzLnJlZHVjZShcbiAgICAoY29tYmluZWRIZWFkZXJzLCBjdXJyZW50SGVhZGVycykgPT4gKHtcbiAgICAgIC4uLmNvbWJpbmVkSGVhZGVycyxcbiAgICAgIC4uLmN1cnJlbnRIZWFkZXJzICE9IG51bGwgPyBjdXJyZW50SGVhZGVycyA6IHt9XG4gICAgfSksXG4gICAge31cbiAgKTtcbn1cblxuLy8gc3JjL2NvbnZlcnQtYXN5bmMtZ2VuZXJhdG9yLXRvLXJlYWRhYmxlLXN0cmVhbS50c1xuZnVuY3Rpb24gY29udmVydEFzeW5jR2VuZXJhdG9yVG9SZWFkYWJsZVN0cmVhbShzdHJlYW0pIHtcbiAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIHdhbnRzIHRvIHB1bGwgbW9yZSBkYXRhIGZyb20gdGhlIHN0cmVhbS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSB7UmVhZGFibGVTdHJlYW1EZWZhdWx0Q29udHJvbGxlcjxUPn0gY29udHJvbGxlciAtIFRoZSBjb250cm9sbGVyIHRvIGVucXVldWUgZGF0YSBpbnRvIHRoZSBzdHJlYW0uXG4gICAgICogQHJldHVybnMge1Byb21pc2U8dm9pZD59XG4gICAgICovXG4gICAgYXN5bmMgcHVsbChjb250cm9sbGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCB7IHZhbHVlLCBkb25lIH0gPSBhd2FpdCBzdHJlYW0ubmV4dCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGNvbnRyb2xsZXIuY2xvc2UoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUodmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICBjb250cm9sbGVyLmVycm9yKGVycm9yKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25zdW1lciBjYW5jZWxzIHRoZSBzdHJlYW0uXG4gICAgICovXG4gICAgY2FuY2VsKCkge1xuICAgIH1cbiAgfSk7XG59XG5cbi8vIHNyYy9leHRyYWN0LXJlc3BvbnNlLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpIHtcbiAgY29uc3QgaGVhZGVycyA9IHt9O1xuICByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcbiAgICBoZWFkZXJzW2tleV0gPSB2YWx1ZTtcbiAgfSk7XG4gIHJldHVybiBoZWFkZXJzO1xufVxuXG4vLyBzcmMvZ2VuZXJhdGUtaWQudHNcbmltcG9ydCB7IEludmFsaWRBcmd1bWVudEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7IGN1c3RvbUFscGhhYmV0IH0gZnJvbSBcIm5hbm9pZC9ub24tc2VjdXJlXCI7XG52YXIgY3JlYXRlSWRHZW5lcmF0b3IgPSAoe1xuICBwcmVmaXgsXG4gIHNpemU6IGRlZmF1bHRTaXplID0gNyxcbiAgYWxwaGFiZXQgPSBcIjAxMjM0NTY3ODlBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6XCIsXG4gIHNlcGFyYXRvciA9IFwiLVwiXG59ID0ge30pID0+IHtcbiAgY29uc3QgZ2VuZXJhdG9yID0gY3VzdG9tQWxwaGFiZXQoYWxwaGFiZXQsIGRlZmF1bHRTaXplKTtcbiAgaWYgKHByZWZpeCA9PSBudWxsKSB7XG4gICAgcmV0dXJuIGdlbmVyYXRvcjtcbiAgfVxuICBpZiAoYWxwaGFiZXQuaW5jbHVkZXMoc2VwYXJhdG9yKSkge1xuICAgIHRocm93IG5ldyBJbnZhbGlkQXJndW1lbnRFcnJvcih7XG4gICAgICBhcmd1bWVudDogXCJzZXBhcmF0b3JcIixcbiAgICAgIG1lc3NhZ2U6IGBUaGUgc2VwYXJhdG9yIFwiJHtzZXBhcmF0b3J9XCIgbXVzdCBub3QgYmUgcGFydCBvZiB0aGUgYWxwaGFiZXQgXCIke2FscGhhYmV0fVwiLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gKHNpemUpID0+IGAke3ByZWZpeH0ke3NlcGFyYXRvcn0ke2dlbmVyYXRvcihzaXplKX1gO1xufTtcbnZhciBnZW5lcmF0ZUlkID0gY3JlYXRlSWRHZW5lcmF0b3IoKTtcblxuLy8gc3JjL2dldC1lcnJvci1tZXNzYWdlLnRzXG5mdW5jdGlvbiBnZXRFcnJvck1lc3NhZ2UoZXJyb3IpIHtcbiAgaWYgKGVycm9yID09IG51bGwpIHtcbiAgICByZXR1cm4gXCJ1bmtub3duIGVycm9yXCI7XG4gIH1cbiAgaWYgKHR5cGVvZiBlcnJvciA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBlcnJvcjtcbiAgfVxuICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgIHJldHVybiBlcnJvci5tZXNzYWdlO1xuICB9XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeShlcnJvcik7XG59XG5cbi8vIHNyYy9pcy1hYm9ydC1lcnJvci50c1xuZnVuY3Rpb24gaXNBYm9ydEVycm9yKGVycm9yKSB7XG4gIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIChlcnJvci5uYW1lID09PSBcIkFib3J0RXJyb3JcIiB8fCBlcnJvci5uYW1lID09PSBcIlRpbWVvdXRFcnJvclwiKTtcbn1cblxuLy8gc3JjL2xvYWQtYXBpLWtleS50c1xuaW1wb3J0IHsgTG9hZEFQSUtleUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRBcGlLZXkoe1xuICBhcGlLZXksXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lLFxuICBhcGlLZXlQYXJhbWV0ZXJOYW1lID0gXCJhcGlLZXlcIixcbiAgZGVzY3JpcHRpb25cbn0pIHtcbiAgaWYgKHR5cGVvZiBhcGlLZXkgPT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gYXBpS2V5O1xuICB9XG4gIGlmIChhcGlLZXkgIT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyLiBFbnZpcm9ubWVudCB2YXJpYWJsZXMgaXMgbm90IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50LmBcbiAgICB9KTtcbiAgfVxuICBhcGlLZXkgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChhcGlLZXkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBMb2FkQVBJS2V5RXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IEFQSSBrZXkgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7YXBpS2V5UGFyYW1ldGVyTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2YgYXBpS2V5ICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLiBUaGUgdmFsdWUgb2YgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlIGlzIG5vdCBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgcmV0dXJuIGFwaUtleTtcbn1cblxuLy8gc3JjL2xvYWQtc2V0dGluZy50c1xuaW1wb3J0IHsgTG9hZFNldHRpbmdFcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5mdW5jdGlvbiBsb2FkU2V0dGluZyh7XG4gIHNldHRpbmdWYWx1ZSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIHNldHRpbmdOYW1lLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgaXMgbWlzc2luZy4gUGFzcyBpdCB1c2luZyB0aGUgJyR7c2V0dGluZ05hbWV9JyBwYXJhbWV0ZXIgb3IgdGhlICR7ZW52aXJvbm1lbnRWYXJpYWJsZU5hbWV9IGVudmlyb25tZW50IHZhcmlhYmxlLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgIHRocm93IG5ldyBMb2FkU2V0dGluZ0Vycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBzZXR0aW5nIG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvbG9hZC1vcHRpb25hbC1zZXR0aW5nLnRzXG5mdW5jdGlvbiBsb2FkT3B0aW9uYWxTZXR0aW5nKHtcbiAgc2V0dGluZ1ZhbHVlLFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZVxufSkge1xuICBpZiAodHlwZW9mIHNldHRpbmdWYWx1ZSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBzZXR0aW5nVmFsdWU7XG4gIH1cbiAgaWYgKHNldHRpbmdWYWx1ZSAhPSBudWxsIHx8IHR5cGVvZiBwcm9jZXNzID09PSBcInVuZGVmaW5lZFwiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICBzZXR0aW5nVmFsdWUgPSBwcm9jZXNzLmVudltlbnZpcm9ubWVudFZhcmlhYmxlTmFtZV07XG4gIGlmIChzZXR0aW5nVmFsdWUgPT0gbnVsbCB8fCB0eXBlb2Ygc2V0dGluZ1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHZvaWQgMDtcbiAgfVxuICByZXR1cm4gc2V0dGluZ1ZhbHVlO1xufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuaW1wb3J0IHtcbiAgSlNPTlBhcnNlRXJyb3IsXG4gIFR5cGVWYWxpZGF0aW9uRXJyb3IgYXMgVHlwZVZhbGlkYXRpb25FcnJvcjJcbn0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCBTZWN1cmVKU09OIGZyb20gXCJzZWN1cmUtanNvbi1wYXJzZVwiO1xuXG4vLyBzcmMvdmFsaWRhdGUtdHlwZXMudHNcbmltcG9ydCB7IFR5cGVWYWxpZGF0aW9uRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvdmFsaWRhdG9yLnRzXG52YXIgdmFsaWRhdG9yU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS52YWxpZGF0b3JcIik7XG5mdW5jdGlvbiB2YWxpZGF0b3IodmFsaWRhdGUpIHtcbiAgcmV0dXJuIHsgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsIHZhbGlkYXRlIH07XG59XG5mdW5jdGlvbiBpc1ZhbGlkYXRvcih2YWx1ZSkge1xuICByZXR1cm4gdHlwZW9mIHZhbHVlID09PSBcIm9iamVjdFwiICYmIHZhbHVlICE9PSBudWxsICYmIHZhbGlkYXRvclN5bWJvbCBpbiB2YWx1ZSAmJiB2YWx1ZVt2YWxpZGF0b3JTeW1ib2xdID09PSB0cnVlICYmIFwidmFsaWRhdGVcIiBpbiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGFzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiBpc1ZhbGlkYXRvcih2YWx1ZSkgPyB2YWx1ZSA6IHpvZFZhbGlkYXRvcih2YWx1ZSk7XG59XG5mdW5jdGlvbiB6b2RWYWxpZGF0b3Ioem9kU2NoZW1hKSB7XG4gIHJldHVybiB2YWxpZGF0b3IoKHZhbHVlKSA9PiB7XG4gICAgY29uc3QgcmVzdWx0ID0gem9kU2NoZW1hLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgfSk7XG59XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuZnVuY3Rpb24gdmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWE6IGlucHV0U2NoZW1hXG59KSB7XG4gIGNvbnN0IHJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYTogaW5wdXRTY2hlbWEgfSk7XG4gIGlmICghcmVzdWx0LnN1Y2Nlc3MpIHtcbiAgICB0aHJvdyBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IHJlc3VsdC5lcnJvciB9KTtcbiAgfVxuICByZXR1cm4gcmVzdWx0LnZhbHVlO1xufVxuZnVuY3Rpb24gc2FmZVZhbGlkYXRlVHlwZXMoe1xuICB2YWx1ZSxcbiAgc2NoZW1hXG59KSB7XG4gIGNvbnN0IHZhbGlkYXRvcjIgPSBhc1ZhbGlkYXRvcihzY2hlbWEpO1xuICB0cnkge1xuICAgIGlmICh2YWxpZGF0b3IyLnZhbGlkYXRlID09IG51bGwpIHtcbiAgICAgIHJldHVybiB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlIH07XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHZhbGlkYXRvcjIudmFsaWRhdGUodmFsdWUpO1xuICAgIGlmIChyZXN1bHQuc3VjY2Vzcykge1xuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiBlcnJvciB9KVxuICAgIH07XG4gIH1cbn1cblxuLy8gc3JjL3BhcnNlLWpzb24udHNcbmZ1bmN0aW9uIHBhcnNlSlNPTih7XG4gIHRleHQsXG4gIHNjaGVtYVxufSkge1xuICB0cnkge1xuICAgIGNvbnN0IHZhbHVlID0gU2VjdXJlSlNPTi5wYXJzZSh0ZXh0KTtcbiAgICBpZiAoc2NoZW1hID09IG51bGwpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hIH0pO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChKU09OUGFyc2VFcnJvci5pc0pTT05QYXJzZUVycm9yKGVycm9yKSB8fCBUeXBlVmFsaWRhdGlvbkVycm9yMi5pc1R5cGVWYWxpZGF0aW9uRXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEpTT05QYXJzZUVycm9yKHsgdGV4dCwgY2F1c2U6IGVycm9yIH0pO1xuICB9XG59XG5mdW5jdGlvbiBzYWZlUGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBTZWN1cmVKU09OLnBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgc3VjY2VzczogdHJ1ZSxcbiAgICAgICAgdmFsdWVcbiAgICAgIH07XG4gICAgfVxuICAgIHJldHVybiBzYWZlVmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHN1Y2Nlc3M6IGZhbHNlLFxuICAgICAgZXJyb3I6IEpTT05QYXJzZUVycm9yLmlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpID8gZXJyb3IgOiBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSlcbiAgICB9O1xuICB9XG59XG5mdW5jdGlvbiBpc1BhcnNhYmxlSnNvbihpbnB1dCkge1xuICB0cnkge1xuICAgIFNlY3VyZUpTT04ucGFyc2UoaW5wdXQpO1xuICAgIHJldHVybiB0cnVlO1xuICB9IGNhdGNoIChlKSB7XG4gICAgcmV0dXJuIGZhbHNlO1xuICB9XG59XG52YXIgaXNQYXJzZWFibGVKc29uID0gaXNQYXJzYWJsZUpzb247XG5cbi8vIHNyYy9wb3N0LXRvLWFwaS50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcblxuLy8gc3JjL3JlbW92ZS11bmRlZmluZWQtZW50cmllcy50c1xuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRW50cmllcyhyZWNvcmQpIHtcbiAgcmV0dXJuIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICBPYmplY3QuZW50cmllcyhyZWNvcmQpLmZpbHRlcigoW19rZXksIHZhbHVlXSkgPT4gdmFsdWUgIT0gbnVsbClcbiAgKTtcbn1cblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGdsb2JhbFRoaXMuZmV0Y2g7XG52YXIgcG9zdEpzb25Ub0FwaSA9IGFzeW5jICh7XG4gIHVybCxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2hcbn0pID0+IHBvc3RUb0FwaSh7XG4gIHVybCxcbiAgaGVhZGVyczoge1xuICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgIC4uLmhlYWRlcnNcbiAgfSxcbiAgYm9keToge1xuICAgIGNvbnRlbnQ6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIHZhbHVlczogYm9keVxuICB9LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSk7XG52YXIgcG9zdFRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzID0ge30sXG4gIGJvZHksXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSA9PiB7XG4gIHRyeSB7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaCh1cmwsIHtcbiAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICBoZWFkZXJzOiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKGhlYWRlcnMpLFxuICAgICAgYm9keTogYm9keS5jb250ZW50LFxuICAgICAgc2lnbmFsOiBhYm9ydFNpZ25hbFxuICAgIH0pO1xuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGxldCBlcnJvckluZm9ybWF0aW9uO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZXJyb3JJbmZvcm1hdGlvbiA9IGF3YWl0IGZhaWxlZFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgICAgdXJsLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBcIkZhaWxlZCB0byBwcm9jZXNzIGVycm9yIHJlc3BvbnNlXCIsXG4gICAgICAgICAgY2F1c2U6IGVycm9yLFxuICAgICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHRocm93IGVycm9ySW5mb3JtYXRpb24udmFsdWU7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICByZXR1cm4gYXdhaXQgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcih7XG4gICAgICAgIHJlc3BvbnNlLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpIHx8IEFQSUNhbGxFcnJvci5pc0FQSUNhbGxFcnJvcihlcnJvcikpIHtcbiAgICAgICAgICB0aHJvdyBlcnJvcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcih7XG4gICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3Mgc3VjY2Vzc2Z1bCByZXNwb25zZVwiLFxuICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzOiBib2R5LnZhbHVlc1xuICAgICAgfSk7XG4gICAgfVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChpc0Fib3J0RXJyb3IoZXJyb3IpKSB7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9XG4gICAgaWYgKGVycm9yIGluc3RhbmNlb2YgVHlwZUVycm9yICYmIGVycm9yLm1lc3NhZ2UgPT09IFwiZmV0Y2ggZmFpbGVkXCIpIHtcbiAgICAgIGNvbnN0IGNhdXNlID0gZXJyb3IuY2F1c2U7XG4gICAgICBpZiAoY2F1c2UgIT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgICBtZXNzYWdlOiBgQ2Fubm90IGNvbm5lY3QgdG8gQVBJOiAke2NhdXNlLm1lc3NhZ2V9YCxcbiAgICAgICAgICBjYXVzZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzLFxuICAgICAgICAgIGlzUmV0cnlhYmxlOiB0cnVlXG4gICAgICAgICAgLy8gcmV0cnkgd2hlbiBuZXR3b3JrIGVycm9yXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cbiAgICB0aHJvdyBlcnJvcjtcbiAgfVxufTtcblxuLy8gc3JjL3Jlc3BvbnNlLWhhbmRsZXIudHNcbmltcG9ydCB7IEFQSUNhbGxFcnJvciBhcyBBUElDYWxsRXJyb3IyLCBFbXB0eVJlc3BvbnNlQm9keUVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmltcG9ydCB7XG4gIEV2ZW50U291cmNlUGFyc2VyU3RyZWFtXG59IGZyb20gXCJldmVudHNvdXJjZS1wYXJzZXIvc3RyZWFtXCI7XG52YXIgY3JlYXRlSnNvbkVycm9yUmVzcG9uc2VIYW5kbGVyID0gKHtcbiAgZXJyb3JTY2hlbWEsXG4gIGVycm9yVG9NZXNzYWdlLFxuICBpc1JldHJ5YWJsZVxufSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2VCb2R5LnRyaW0oKSA9PT0gXCJcIikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG4gIHRyeSB7XG4gICAgY29uc3QgcGFyc2VkRXJyb3IgPSBwYXJzZUpTT04oe1xuICAgICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgICAgc2NoZW1hOiBlcnJvclNjaGVtYVxuICAgIH0pO1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiBlcnJvclRvTWVzc2FnZShwYXJzZWRFcnJvciksXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGRhdGE6IHBhcnNlZEVycm9yLFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlLCBwYXJzZWRFcnJvcilcbiAgICAgIH0pXG4gICAgfTtcbiAgfSBjYXRjaCAocGFyc2VFcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICB2YWx1ZTogbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgICBtZXNzYWdlOiByZXNwb25zZS5zdGF0dXNUZXh0LFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgICBpc1JldHJ5YWJsZTogaXNSZXRyeWFibGUgPT0gbnVsbCA/IHZvaWQgMCA6IGlzUmV0cnlhYmxlKHJlc3BvbnNlKVxuICAgICAgfSlcbiAgICB9O1xuICB9XG59O1xudmFyIGNyZWF0ZUV2ZW50U291cmNlUmVzcG9uc2VIYW5kbGVyID0gKGNodW5rU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAocmVzcG9uc2UuYm9keSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IEVtcHR5UmVzcG9uc2VCb2R5RXJyb3Ioe30pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChuZXcgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0oKSkucGlwZVRocm91Z2goXG4gICAgICBuZXcgVHJhbnNmb3JtU3RyZWFtKHtcbiAgICAgICAgdHJhbnNmb3JtKHsgZGF0YSB9LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGRhdGEgPT09IFwiW0RPTkVdXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgc2FmZVBhcnNlSlNPTih7XG4gICAgICAgICAgICAgIHRleHQ6IGRhdGEsXG4gICAgICAgICAgICAgIHNjaGVtYTogY2h1bmtTY2hlbWFcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApXG4gIH07XG59O1xudmFyIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgbGV0IGJ1ZmZlciA9IFwiXCI7XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oY2h1bmtUZXh0LCBjb250cm9sbGVyKSB7XG4gICAgICAgICAgaWYgKGNodW5rVGV4dC5lbmRzV2l0aChcIlxcblwiKSkge1xuICAgICAgICAgICAgY29udHJvbGxlci5lbnF1ZXVlKFxuICAgICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgICB0ZXh0OiBidWZmZXIgKyBjaHVua1RleHQsXG4gICAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGJ1ZmZlciA9IFwiXCI7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGJ1ZmZlciArPSBjaHVua1RleHQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlciA9IChyZXNwb25zZVNjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UsIHVybCwgcmVxdWVzdEJvZHlWYWx1ZXMgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUJvZHkgPSBhd2FpdCByZXNwb25zZS50ZXh0KCk7XG4gIGNvbnN0IHBhcnNlZFJlc3VsdCA9IHNhZmVQYXJzZUpTT04oe1xuICAgIHRleHQ6IHJlc3BvbnNlQm9keSxcbiAgICBzY2hlbWE6IHJlc3BvbnNlU2NoZW1hXG4gIH0pO1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKCFwYXJzZWRSZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3IyKHtcbiAgICAgIG1lc3NhZ2U6IFwiSW52YWxpZCBKU09OIHJlc3BvbnNlXCIsXG4gICAgICBjYXVzZTogcGFyc2VkUmVzdWx0LmVycm9yLFxuICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgcmVzcG9uc2VCb2R5LFxuICAgICAgdXJsLFxuICAgICAgcmVxdWVzdEJvZHlWYWx1ZXNcbiAgICB9KTtcbiAgfVxuICByZXR1cm4ge1xuICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICB2YWx1ZTogcGFyc2VkUmVzdWx0LnZhbHVlXG4gIH07XG59O1xuXG4vLyBzcmMvdWludDgtdXRpbHMudHNcbnZhciB7IGJ0b2EsIGF0b2IgfSA9IGdsb2JhbFRoaXM7XG5mdW5jdGlvbiBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5KGJhc2U2NFN0cmluZykge1xuICBjb25zdCBiYXNlNjRVcmwgPSBiYXNlNjRTdHJpbmcucmVwbGFjZSgvLS9nLCBcIitcIikucmVwbGFjZSgvXy9nLCBcIi9cIik7XG4gIGNvbnN0IGxhdGluMXN0cmluZyA9IGF0b2IoYmFzZTY0VXJsKTtcbiAgcmV0dXJuIFVpbnQ4QXJyYXkuZnJvbShsYXRpbjFzdHJpbmcsIChieXRlKSA9PiBieXRlLmNvZGVQb2ludEF0KDApKTtcbn1cbmZ1bmN0aW9uIGNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQoYXJyYXkpIHtcbiAgbGV0IGxhdGluMXN0cmluZyA9IFwiXCI7XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgYXJyYXkubGVuZ3RoOyBpKyspIHtcbiAgICBsYXRpbjFzdHJpbmcgKz0gU3RyaW5nLmZyb21Db2RlUG9pbnQoYXJyYXlbaV0pO1xuICB9XG4gIHJldHVybiBidG9hKGxhdGluMXN0cmluZyk7XG59XG5cbi8vIHNyYy93aXRob3V0LXRyYWlsaW5nLXNsYXNoLnRzXG5mdW5jdGlvbiB3aXRob3V0VHJhaWxpbmdTbGFzaCh1cmwpIHtcbiAgcmV0dXJuIHVybCA9PSBudWxsID8gdm9pZCAwIDogdXJsLnJlcGxhY2UoL1xcLyQvLCBcIlwiKTtcbn1cbmV4cG9ydCB7XG4gIGFzVmFsaWRhdG9yLFxuICBjb21iaW5lSGVhZGVycyxcbiAgY29udmVydEFzeW5jR2VuZXJhdG9yVG9SZWFkYWJsZVN0cmVhbSxcbiAgY29udmVydEJhc2U2NFRvVWludDhBcnJheSxcbiAgY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NCxcbiAgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUlkR2VuZXJhdG9yLFxuICBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIsXG4gIGNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIsXG4gIGV4dHJhY3RSZXNwb25zZUhlYWRlcnMsXG4gIGdlbmVyYXRlSWQsXG4gIGdldEVycm9yTWVzc2FnZSxcbiAgaXNBYm9ydEVycm9yLFxuICBpc1BhcnNhYmxlSnNvbixcbiAgaXNQYXJzZWFibGVKc29uLFxuICBpc1ZhbGlkYXRvcixcbiAgbG9hZEFwaUtleSxcbiAgbG9hZE9wdGlvbmFsU2V0dGluZyxcbiAgbG9hZFNldHRpbmcsXG4gIHBhcnNlSlNPTixcbiAgcG9zdEpzb25Ub0FwaSxcbiAgcG9zdFRvQXBpLFxuICBzYWZlUGFyc2VKU09OLFxuICBzYWZlVmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdGVUeXBlcyxcbiAgdmFsaWRhdG9yLFxuICB2YWxpZGF0b3JTeW1ib2wsXG4gIHdpdGhvdXRUcmFpbGluZ1NsYXNoLFxuICB6b2RWYWxpZGF0b3Jcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n  /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */\n  constructor({\n    name: name14,\n    message,\n    cause\n  }) {\n    super(message);\n    this[_a] = true;\n    this.name = name14;\n    this.cause = cause;\n  }\n  /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */\n  static isInstance(error) {\n    return _AISDKError.hasMarker(error, marker);\n  }\n  static hasMarker(error, marker15) {\n    const markerSymbol = Symbol.for(marker15);\n    return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n  }\n  /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message\n    };\n  }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n  constructor({\n    message,\n    url,\n    requestBodyValues,\n    statusCode,\n    responseHeaders,\n    responseBody,\n    cause,\n    isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500),\n    // server error\n    data\n  }) {\n    super({ name, message, cause });\n    this[_a2] = true;\n    this.url = url;\n    this.requestBodyValues = requestBodyValues;\n    this.statusCode = statusCode;\n    this.responseHeaders = responseHeaders;\n    this.responseBody = responseBody;\n    this.isRetryable = isRetryable;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker2);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isAPICallError(error) {\n    return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      url: this.url,\n      requestBodyValues: this.requestBodyValues,\n      statusCode: this.statusCode,\n      responseHeaders: this.responseHeaders,\n      responseBody: this.responseBody,\n      cause: this.cause,\n      isRetryable: this.isRetryable,\n      data: this.data\n    };\n  }\n};\n_a2 = symbol2;\n\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message = \"Empty response body\" } = {}) {\n    super({ name: name2, message });\n    this[_a3] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker3);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isEmptyResponseBodyError(error) {\n    return error instanceof Error && error.name === name2;\n  }\n};\n_a3 = symbol3;\n\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n  if (error == null) {\n    return \"unknown error\";\n  }\n  if (typeof error === \"string\") {\n    return error;\n  }\n  if (error instanceof Error) {\n    return error.message;\n  }\n  return JSON.stringify(error);\n}\n\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n  constructor({\n    message,\n    cause,\n    argument\n  }) {\n    super({ name: name3, message, cause });\n    this[_a4] = true;\n    this.argument = argument;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker4);\n  }\n};\n_a4 = symbol4;\n\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n  constructor({\n    prompt: prompt2,\n    message,\n    cause\n  }) {\n    super({ name: name4, message: `Invalid prompt: ${message}`, cause });\n    this[_a5] = true;\n    this.prompt = prompt2;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker5);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidPromptError(error) {\n    return error instanceof Error && error.name === name4 && prompt != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      prompt: this.prompt\n    };\n  }\n};\n_a5 = symbol5;\n\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n  constructor({\n    data,\n    message = `Invalid response data: ${JSON.stringify(data)}.`\n  }) {\n    super({ name: name5, message });\n    this[_a6] = true;\n    this.data = data;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker6);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isInvalidResponseDataError(error) {\n    return error instanceof Error && error.name === name5 && error.data != null;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      data: this.data\n    };\n  }\n};\n_a6 = symbol6;\n\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n  constructor({ text, cause }) {\n    super({\n      name: name6,\n      message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a7] = true;\n    this.text = text;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker7);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isJSONParseError(error) {\n    return error instanceof Error && error.name === name6 && \"text\" in error && typeof error.text === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      valueText: this.text\n    };\n  }\n};\n_a7 = symbol7;\n\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name7, message });\n    this[_a8] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker8);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadAPIKeyError(error) {\n    return error instanceof Error && error.name === name7;\n  }\n};\n_a8 = symbol8;\n\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n  // used in isInstance\n  constructor({ message }) {\n    super({ name: name8, message });\n    this[_a9] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker9);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isLoadSettingError(error) {\n    return error instanceof Error && error.name === name8;\n  }\n};\n_a9 = symbol9;\n\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n  // used in isInstance\n  constructor({\n    message = \"No content generated.\"\n  } = {}) {\n    super({ name: name9, message });\n    this[_a10] = true;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker10);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isNoContentGeneratedError(error) {\n    return error instanceof Error && error.name === name9;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      cause: this.cause,\n      message: this.message,\n      stack: this.stack\n    };\n  }\n};\n_a10 = symbol10;\n\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n  constructor({\n    errorName = name10,\n    modelId,\n    modelType,\n    message = `No such ${modelType}: ${modelId}`\n  }) {\n    super({ name: errorName, message });\n    this[_a11] = true;\n    this.modelId = modelId;\n    this.modelType = modelType;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker11);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isNoSuchModelError(error) {\n    return error instanceof Error && error.name === name10 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      modelId: this.modelId,\n      modelType: this.modelType\n    };\n  }\n};\n_a11 = symbol11;\n\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n  constructor(options) {\n    super({\n      name: name11,\n      message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n    });\n    this[_a12] = true;\n    this.provider = options.provider;\n    this.modelId = options.modelId;\n    this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n    this.values = options.values;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker12);\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTooManyEmbeddingValuesForCallError(error) {\n    return error instanceof Error && error.name === name11 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      provider: this.provider,\n      modelId: this.modelId,\n      maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n      values: this.values\n    };\n  }\n};\n_a12 = symbol12;\n\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n  constructor({ value, cause }) {\n    super({\n      name: name12,\n      message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n      cause\n    });\n    this[_a13] = true;\n    this.value = value;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker13);\n  }\n  /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */\n  static wrap({\n    value,\n    cause\n  }) {\n    return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({ value, cause });\n  }\n  /**\n   * @deprecated use `isInstance` instead\n   */\n  static isTypeValidationError(error) {\n    return error instanceof Error && error.name === name12;\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      cause: this.cause,\n      stack: this.stack,\n      value: this.value\n    };\n  }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n  constructor({ functionality }) {\n    super({\n      name: name13,\n      message: `'${functionality}' functionality not supported.`\n    });\n    this[_a14] = true;\n    this.functionality = functionality;\n  }\n  static isInstance(error) {\n    return AISDKError.hasMarker(error, marker14);\n  }\n  /**\n   * @deprecated Use isInstance instead.\n   */\n  static isUnsupportedFunctionalityError(error) {\n    return error instanceof Error && error.name === name13 && typeof error.functionality === \"string\";\n  }\n  /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */\n  toJSON() {\n    return {\n      name: this.name,\n      message: this.message,\n      stack: this.stack,\n      functionality: this.functionality\n    };\n  }\n};\n_a14 = symbol14;\n\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n  if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n    return true;\n  }\n  if (Array.isArray(value)) {\n    return value.every(isJSONValue);\n  }\n  if (typeof value === \"object\") {\n    return Object.entries(value).every(\n      ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n    );\n  }\n  return false;\n}\nfunction isJSONArray(value) {\n  return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n  return value != null && typeof value === \"object\" && Object.entries(value).every(\n    ([key, val]) => typeof key === \"string\" && isJSONValue(val)\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCLGFBQWEsUUFBUTtBQUNyQixhQUFhLFFBQVE7QUFDckIsYUFBYSxTQUFTO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFNBQVM7QUFDdEIsZUFBZSxTQUFTO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZSxRQUFRO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLEtBQUs7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSCxZQUFZLHNCQUFzQjtBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUNBQWlDLE1BQU07QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0Isa0NBQWtDLElBQUk7QUFDdEQsWUFBWSxzQkFBc0I7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQW9CRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcnN0X2NoYXRib3QvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcz82OGM4Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvYWktc2RrLWVycm9yLnRzXG52YXIgbWFya2VyID0gXCJ2ZXJjZWwuYWkuZXJyb3JcIjtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2E7XG52YXIgX0FJU0RLRXJyb3IgPSBjbGFzcyBfQUlTREtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbcGFyYW1zLmNhdXNlXSAtIFRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiBuYW1lMTQsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUxNDtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBfQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbiAgc3RhdGljIGhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpIHtcbiAgICBjb25zdCBtYXJrZXJTeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbiAgICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgbWFya2VyU3ltYm9sIGluIGVycm9yICYmIHR5cGVvZiBlcnJvclttYXJrZXJTeW1ib2xdID09PSBcImJvb2xlYW5cIiAmJiBlcnJvclttYXJrZXJTeW1ib2xdID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlcnJvcidzIG5hbWUsIG1lc3NhZ2UsIGFuZCBjYXVzZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzQVBJQ2FsbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZSAmJiB0eXBlb2YgZXJyb3IudXJsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5yZXF1ZXN0Qm9keVZhbHVlcyA9PT0gXCJvYmplY3RcIiAmJiAoZXJyb3Iuc3RhdHVzQ29kZSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5zdGF0dXNDb2RlID09PSBcIm51bWJlclwiKSAmJiAoZXJyb3IucmVzcG9uc2VIZWFkZXJzID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJvYmplY3RcIikgJiYgKGVycm9yLnJlc3BvbnNlQm9keSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5yZXNwb25zZUJvZHkgPT09IFwic3RyaW5nXCIpICYmIChlcnJvci5jYXVzZSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5jYXVzZSA9PT0gXCJvYmplY3RcIikgJiYgdHlwZW9mIGVycm9yLmlzUmV0cnlhYmxlID09PSBcImJvb2xlYW5cIiAmJiAoZXJyb3IuZGF0YSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5kYXRhID09PSBcIm9iamVjdFwiKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlczogdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHJlc3BvbnNlSGVhZGVyczogdGhpcy5yZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHk6IHRoaXMucmVzcG9uc2VCb2R5LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBpc1JldHJ5YWJsZTogdGhpcy5pc1JldHJ5YWJsZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyBzcmMvZXJyb3JzL2VtcHR5LXJlc3BvbnNlLWJvZHktZXJyb3IudHNcbnZhciBuYW1lMiA9IFwiQUlfRW1wdHlSZXNwb25zZUJvZHlFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgRW1wdHlSZXNwb25zZUJvZHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIkVtcHR5IHJlc3BvbnNlIGJvZHlcIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0VtcHR5UmVzcG9uc2VCb2R5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMjtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdDogcHJvbXB0MixcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0MjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFByb21wdEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgcHJvbXB0ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHByb21wdDogdGhpcy5wcm9tcHRcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLXJlc3BvbnNlLWRhdGEtZXJyb3IudHNcbnZhciBuYW1lNSA9IFwiQUlfSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgcmVzcG9uc2UgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRSZXNwb25zZURhdGFFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIGVycm9yLmRhdGEgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNiAmJiBcInRleHRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IudGV4dCA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB2YWx1ZVRleHQ6IHRoaXMudGV4dFxuICAgIH07XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkQVBJS2V5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNztcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1zZXR0aW5nLWVycm9yLnRzXG52YXIgbmFtZTggPSBcIkFJX0xvYWRTZXR0aW5nRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIExvYWRTZXR0aW5nRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjkpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTG9hZFNldHRpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU4O1xuICB9XG59O1xuX2E5ID0gc3ltYm9sOTtcblxuLy8gc3JjL2Vycm9ycy9uby1jb250ZW50LWdlbmVyYXRlZC1lcnJvci50c1xudmFyIG5hbWU5ID0gXCJBSV9Ob0NvbnRlbnRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIE5vQ29udGVudEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBjb250ZW50IGdlbmVyYXRlZC5cIlxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU5O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIHNyYy9lcnJvcnMvbm8tc3VjaC1tb2RlbC1lcnJvci50c1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBOb1N1Y2hNb2RlbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVycm9yTmFtZSA9IG5hbWUxMCxcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggJHttb2RlbFR5cGV9OiAke21vZGVsSWR9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBlcnJvck5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTExXSA9IHRydWU7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLm1vZGVsVHlwZSA9IG1vZGVsVHlwZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaE1vZGVsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTAgJiYgdHlwZW9mIGVycm9yLm1vZGVsSWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLm1vZGVsVHlwZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbW9kZWxUeXBlOiB0aGlzLm1vZGVsVHlwZVxuICAgIH07XG4gIH1cbn07XG5fYTExID0gc3ltYm9sMTE7XG5cbi8vIHNyYy9lcnJvcnMvdG9vLW1hbnktZW1iZWRkaW5nLXZhbHVlcy1mb3ItY2FsbC1lcnJvci50c1xudmFyIG5hbWUxMSA9IFwiQUlfVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjEyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDEyID0gU3ltYm9sLmZvcihtYXJrZXIxMik7XG52YXIgX2ExMjtcbnZhciBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMSxcbiAgICAgIG1lc3NhZ2U6IGBUb28gbWFueSB2YWx1ZXMgZm9yIGEgc2luZ2xlIGVtYmVkZGluZyBjYWxsLiBUaGUgJHtvcHRpb25zLnByb3ZpZGVyfSBtb2RlbCBcIiR7b3B0aW9ucy5tb2RlbElkfVwiIGNhbiBvbmx5IGVtYmVkIHVwIHRvICR7b3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbH0gdmFsdWVzIHBlciBjYWxsLCBidXQgJHtvcHRpb25zLnZhbHVlcy5sZW5ndGh9IHZhbHVlcyB3ZXJlIHByb3ZpZGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0aW9ucy5wcm92aWRlcjtcbiAgICB0aGlzLm1vZGVsSWQgPSBvcHRpb25zLm1vZGVsSWQ7XG4gICAgdGhpcy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG9wdGlvbnMubWF4RW1iZWRkaW5nc1BlckNhbGw7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1Rvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTEgJiYgXCJwcm92aWRlclwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiAmJiBcIm1vZGVsSWRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiBcIm1heEVtYmVkZGluZ3NQZXJDYWxsXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1heEVtYmVkZGluZ3NQZXJDYWxsID09PSBcIm51bWJlclwiICYmIFwidmFsdWVzXCIgaW4gZXJyb3IgJiYgQXJyYXkuaXNBcnJheShlcnJvci52YWx1ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1heEVtYmVkZGluZ3NQZXJDYWxsOiB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgIH07XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNUeXBlVmFsaWRhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEyO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IGZ1bmN0aW9uYWxpdHkgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMyxcbiAgICAgIG1lc3NhZ2U6IGAnJHtmdW5jdGlvbmFsaXR5fScgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTRdID0gdHJ1ZTtcbiAgICB0aGlzLmZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbmFsaXR5O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMyAmJiB0eXBlb2YgZXJyb3IuZnVuY3Rpb25hbGl0eSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZnVuY3Rpb25hbGl0eTogdGhpcy5mdW5jdGlvbmFsaXR5XG4gICAgfTtcbiAgfVxufTtcbl9hMTQgPSBzeW1ib2wxNDtcblxuLy8gc3JjL2pzb24tdmFsdWUvaXMtanNvbi50c1xuZnVuY3Rpb24gaXNKU09OVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0pTT05BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoaXNKU09OVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNKU09OT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgKFtrZXksIHZhbF0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgaXNKU09OVmFsdWUodmFsKVxuICApO1xufVxuZXhwb3J0IHtcbiAgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBpc0pTT05WYWx1ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs":
/*!***************************************************!*\
  !*** ./node_modules/@ai-sdk/react/dist/index.mjs ***!
  \***************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   experimental_useAssistant: () => (/* binding */ experimental_useAssistant),\n/* harmony export */   experimental_useObject: () => (/* binding */ experimental_useObject),\n/* harmony export */   useAssistant: () => (/* binding */ useAssistant),\n/* harmony export */   useChat: () => (/* binding */ useChat),\n/* harmony export */   useCompletion: () => (/* binding */ useCompletion)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @ai-sdk/ui-utils */ \"(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var swr__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! swr */ \"(ssr)/./node_modules/swr/dist/core/index.mjs\");\n/* harmony import */ var throttleit__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! throttleit */ \"(ssr)/./node_modules/throttleit/index.js\");\n// src/use-assistant.ts\n\n\n\nvar getOriginalFetch = () => fetch;\nfunction useAssistant({\n  api,\n  threadId: threadIdParam,\n  credentials,\n  headers,\n  body,\n  onError,\n  fetch: fetch2\n}) {\n  const [messages, setMessages] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"\");\n  const [currentThreadId, setCurrentThreadId] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\n    void 0\n  );\n  const [status, setStatus] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(\"awaiting_message\");\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  const handleInputChange = (event) => {\n    setInput(event.target.value);\n  };\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const append = async (message, requestOptions) => {\n    var _a, _b;\n    setStatus(\"in_progress\");\n    setMessages((messages2) => {\n      var _a2;\n      return [\n        ...messages2,\n        {\n          ...message,\n          id: (_a2 = message.id) != null ? _a2 : (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.generateId)()\n        }\n      ];\n    });\n    setInput(\"\");\n    const abortController = new AbortController();\n    try {\n      abortControllerRef.current = abortController;\n      const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch();\n      const response = await actualFetch(api, {\n        method: \"POST\",\n        credentials,\n        signal: abortController.signal,\n        headers: { \"Content-Type\": \"application/json\", ...headers },\n        body: JSON.stringify({\n          ...body,\n          // always use user-provided threadId when available:\n          threadId: (_a = threadIdParam != null ? threadIdParam : currentThreadId) != null ? _a : null,\n          message: message.content,\n          // optional request data:\n          data: requestOptions == null ? void 0 : requestOptions.data\n        })\n      });\n      if (!response.ok) {\n        throw new Error(\n          (_b = await response.text()) != null ? _b : \"Failed to fetch the assistant response.\"\n        );\n      }\n      if (response.body == null) {\n        throw new Error(\"The response body is empty.\");\n      }\n      for await (const { type, value } of (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.readDataStream)(\n        response.body.getReader()\n      )) {\n        switch (type) {\n          case \"assistant_message\": {\n            setMessages((messages2) => [\n              ...messages2,\n              {\n                id: value.id,\n                role: value.role,\n                content: value.content[0].text.value\n              }\n            ]);\n            break;\n          }\n          case \"text\": {\n            setMessages((messages2) => {\n              const lastMessage = messages2[messages2.length - 1];\n              return [\n                ...messages2.slice(0, messages2.length - 1),\n                {\n                  id: lastMessage.id,\n                  role: lastMessage.role,\n                  content: lastMessage.content + value\n                }\n              ];\n            });\n            break;\n          }\n          case \"data_message\": {\n            setMessages((messages2) => {\n              var _a2;\n              return [\n                ...messages2,\n                {\n                  id: (_a2 = value.id) != null ? _a2 : (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.generateId)(),\n                  role: \"data\",\n                  content: \"\",\n                  data: value.data\n                }\n              ];\n            });\n            break;\n          }\n          case \"assistant_control_data\": {\n            setCurrentThreadId(value.threadId);\n            setMessages((messages2) => {\n              const lastMessage = messages2[messages2.length - 1];\n              lastMessage.id = value.messageId;\n              return [...messages2.slice(0, messages2.length - 1), lastMessage];\n            });\n            break;\n          }\n          case \"error\": {\n            setError(new Error(value));\n            break;\n          }\n        }\n      }\n    } catch (error2) {\n      if ((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error2) && abortController.signal.aborted) {\n        abortControllerRef.current = null;\n        return;\n      }\n      if (onError && error2 instanceof Error) {\n        onError(error2);\n      }\n      setError(error2);\n    } finally {\n      abortControllerRef.current = null;\n      setStatus(\"awaiting_message\");\n    }\n  };\n  const submitMessage = async (event, requestOptions) => {\n    var _a;\n    (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n    if (input === \"\") {\n      return;\n    }\n    append({ role: \"user\", content: input }, requestOptions);\n  };\n  const setThreadId = (threadId) => {\n    setCurrentThreadId(threadId);\n    setMessages([]);\n  };\n  return {\n    append,\n    messages,\n    setMessages,\n    threadId: currentThreadId,\n    setThreadId,\n    input,\n    setInput,\n    handleInputChange,\n    submitMessage,\n    status,\n    error,\n    stop\n  };\n}\nvar experimental_useAssistant = useAssistant;\n\n// src/use-chat.ts\n\n\n\n\n// src/throttle.ts\n\nfunction throttle(fn, waitMs) {\n  return waitMs != null ? throttleit__WEBPACK_IMPORTED_MODULE_4__(fn, waitMs) : fn;\n}\n\n// src/use-chat.ts\nvar getStreamedResponse = async (api, chatRequest, mutate, mutateStreamData, existingDataRef, extraMetadataRef, messagesRef, abortControllerRef, generateId2, streamProtocol, onFinish, onResponse, onToolCall, sendExtraMessageFields, experimental_prepareRequestBody, fetch2, keepLastMessageOnError) => {\n  var _a;\n  const previousMessages = messagesRef.current;\n  mutate(chatRequest.messages, false);\n  const constructedMessagesPayload = sendExtraMessageFields ? chatRequest.messages : chatRequest.messages.map(\n    ({\n      role,\n      content,\n      experimental_attachments,\n      name,\n      data,\n      annotations,\n      toolInvocations,\n      function_call,\n      tool_calls,\n      tool_call_id\n    }) => ({\n      role,\n      content,\n      ...experimental_attachments !== void 0 && {\n        experimental_attachments\n      },\n      ...name !== void 0 && { name },\n      ...data !== void 0 && { data },\n      ...annotations !== void 0 && { annotations },\n      ...toolInvocations !== void 0 && { toolInvocations },\n      // outdated function/tool call handling (TODO deprecate):\n      tool_call_id,\n      ...function_call !== void 0 && { function_call },\n      ...tool_calls !== void 0 && { tool_calls }\n    })\n  );\n  const existingData = existingDataRef.current;\n  return await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.callChatApi)({\n    api,\n    body: (_a = experimental_prepareRequestBody == null ? void 0 : experimental_prepareRequestBody({\n      messages: chatRequest.messages,\n      requestData: chatRequest.data,\n      requestBody: chatRequest.body\n    })) != null ? _a : {\n      messages: constructedMessagesPayload,\n      data: chatRequest.data,\n      ...extraMetadataRef.current.body,\n      ...chatRequest.body,\n      ...chatRequest.functions !== void 0 && {\n        functions: chatRequest.functions\n      },\n      ...chatRequest.function_call !== void 0 && {\n        function_call: chatRequest.function_call\n      },\n      ...chatRequest.tools !== void 0 && {\n        tools: chatRequest.tools\n      },\n      ...chatRequest.tool_choice !== void 0 && {\n        tool_choice: chatRequest.tool_choice\n      }\n    },\n    streamProtocol,\n    credentials: extraMetadataRef.current.credentials,\n    headers: {\n      ...extraMetadataRef.current.headers,\n      ...chatRequest.headers\n    },\n    abortController: () => abortControllerRef.current,\n    restoreMessagesOnFailure() {\n      if (!keepLastMessageOnError) {\n        mutate(previousMessages, false);\n      }\n    },\n    onResponse,\n    onUpdate(merged, data) {\n      mutate([...chatRequest.messages, ...merged], false);\n      mutateStreamData([...existingData != null ? existingData : [], ...data != null ? data : []], false);\n    },\n    onToolCall,\n    onFinish,\n    generateId: generateId2,\n    fetch: fetch2\n  });\n};\nfunction useChat({\n  api = \"/api/chat\",\n  id,\n  initialMessages,\n  initialInput = \"\",\n  sendExtraMessageFields,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  onToolCall,\n  experimental_prepareRequestBody,\n  experimental_maxAutomaticRoundtrips = 0,\n  maxAutomaticRoundtrips = experimental_maxAutomaticRoundtrips,\n  maxToolRoundtrips = maxAutomaticRoundtrips,\n  maxSteps = maxToolRoundtrips != null ? maxToolRoundtrips + 1 : 1,\n  streamMode,\n  streamProtocol,\n  onResponse,\n  onFinish,\n  onError,\n  credentials,\n  headers,\n  body,\n  generateId: generateId2 = _ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.generateId,\n  fetch: fetch2,\n  keepLastMessageOnError = false,\n  experimental_throttle: throttleWaitMs\n} = {}) {\n  if (streamMode) {\n    streamProtocol != null ? streamProtocol : streamProtocol = streamMode === \"text\" ? \"text\" : void 0;\n  }\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const idKey = id != null ? id : hookId;\n  const chatKey = typeof api === \"string\" ? [api, idKey] : idKey;\n  const [initialMessagesFallback] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n  const { data: messages, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    [chatKey, \"messages\"],\n    null,\n    { fallbackData: initialMessages != null ? initialMessages : initialMessagesFallback }\n  );\n  const messagesRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(messages || []);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    messagesRef.current = messages || [];\n  }, [messages]);\n  const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([chatKey, \"streamData\"], null);\n  const streamDataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(streamData);\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    streamDataRef.current = streamData;\n  }, [streamData]);\n  const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    [chatKey, \"loading\"],\n    null\n  );\n  const { data: error = void 0, mutate: setError } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([chatKey, \"error\"], null);\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    credentials,\n    headers,\n    body\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (chatRequest) => {\n      const messageCount = messagesRef.current.length;\n      try {\n        mutateLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        abortControllerRef.current = abortController;\n        await (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.processChatStream)({\n          getStreamedResponse: () => getStreamedResponse(\n            api,\n            chatRequest,\n            // throttle streamed ui updates:\n            throttle(mutate, throttleWaitMs),\n            throttle(mutateStreamData, throttleWaitMs),\n            streamDataRef,\n            extraMetadataRef,\n            messagesRef,\n            abortControllerRef,\n            generateId2,\n            streamProtocol,\n            onFinish,\n            onResponse,\n            onToolCall,\n            sendExtraMessageFields,\n            experimental_prepareRequestBody,\n            fetch2,\n            keepLastMessageOnError\n          ),\n          experimental_onFunctionCall,\n          experimental_onToolCall,\n          updateChatRequest: (chatRequestParam) => {\n            chatRequest = chatRequestParam;\n          },\n          getCurrentMessages: () => messagesRef.current\n        });\n        abortControllerRef.current = null;\n      } catch (err) {\n        if (err.name === \"AbortError\") {\n          abortControllerRef.current = null;\n          return null;\n        }\n        if (onError && err instanceof Error) {\n          onError(err);\n        }\n        setError(err);\n      } finally {\n        mutateLoading(false);\n      }\n      const messages2 = messagesRef.current;\n      const lastMessage = messages2[messages2.length - 1];\n      if (\n        // ensure we actually have new messages (to prevent infinite loops in case of errors):\n        messages2.length > messageCount && // ensure there is a last message:\n        lastMessage != null && // check if the feature is enabled:\n        maxSteps > 1 && // check that next step is possible:\n        isAssistantMessageWithCompletedToolCalls(lastMessage) && // limit the number of automatic steps:\n        countTrailingAssistantMessages(messages2) < maxSteps\n      ) {\n        await triggerRequest({ messages: messages2 });\n      }\n    },\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      mutateStreamData,\n      streamDataRef,\n      streamProtocol,\n      sendExtraMessageFields,\n      experimental_onFunctionCall,\n      experimental_onToolCall,\n      experimental_prepareRequestBody,\n      onToolCall,\n      maxSteps,\n      messagesRef,\n      abortControllerRef,\n      generateId2,\n      fetch2,\n      keepLastMessageOnError,\n      throttleWaitMs\n    ]\n  );\n  const append = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (message, {\n      options,\n      functions,\n      function_call,\n      tools,\n      tool_choice,\n      data,\n      headers: headers2,\n      body: body2,\n      experimental_attachments\n    } = {}) => {\n      var _a, _b;\n      if (!message.id) {\n        message.id = generateId2();\n      }\n      const attachmentsForRequest = await prepareAttachmentsForRequest(\n        experimental_attachments\n      );\n      const requestOptions = {\n        headers: headers2 != null ? headers2 : options == null ? void 0 : options.headers,\n        body: body2 != null ? body2 : options == null ? void 0 : options.body\n      };\n      const messages2 = messagesRef.current.concat({\n        ...message,\n        id: (_a = message.id) != null ? _a : generateId2(),\n        createdAt: (_b = message.createdAt) != null ? _b : /* @__PURE__ */ new Date(),\n        experimental_attachments: attachmentsForRequest.length > 0 ? attachmentsForRequest : void 0\n      });\n      const chatRequest = {\n        messages: messages2,\n        options: requestOptions,\n        headers: requestOptions.headers,\n        body: requestOptions.body,\n        data,\n        ...functions !== void 0 && { functions },\n        ...function_call !== void 0 && { function_call },\n        ...tools !== void 0 && { tools },\n        ...tool_choice !== void 0 && { tool_choice }\n      };\n      return triggerRequest(chatRequest);\n    },\n    [triggerRequest, generateId2]\n  );\n  const reload = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async ({\n      options,\n      functions,\n      function_call,\n      tools,\n      tool_choice,\n      data,\n      headers: headers2,\n      body: body2\n    } = {}) => {\n      if (messagesRef.current.length === 0)\n        return null;\n      const requestOptions = {\n        headers: headers2 != null ? headers2 : options == null ? void 0 : options.headers,\n        body: body2 != null ? body2 : options == null ? void 0 : options.body\n      };\n      const lastMessage = messagesRef.current[messagesRef.current.length - 1];\n      if (lastMessage.role === \"assistant\") {\n        const chatRequest2 = {\n          messages: messagesRef.current.slice(0, -1),\n          options: requestOptions,\n          headers: requestOptions.headers,\n          body: requestOptions.body,\n          data,\n          ...functions !== void 0 && { functions },\n          ...function_call !== void 0 && { function_call },\n          ...tools !== void 0 && { tools },\n          ...tool_choice !== void 0 && { tool_choice }\n        };\n        return triggerRequest(chatRequest2);\n      }\n      const chatRequest = {\n        messages: messagesRef.current,\n        options: requestOptions,\n        headers: requestOptions.headers,\n        body: requestOptions.body,\n        data,\n        ...functions !== void 0 && { functions },\n        ...function_call !== void 0 && { function_call },\n        ...tools !== void 0 && { tools },\n        ...tool_choice !== void 0 && { tool_choice }\n      };\n      return triggerRequest(chatRequest);\n    },\n    [triggerRequest]\n  );\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (abortControllerRef.current) {\n      abortControllerRef.current.abort();\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const setMessages = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (messages2) => {\n      if (typeof messages2 === \"function\") {\n        messages2 = messages2(messagesRef.current);\n      }\n      mutate(messages2, false);\n      messagesRef.current = messages2;\n    },\n    [mutate]\n  );\n  const setData = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (data) => {\n      if (typeof data === \"function\") {\n        data = data(streamDataRef.current);\n      }\n      mutateStreamData(data, false);\n      streamDataRef.current = data;\n    },\n    [mutateStreamData]\n  );\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (event, options = {}, metadata) => {\n      var _a, _b, _c, _d, _e;\n      (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n      if (!input && !options.allowEmptySubmit)\n        return;\n      if (metadata) {\n        extraMetadataRef.current = {\n          ...extraMetadataRef.current,\n          ...metadata\n        };\n      }\n      const attachmentsForRequest = await prepareAttachmentsForRequest(\n        options.experimental_attachments\n      );\n      const requestOptions = {\n        headers: (_c = options.headers) != null ? _c : (_b = options.options) == null ? void 0 : _b.headers,\n        body: (_e = options.body) != null ? _e : (_d = options.options) == null ? void 0 : _d.body\n      };\n      const messages2 = !input && !attachmentsForRequest.length && options.allowEmptySubmit ? messagesRef.current : messagesRef.current.concat({\n        id: generateId2(),\n        createdAt: /* @__PURE__ */ new Date(),\n        role: \"user\",\n        content: input,\n        experimental_attachments: attachmentsForRequest.length > 0 ? attachmentsForRequest : void 0\n      });\n      const chatRequest = {\n        messages: messages2,\n        options: requestOptions,\n        headers: requestOptions.headers,\n        body: requestOptions.body,\n        data: options.data\n      };\n      triggerRequest(chatRequest);\n      setInput(\"\");\n    },\n    [input, generateId2, triggerRequest]\n  );\n  const handleInputChange = (e) => {\n    setInput(e.target.value);\n  };\n  const addToolResult = ({\n    toolCallId,\n    result\n  }) => {\n    const updatedMessages = messagesRef.current.map(\n      (message, index, arr) => (\n        // update the tool calls in the last assistant message:\n        index === arr.length - 1 && message.role === \"assistant\" && message.toolInvocations ? {\n          ...message,\n          toolInvocations: message.toolInvocations.map(\n            (toolInvocation) => toolInvocation.toolCallId === toolCallId ? { ...toolInvocation, result } : toolInvocation\n          )\n        } : message\n      )\n    );\n    mutate(updatedMessages, false);\n    const lastMessage = updatedMessages[updatedMessages.length - 1];\n    if (isAssistantMessageWithCompletedToolCalls(lastMessage)) {\n      triggerRequest({ messages: updatedMessages });\n    }\n  };\n  return {\n    messages: messages || [],\n    setMessages,\n    data: streamData,\n    setData,\n    error,\n    append,\n    reload,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    addToolResult,\n    experimental_addToolResult: addToolResult\n  };\n}\nfunction isAssistantMessageWithCompletedToolCalls(message) {\n  return message.role === \"assistant\" && message.toolInvocations && message.toolInvocations.length > 0 && message.toolInvocations.every((toolInvocation) => \"result\" in toolInvocation);\n}\nfunction countTrailingAssistantMessages(messages) {\n  let count = 0;\n  for (let i = messages.length - 1; i >= 0; i--) {\n    if (messages[i].role === \"assistant\") {\n      count++;\n    } else {\n      break;\n    }\n  }\n  return count;\n}\nasync function prepareAttachmentsForRequest(attachmentsFromOptions) {\n  if (attachmentsFromOptions == null) {\n    return [];\n  }\n  if (attachmentsFromOptions instanceof FileList) {\n    return Promise.all(\n      Array.from(attachmentsFromOptions).map(async (attachment) => {\n        const { name, type } = attachment;\n        const dataUrl = await new Promise((resolve, reject) => {\n          const reader = new FileReader();\n          reader.onload = (readerEvent) => {\n            var _a;\n            resolve((_a = readerEvent.target) == null ? void 0 : _a.result);\n          };\n          reader.onerror = (error) => reject(error);\n          reader.readAsDataURL(attachment);\n        });\n        return {\n          name,\n          contentType: type,\n          url: dataUrl\n        };\n      })\n    );\n  }\n  if (Array.isArray(attachmentsFromOptions)) {\n    return attachmentsFromOptions;\n  }\n  throw new Error(\"Invalid attachments type\");\n}\n\n// src/use-completion.ts\n\n\n\nfunction useCompletion({\n  api = \"/api/completion\",\n  id,\n  initialCompletion = \"\",\n  initialInput = \"\",\n  credentials,\n  headers,\n  body,\n  streamMode,\n  streamProtocol,\n  fetch: fetch2,\n  onResponse,\n  onFinish,\n  onError,\n  experimental_throttle: throttleWaitMs\n} = {}) {\n  if (streamMode) {\n    streamProtocol != null ? streamProtocol : streamProtocol = streamMode === \"text\" ? \"text\" : void 0;\n  }\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const completionId = id || hookId;\n  const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([api, completionId], null, {\n    fallbackData: initialCompletion\n  });\n  const { data: isLoading = false, mutate: mutateLoading } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    [completionId, \"loading\"],\n    null\n  );\n  const { data: streamData, mutate: mutateStreamData } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])([completionId, \"streamData\"], null);\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  const completion = data;\n  const [abortController, setAbortController] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(null);\n  const extraMetadataRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)({\n    credentials,\n    headers,\n    body\n  });\n  (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(() => {\n    extraMetadataRef.current = {\n      credentials,\n      headers,\n      body\n    };\n  }, [credentials, headers, body]);\n  const triggerRequest = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (prompt, options) => (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.callCompletionApi)({\n      api,\n      prompt,\n      credentials: extraMetadataRef.current.credentials,\n      headers: { ...extraMetadataRef.current.headers, ...options == null ? void 0 : options.headers },\n      body: {\n        ...extraMetadataRef.current.body,\n        ...options == null ? void 0 : options.body\n      },\n      streamProtocol,\n      fetch: fetch2,\n      // throttle streamed ui updates:\n      setCompletion: throttle(\n        (completion2) => mutate(completion2, false),\n        throttleWaitMs\n      ),\n      onData: throttle(\n        (data2) => mutateStreamData([...streamData != null ? streamData : [], ...data2 != null ? data2 : []], false),\n        throttleWaitMs\n      ),\n      setLoading: mutateLoading,\n      setError,\n      setAbortController,\n      onResponse,\n      onFinish,\n      onError\n    }),\n    [\n      mutate,\n      mutateLoading,\n      api,\n      extraMetadataRef,\n      setAbortController,\n      onResponse,\n      onFinish,\n      onError,\n      setError,\n      streamData,\n      streamProtocol,\n      fetch2,\n      mutateStreamData,\n      throttleWaitMs\n    ]\n  );\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    if (abortController) {\n      abortController.abort();\n      setAbortController(null);\n    }\n  }, [abortController]);\n  const setCompletion = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (completion2) => {\n      mutate(completion2, false);\n    },\n    [mutate]\n  );\n  const complete = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    async (prompt, options) => {\n      return triggerRequest(prompt, options);\n    },\n    [triggerRequest]\n  );\n  const [input, setInput] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(initialInput);\n  const handleSubmit = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (event) => {\n      var _a;\n      (_a = event == null ? void 0 : event.preventDefault) == null ? void 0 : _a.call(event);\n      return input ? complete(input) : void 0;\n    },\n    [input, complete]\n  );\n  const handleInputChange = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(\n    (e) => {\n      setInput(e.target.value);\n    },\n    [setInput]\n  );\n  return {\n    completion,\n    complete,\n    error,\n    setCompletion,\n    stop,\n    input,\n    setInput,\n    handleInputChange,\n    handleSubmit,\n    isLoading,\n    data: streamData\n  };\n}\n\n// src/use-object.ts\n\n\n\n\nvar getOriginalFetch2 = () => fetch;\nfunction useObject({\n  api,\n  id,\n  schema,\n  // required, in the future we will use it for validation\n  initialValue,\n  fetch: fetch2,\n  onError,\n  onFinish,\n  headers\n}) {\n  const hookId = (0,react__WEBPACK_IMPORTED_MODULE_0__.useId)();\n  const completionId = id != null ? id : hookId;\n  const { data, mutate } = (0,swr__WEBPACK_IMPORTED_MODULE_3__[\"default\"])(\n    [api, completionId],\n    null,\n    { fallbackData: initialValue }\n  );\n  const [error, setError] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(void 0);\n  const [isLoading, setIsLoading] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)(false);\n  const abortControllerRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(null);\n  const stop = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)(() => {\n    var _a;\n    try {\n      (_a = abortControllerRef.current) == null ? void 0 : _a.abort();\n    } catch (ignored) {\n    } finally {\n      setIsLoading(false);\n      abortControllerRef.current = null;\n    }\n  }, []);\n  const submit = async (input) => {\n    var _a;\n    try {\n      mutate(void 0);\n      setIsLoading(true);\n      setError(void 0);\n      const abortController = new AbortController();\n      abortControllerRef.current = abortController;\n      const actualFetch = fetch2 != null ? fetch2 : getOriginalFetch2();\n      const response = await actualFetch(api, {\n        method: \"POST\",\n        headers: {\n          \"Content-Type\": \"application/json\",\n          ...headers\n        },\n        signal: abortController.signal,\n        body: JSON.stringify(input)\n      });\n      if (!response.ok) {\n        throw new Error(\n          (_a = await response.text()) != null ? _a : \"Failed to fetch the response.\"\n        );\n      }\n      if (response.body == null) {\n        throw new Error(\"The response body is empty.\");\n      }\n      let accumulatedText = \"\";\n      let latestObject = void 0;\n      await response.body.pipeThrough(new TextDecoderStream()).pipeTo(\n        new WritableStream({\n          write(chunk) {\n            accumulatedText += chunk;\n            const { value } = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.parsePartialJson)(accumulatedText);\n            const currentObject = value;\n            if (!(0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.isDeepEqualData)(latestObject, currentObject)) {\n              latestObject = currentObject;\n              mutate(currentObject);\n            }\n          },\n          close() {\n            setIsLoading(false);\n            abortControllerRef.current = null;\n            if (onFinish != null) {\n              const validationResult = (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.safeValidateTypes)({\n                value: latestObject,\n                schema: (0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_2__.asSchema)(schema)\n              });\n              onFinish(\n                validationResult.success ? { object: validationResult.value, error: void 0 } : { object: void 0, error: validationResult.error }\n              );\n            }\n          }\n        })\n      );\n    } catch (error2) {\n      if ((0,_ai_sdk_ui_utils__WEBPACK_IMPORTED_MODULE_1__.isAbortError)(error2)) {\n        return;\n      }\n      if (onError && error2 instanceof Error) {\n        onError(error2);\n      }\n      setIsLoading(false);\n      setError(error2 instanceof Error ? error2 : new Error(String(error2)));\n    }\n  };\n  return {\n    setInput: submit,\n    // Deprecated\n    submit,\n    object: data,\n    error,\n    isLoading,\n    stop\n  };\n}\nvar experimental_useObject = useObject;\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9yZWFjdC9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7O0FBQUE7QUFDc0Q7QUFJNUI7QUFDNEI7QUFDdEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNELGtDQUFrQywrQ0FBUTtBQUMxQyw0QkFBNEIsK0NBQVE7QUFDcEMsZ0RBQWdELCtDQUFRO0FBQ3hEO0FBQ0E7QUFDQSw4QkFBOEIsK0NBQVE7QUFDdEMsNEJBQTRCLCtDQUFRO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBLDZCQUE2Qiw2Q0FBTTtBQUNuQyxlQUFlLGtEQUFXO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRCw0REFBVTtBQUMzRDtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQixnREFBZ0Q7QUFDbkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsT0FBTztBQUNQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUIsY0FBYyxHQUFHLGdFQUFjO0FBQ3hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1REFBdUQsNERBQVU7QUFDakU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBT0U7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJzdF9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvcmVhY3QvZGlzdC9pbmRleC5tanM/MzhiNyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvdXNlLWFzc2lzdGFudC50c1xuaW1wb3J0IHsgaXNBYm9ydEVycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcbmltcG9ydCB7XG4gIGdlbmVyYXRlSWQsXG4gIHJlYWREYXRhU3RyZWFtXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjaywgdXNlUmVmLCB1c2VTdGF0ZSB9IGZyb20gXCJyZWFjdFwiO1xudmFyIGdldE9yaWdpbmFsRmV0Y2ggPSAoKSA9PiBmZXRjaDtcbmZ1bmN0aW9uIHVzZUFzc2lzdGFudCh7XG4gIGFwaSxcbiAgdGhyZWFkSWQ6IHRocmVhZElkUGFyYW0sXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBvbkVycm9yLFxuICBmZXRjaDogZmV0Y2gyXG59KSB7XG4gIGNvbnN0IFttZXNzYWdlcywgc2V0TWVzc2FnZXNdID0gdXNlU3RhdGUoW10pO1xuICBjb25zdCBbaW5wdXQsIHNldElucHV0XSA9IHVzZVN0YXRlKFwiXCIpO1xuICBjb25zdCBbY3VycmVudFRocmVhZElkLCBzZXRDdXJyZW50VGhyZWFkSWRdID0gdXNlU3RhdGUoXG4gICAgdm9pZCAwXG4gICk7XG4gIGNvbnN0IFtzdGF0dXMsIHNldFN0YXR1c10gPSB1c2VTdGF0ZShcImF3YWl0aW5nX21lc3NhZ2VcIik7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gdXNlU3RhdGUodm9pZCAwKTtcbiAgY29uc3QgaGFuZGxlSW5wdXRDaGFuZ2UgPSAoZXZlbnQpID0+IHtcbiAgICBzZXRJbnB1dChldmVudC50YXJnZXQudmFsdWUpO1xuICB9O1xuICBjb25zdCBhYm9ydENvbnRyb2xsZXJSZWYgPSB1c2VSZWYobnVsbCk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjaygoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBhcHBlbmQgPSBhc3luYyAobWVzc2FnZSwgcmVxdWVzdE9wdGlvbnMpID0+IHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHNldFN0YXR1cyhcImluX3Byb2dyZXNzXCIpO1xuICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IHtcbiAgICAgIHZhciBfYTI7XG4gICAgICByZXR1cm4gW1xuICAgICAgICAuLi5tZXNzYWdlczIsXG4gICAgICAgIHtcbiAgICAgICAgICAuLi5tZXNzYWdlLFxuICAgICAgICAgIGlkOiAoX2EyID0gbWVzc2FnZS5pZCkgIT0gbnVsbCA/IF9hMiA6IGdlbmVyYXRlSWQoKVxuICAgICAgICB9XG4gICAgICBdO1xuICAgIH0pO1xuICAgIHNldElucHV0KFwiXCIpO1xuICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICB0cnkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBhYm9ydENvbnRyb2xsZXI7XG4gICAgICBjb25zdCBhY3R1YWxGZXRjaCA9IGZldGNoMiAhPSBudWxsID8gZmV0Y2gyIDogZ2V0T3JpZ2luYWxGZXRjaCgpO1xuICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBhY3R1YWxGZXRjaChhcGksIHtcbiAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgY3JlZGVudGlhbHMsXG4gICAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbCxcbiAgICAgICAgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIiwgLi4uaGVhZGVycyB9LFxuICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgLi4uYm9keSxcbiAgICAgICAgICAvLyBhbHdheXMgdXNlIHVzZXItcHJvdmlkZWQgdGhyZWFkSWQgd2hlbiBhdmFpbGFibGU6XG4gICAgICAgICAgdGhyZWFkSWQ6IChfYSA9IHRocmVhZElkUGFyYW0gIT0gbnVsbCA/IHRocmVhZElkUGFyYW0gOiBjdXJyZW50VGhyZWFkSWQpICE9IG51bGwgPyBfYSA6IG51bGwsXG4gICAgICAgICAgbWVzc2FnZTogbWVzc2FnZS5jb250ZW50LFxuICAgICAgICAgIC8vIG9wdGlvbmFsIHJlcXVlc3QgZGF0YTpcbiAgICAgICAgICBkYXRhOiByZXF1ZXN0T3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogcmVxdWVzdE9wdGlvbnMuZGF0YVxuICAgICAgICB9KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAoX2IgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfYiA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBhc3Npc3RhbnQgcmVzcG9uc2UuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgICAgfVxuICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0oXG4gICAgICAgIHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKClcbiAgICAgICkpIHtcbiAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgY2FzZSBcImFzc2lzdGFudF9tZXNzYWdlXCI6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IFtcbiAgICAgICAgICAgICAgLi4ubWVzc2FnZXMyLFxuICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgaWQ6IHZhbHVlLmlkLFxuICAgICAgICAgICAgICAgIHJvbGU6IHZhbHVlLnJvbGUsXG4gICAgICAgICAgICAgICAgY29udGVudDogdmFsdWUuY29udGVudFswXS50ZXh0LnZhbHVlXG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgIHNldE1lc3NhZ2VzKChtZXNzYWdlczIpID0+IHtcbiAgICAgICAgICAgICAgY29uc3QgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlczJbbWVzc2FnZXMyLmxlbmd0aCAtIDFdO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VzMi5zbGljZSgwLCBtZXNzYWdlczIubGVuZ3RoIC0gMSksXG4gICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgaWQ6IGxhc3RNZXNzYWdlLmlkLFxuICAgICAgICAgICAgICAgICAgcm9sZTogbGFzdE1lc3NhZ2Uucm9sZSxcbiAgICAgICAgICAgICAgICAgIGNvbnRlbnQ6IGxhc3RNZXNzYWdlLmNvbnRlbnQgKyB2YWx1ZVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJkYXRhX21lc3NhZ2VcIjoge1xuICAgICAgICAgICAgc2V0TWVzc2FnZXMoKG1lc3NhZ2VzMikgPT4ge1xuICAgICAgICAgICAgICB2YXIgX2EyO1xuICAgICAgICAgICAgICByZXR1cm4gW1xuICAgICAgICAgICAgICAgIC4uLm1lc3NhZ2VzMixcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICBpZDogKF9hMiA9IHZhbHVlLmlkKSAhPSBudWxsID8gX2EyIDogZ2VuZXJhdGVJZCgpLFxuICAgICAgICAgICAgICAgICAgcm9sZTogXCJkYXRhXCIsXG4gICAgICAgICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgICAgICAgZGF0YTogdmFsdWUuZGF0YVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCI6IHtcbiAgICAgICAgICAgIHNldEN1cnJlbnRUaHJlYWRJZCh2YWx1ZS50aHJlYWRJZCk7XG4gICAgICAgICAgICBzZXRNZXNzYWdlcygobWVzc2FnZXMyKSA9PiB7XG4gICAgICAgICAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXMyW21lc3NhZ2VzMi5sZW5ndGggLSAxXTtcbiAgICAgICAgICAgICAgbGFzdE1lc3NhZ2UuaWQgPSB2YWx1ZS5tZXNzYWdlSWQ7XG4gICAgICAgICAgICAgIHJldHVybiBbLi4ubWVzc2FnZXMyLnNsaWNlKDAsIG1lc3NhZ2VzMi5sZW5ndGggLSAxKSwgbGFzdE1lc3NhZ2VdO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVycm9yXCI6IHtcbiAgICAgICAgICAgIHNldEVycm9yKG5ldyBFcnJvcih2YWx1ZSkpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBjYXRjaCAoZXJyb3IyKSB7XG4gICAgICBpZiAoaXNBYm9ydEVycm9yKGVycm9yMikgJiYgYWJvcnRDb250cm9sbGVyLnNpZ25hbC5hYm9ydGVkKSB7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKG9uRXJyb3IgJiYgZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgb25FcnJvcihlcnJvcjIpO1xuICAgICAgfVxuICAgICAgc2V0RXJyb3IoZXJyb3IyKTtcbiAgICB9IGZpbmFsbHkge1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgc2V0U3RhdHVzKFwiYXdhaXRpbmdfbWVzc2FnZVwiKTtcbiAgICB9XG4gIH07XG4gIGNvbnN0IHN1Ym1pdE1lc3NhZ2UgPSBhc3luYyAoZXZlbnQsIHJlcXVlc3RPcHRpb25zKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIChfYSA9IGV2ZW50ID09IG51bGwgPyB2b2lkIDAgOiBldmVudC5wcmV2ZW50RGVmYXVsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmNhbGwoZXZlbnQpO1xuICAgIGlmIChpbnB1dCA9PT0gXCJcIikge1xuICAgICAgcmV0dXJuO1xuICAgIH1cbiAgICBhcHBlbmQoeyByb2xlOiBcInVzZXJcIiwgY29udGVudDogaW5wdXQgfSwgcmVxdWVzdE9wdGlvbnMpO1xuICB9O1xuICBjb25zdCBzZXRUaHJlYWRJZCA9ICh0aHJlYWRJZCkgPT4ge1xuICAgIHNldEN1cnJlbnRUaHJlYWRJZCh0aHJlYWRJZCk7XG4gICAgc2V0TWVzc2FnZXMoW10pO1xuICB9O1xuICByZXR1cm4ge1xuICAgIGFwcGVuZCxcbiAgICBtZXNzYWdlcyxcbiAgICBzZXRNZXNzYWdlcyxcbiAgICB0aHJlYWRJZDogY3VycmVudFRocmVhZElkLFxuICAgIHNldFRocmVhZElkLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIHN1Ym1pdE1lc3NhZ2UsXG4gICAgc3RhdHVzLFxuICAgIGVycm9yLFxuICAgIHN0b3BcbiAgfTtcbn1cbnZhciBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50ID0gdXNlQXNzaXN0YW50O1xuXG4vLyBzcmMvdXNlLWNoYXQudHNcbmltcG9ydCB7XG4gIGNhbGxDaGF0QXBpLFxuICBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jLFxuICBwcm9jZXNzQ2hhdFN0cmVhbVxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2syLCB1c2VFZmZlY3QsIHVzZUlkLCB1c2VSZWYgYXMgdXNlUmVmMiwgdXNlU3RhdGUgYXMgdXNlU3RhdGUyIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSIGZyb20gXCJzd3JcIjtcblxuLy8gc3JjL3Rocm90dGxlLnRzXG5pbXBvcnQgdGhyb3R0bGVGdW5jdGlvbiBmcm9tIFwidGhyb3R0bGVpdFwiO1xuZnVuY3Rpb24gdGhyb3R0bGUoZm4sIHdhaXRNcykge1xuICByZXR1cm4gd2FpdE1zICE9IG51bGwgPyB0aHJvdHRsZUZ1bmN0aW9uKGZuLCB3YWl0TXMpIDogZm47XG59XG5cbi8vIHNyYy91c2UtY2hhdC50c1xudmFyIGdldFN0cmVhbWVkUmVzcG9uc2UgPSBhc3luYyAoYXBpLCBjaGF0UmVxdWVzdCwgbXV0YXRlLCBtdXRhdGVTdHJlYW1EYXRhLCBleGlzdGluZ0RhdGFSZWYsIGV4dHJhTWV0YWRhdGFSZWYsIG1lc3NhZ2VzUmVmLCBhYm9ydENvbnRyb2xsZXJSZWYsIGdlbmVyYXRlSWQyLCBzdHJlYW1Qcm90b2NvbCwgb25GaW5pc2gsIG9uUmVzcG9uc2UsIG9uVG9vbENhbGwsIHNlbmRFeHRyYU1lc3NhZ2VGaWVsZHMsIGV4cGVyaW1lbnRhbF9wcmVwYXJlUmVxdWVzdEJvZHksIGZldGNoMiwga2VlcExhc3RNZXNzYWdlT25FcnJvcikgPT4ge1xuICB2YXIgX2E7XG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBtZXNzYWdlc1JlZi5jdXJyZW50O1xuICBtdXRhdGUoY2hhdFJlcXVlc3QubWVzc2FnZXMsIGZhbHNlKTtcbiAgY29uc3QgY29uc3RydWN0ZWRNZXNzYWdlc1BheWxvYWQgPSBzZW5kRXh0cmFNZXNzYWdlRmllbGRzID8gY2hhdFJlcXVlc3QubWVzc2FnZXMgOiBjaGF0UmVxdWVzdC5tZXNzYWdlcy5tYXAoXG4gICAgKHtcbiAgICAgIHJvbGUsXG4gICAgICBjb250ZW50LFxuICAgICAgZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzLFxuICAgICAgbmFtZSxcbiAgICAgIGRhdGEsXG4gICAgICBhbm5vdGF0aW9ucyxcbiAgICAgIHRvb2xJbnZvY2F0aW9ucyxcbiAgICAgIGZ1bmN0aW9uX2NhbGwsXG4gICAgICB0b29sX2NhbGxzLFxuICAgICAgdG9vbF9jYWxsX2lkXG4gICAgfSkgPT4gKHtcbiAgICAgIHJvbGUsXG4gICAgICBjb250ZW50LFxuICAgICAgLi4uZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBleHBlcmltZW50YWxfYXR0YWNobWVudHNcbiAgICAgIH0sXG4gICAgICAuLi5uYW1lICE9PSB2b2lkIDAgJiYgeyBuYW1lIH0sXG4gICAgICAuLi5kYXRhICE9PSB2b2lkIDAgJiYgeyBkYXRhIH0sXG4gICAgICAuLi5hbm5vdGF0aW9ucyAhPT0gdm9pZCAwICYmIHsgYW5ub3RhdGlvbnMgfSxcbiAgICAgIC4uLnRvb2xJbnZvY2F0aW9ucyAhPT0gdm9pZCAwICYmIHsgdG9vbEludm9jYXRpb25zIH0sXG4gICAgICAvLyBvdXRkYXRlZCBmdW5jdGlvbi90b29sIGNhbGwgaGFuZGxpbmcgKFRPRE8gZGVwcmVjYXRlKTpcbiAgICAgIHRvb2xfY2FsbF9pZCxcbiAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSxcbiAgICAgIC4uLnRvb2xfY2FsbHMgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2FsbHMgfVxuICAgIH0pXG4gICk7XG4gIGNvbnN0IGV4aXN0aW5nRGF0YSA9IGV4aXN0aW5nRGF0YVJlZi5jdXJyZW50O1xuICByZXR1cm4gYXdhaXQgY2FsbENoYXRBcGkoe1xuICAgIGFwaSxcbiAgICBib2R5OiAoX2EgPSBleHBlcmltZW50YWxfcHJlcGFyZVJlcXVlc3RCb2R5ID09IG51bGwgPyB2b2lkIDAgOiBleHBlcmltZW50YWxfcHJlcGFyZVJlcXVlc3RCb2R5KHtcbiAgICAgIG1lc3NhZ2VzOiBjaGF0UmVxdWVzdC5tZXNzYWdlcyxcbiAgICAgIHJlcXVlc3REYXRhOiBjaGF0UmVxdWVzdC5kYXRhLFxuICAgICAgcmVxdWVzdEJvZHk6IGNoYXRSZXF1ZXN0LmJvZHlcbiAgICB9KSkgIT0gbnVsbCA/IF9hIDoge1xuICAgICAgbWVzc2FnZXM6IGNvbnN0cnVjdGVkTWVzc2FnZXNQYXlsb2FkLFxuICAgICAgZGF0YTogY2hhdFJlcXVlc3QuZGF0YSxcbiAgICAgIC4uLmV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5ib2R5LFxuICAgICAgLi4uY2hhdFJlcXVlc3QuYm9keSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHtcbiAgICAgICAgZnVuY3Rpb25zOiBjaGF0UmVxdWVzdC5mdW5jdGlvbnNcbiAgICAgIH0sXG4gICAgICAuLi5jaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDAgJiYge1xuICAgICAgICBmdW5jdGlvbl9jYWxsOiBjaGF0UmVxdWVzdC5mdW5jdGlvbl9jYWxsXG4gICAgICB9LFxuICAgICAgLi4uY2hhdFJlcXVlc3QudG9vbHMgIT09IHZvaWQgMCAmJiB7XG4gICAgICAgIHRvb2xzOiBjaGF0UmVxdWVzdC50b29sc1xuICAgICAgfSxcbiAgICAgIC4uLmNoYXRSZXF1ZXN0LnRvb2xfY2hvaWNlICE9PSB2b2lkIDAgJiYge1xuICAgICAgICB0b29sX2Nob2ljZTogY2hhdFJlcXVlc3QudG9vbF9jaG9pY2VcbiAgICAgIH1cbiAgICB9LFxuICAgIHN0cmVhbVByb3RvY29sLFxuICAgIGNyZWRlbnRpYWxzOiBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuY3JlZGVudGlhbHMsXG4gICAgaGVhZGVyczoge1xuICAgICAgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsXG4gICAgICAuLi5jaGF0UmVxdWVzdC5oZWFkZXJzXG4gICAgfSxcbiAgICBhYm9ydENvbnRyb2xsZXI6ICgpID0+IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50LFxuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpIHtcbiAgICAgIGlmICgha2VlcExhc3RNZXNzYWdlT25FcnJvcikge1xuICAgICAgICBtdXRhdGUocHJldmlvdXNNZXNzYWdlcywgZmFsc2UpO1xuICAgICAgfVxuICAgIH0sXG4gICAgb25SZXNwb25zZSxcbiAgICBvblVwZGF0ZShtZXJnZWQsIGRhdGEpIHtcbiAgICAgIG11dGF0ZShbLi4uY2hhdFJlcXVlc3QubWVzc2FnZXMsIC4uLm1lcmdlZF0sIGZhbHNlKTtcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEoWy4uLmV4aXN0aW5nRGF0YSAhPSBudWxsID8gZXhpc3RpbmdEYXRhIDogW10sIC4uLmRhdGEgIT0gbnVsbCA/IGRhdGEgOiBbXV0sIGZhbHNlKTtcbiAgICB9LFxuICAgIG9uVG9vbENhbGwsXG4gICAgb25GaW5pc2gsXG4gICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIsXG4gICAgZmV0Y2g6IGZldGNoMlxuICB9KTtcbn07XG5mdW5jdGlvbiB1c2VDaGF0KHtcbiAgYXBpID0gXCIvYXBpL2NoYXRcIixcbiAgaWQsXG4gIGluaXRpYWxNZXNzYWdlcyxcbiAgaW5pdGlhbElucHV0ID0gXCJcIixcbiAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICBleHBlcmltZW50YWxfb25Ub29sQ2FsbCxcbiAgb25Ub29sQ2FsbCxcbiAgZXhwZXJpbWVudGFsX3ByZXBhcmVSZXF1ZXN0Qm9keSxcbiAgZXhwZXJpbWVudGFsX21heEF1dG9tYXRpY1JvdW5kdHJpcHMgPSAwLFxuICBtYXhBdXRvbWF0aWNSb3VuZHRyaXBzID0gZXhwZXJpbWVudGFsX21heEF1dG9tYXRpY1JvdW5kdHJpcHMsXG4gIG1heFRvb2xSb3VuZHRyaXBzID0gbWF4QXV0b21hdGljUm91bmR0cmlwcyxcbiAgbWF4U3RlcHMgPSBtYXhUb29sUm91bmR0cmlwcyAhPSBudWxsID8gbWF4VG9vbFJvdW5kdHJpcHMgKyAxIDogMSxcbiAgc3RyZWFtTW9kZSxcbiAgc3RyZWFtUHJvdG9jb2wsXG4gIG9uUmVzcG9uc2UsXG4gIG9uRmluaXNoLFxuICBvbkVycm9yLFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuYyxcbiAgZmV0Y2g6IGZldGNoMixcbiAga2VlcExhc3RNZXNzYWdlT25FcnJvciA9IGZhbHNlLFxuICBleHBlcmltZW50YWxfdGhyb3R0bGU6IHRocm90dGxlV2FpdE1zXG59ID0ge30pIHtcbiAgaWYgKHN0cmVhbU1vZGUpIHtcbiAgICBzdHJlYW1Qcm90b2NvbCAhPSBudWxsID8gc3RyZWFtUHJvdG9jb2wgOiBzdHJlYW1Qcm90b2NvbCA9IHN0cmVhbU1vZGUgPT09IFwidGV4dFwiID8gXCJ0ZXh0XCIgOiB2b2lkIDA7XG4gIH1cbiAgY29uc3QgaG9va0lkID0gdXNlSWQoKTtcbiAgY29uc3QgaWRLZXkgPSBpZCAhPSBudWxsID8gaWQgOiBob29rSWQ7XG4gIGNvbnN0IGNoYXRLZXkgPSB0eXBlb2YgYXBpID09PSBcInN0cmluZ1wiID8gW2FwaSwgaWRLZXldIDogaWRLZXk7XG4gIGNvbnN0IFtpbml0aWFsTWVzc2FnZXNGYWxsYmFja10gPSB1c2VTdGF0ZTIoW10pO1xuICBjb25zdCB7IGRhdGE6IG1lc3NhZ2VzLCBtdXRhdGUgfSA9IHVzZVNXUihcbiAgICBbY2hhdEtleSwgXCJtZXNzYWdlc1wiXSxcbiAgICBudWxsLFxuICAgIHsgZmFsbGJhY2tEYXRhOiBpbml0aWFsTWVzc2FnZXMgIT0gbnVsbCA/IGluaXRpYWxNZXNzYWdlcyA6IGluaXRpYWxNZXNzYWdlc0ZhbGxiYWNrIH1cbiAgKTtcbiAgY29uc3QgbWVzc2FnZXNSZWYgPSB1c2VSZWYyKG1lc3NhZ2VzIHx8IFtdKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBtZXNzYWdlc1JlZi5jdXJyZW50ID0gbWVzc2FnZXMgfHwgW107XG4gIH0sIFttZXNzYWdlc10pO1xuICBjb25zdCB7IGRhdGE6IHN0cmVhbURhdGEsIG11dGF0ZTogbXV0YXRlU3RyZWFtRGF0YSB9ID0gdXNlU1dSKFtjaGF0S2V5LCBcInN0cmVhbURhdGFcIl0sIG51bGwpO1xuICBjb25zdCBzdHJlYW1EYXRhUmVmID0gdXNlUmVmMihzdHJlYW1EYXRhKTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBzdHJlYW1EYXRhUmVmLmN1cnJlbnQgPSBzdHJlYW1EYXRhO1xuICB9LCBbc3RyZWFtRGF0YV0pO1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUihcbiAgICBbY2hhdEtleSwgXCJsb2FkaW5nXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgeyBkYXRhOiBlcnJvciA9IHZvaWQgMCwgbXV0YXRlOiBzZXRFcnJvciB9ID0gdXNlU1dSKFtjaGF0S2V5LCBcImVycm9yXCJdLCBudWxsKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmMihudWxsKTtcbiAgY29uc3QgZXh0cmFNZXRhZGF0YVJlZiA9IHVzZVJlZjIoe1xuICAgIGNyZWRlbnRpYWxzLFxuICAgIGhlYWRlcnMsXG4gICAgYm9keVxuICB9KTtcbiAgdXNlRWZmZWN0KCgpID0+IHtcbiAgICBleHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQgPSB7XG4gICAgICBjcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnMsXG4gICAgICBib2R5XG4gICAgfTtcbiAgfSwgW2NyZWRlbnRpYWxzLCBoZWFkZXJzLCBib2R5XSk7XG4gIGNvbnN0IHRyaWdnZXJSZXF1ZXN0ID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChjaGF0UmVxdWVzdCkgPT4ge1xuICAgICAgY29uc3QgbWVzc2FnZUNvdW50ID0gbWVzc2FnZXNSZWYuY3VycmVudC5sZW5ndGg7XG4gICAgICB0cnkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKHRydWUpO1xuICAgICAgICBzZXRFcnJvcih2b2lkIDApO1xuICAgICAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgICBhd2FpdCBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gICAgICAgICAgZ2V0U3RyZWFtZWRSZXNwb25zZTogKCkgPT4gZ2V0U3RyZWFtZWRSZXNwb25zZShcbiAgICAgICAgICAgIGFwaSxcbiAgICAgICAgICAgIGNoYXRSZXF1ZXN0LFxuICAgICAgICAgICAgLy8gdGhyb3R0bGUgc3RyZWFtZWQgdWkgdXBkYXRlczpcbiAgICAgICAgICAgIHRocm90dGxlKG11dGF0ZSwgdGhyb3R0bGVXYWl0TXMpLFxuICAgICAgICAgICAgdGhyb3R0bGUobXV0YXRlU3RyZWFtRGF0YSwgdGhyb3R0bGVXYWl0TXMpLFxuICAgICAgICAgICAgc3RyZWFtRGF0YVJlZixcbiAgICAgICAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICAgICAgICBtZXNzYWdlc1JlZixcbiAgICAgICAgICAgIGFib3J0Q29udHJvbGxlclJlZixcbiAgICAgICAgICAgIGdlbmVyYXRlSWQyLFxuICAgICAgICAgICAgc3RyZWFtUHJvdG9jb2wsXG4gICAgICAgICAgICBvbkZpbmlzaCxcbiAgICAgICAgICAgIG9uUmVzcG9uc2UsXG4gICAgICAgICAgICBvblRvb2xDYWxsLFxuICAgICAgICAgICAgc2VuZEV4dHJhTWVzc2FnZUZpZWxkcyxcbiAgICAgICAgICAgIGV4cGVyaW1lbnRhbF9wcmVwYXJlUmVxdWVzdEJvZHksXG4gICAgICAgICAgICBmZXRjaDIsXG4gICAgICAgICAgICBrZWVwTGFzdE1lc3NhZ2VPbkVycm9yXG4gICAgICAgICAgKSxcbiAgICAgICAgICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gICAgICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3Q6IChjaGF0UmVxdWVzdFBhcmFtKSA9PiB7XG4gICAgICAgICAgICBjaGF0UmVxdWVzdCA9IGNoYXRSZXF1ZXN0UGFyYW07XG4gICAgICAgICAgfSxcbiAgICAgICAgICBnZXRDdXJyZW50TWVzc2FnZXM6ICgpID0+IG1lc3NhZ2VzUmVmLmN1cnJlbnRcbiAgICAgICAgfSk7XG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gbnVsbDtcbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbkVycm9yICYmIGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICAgICAgb25FcnJvcihlcnIpO1xuICAgICAgICB9XG4gICAgICAgIHNldEVycm9yKGVycik7XG4gICAgICB9IGZpbmFsbHkge1xuICAgICAgICBtdXRhdGVMb2FkaW5nKGZhbHNlKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IG1lc3NhZ2VzMiA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQ7XG4gICAgICBjb25zdCBsYXN0TWVzc2FnZSA9IG1lc3NhZ2VzMlttZXNzYWdlczIubGVuZ3RoIC0gMV07XG4gICAgICBpZiAoXG4gICAgICAgIC8vIGVuc3VyZSB3ZSBhY3R1YWxseSBoYXZlIG5ldyBtZXNzYWdlcyAodG8gcHJldmVudCBpbmZpbml0ZSBsb29wcyBpbiBjYXNlIG9mIGVycm9ycyk6XG4gICAgICAgIG1lc3NhZ2VzMi5sZW5ndGggPiBtZXNzYWdlQ291bnQgJiYgLy8gZW5zdXJlIHRoZXJlIGlzIGEgbGFzdCBtZXNzYWdlOlxuICAgICAgICBsYXN0TWVzc2FnZSAhPSBudWxsICYmIC8vIGNoZWNrIGlmIHRoZSBmZWF0dXJlIGlzIGVuYWJsZWQ6XG4gICAgICAgIG1heFN0ZXBzID4gMSAmJiAvLyBjaGVjayB0aGF0IG5leHQgc3RlcCBpcyBwb3NzaWJsZTpcbiAgICAgICAgaXNBc3Npc3RhbnRNZXNzYWdlV2l0aENvbXBsZXRlZFRvb2xDYWxscyhsYXN0TWVzc2FnZSkgJiYgLy8gbGltaXQgdGhlIG51bWJlciBvZiBhdXRvbWF0aWMgc3RlcHM6XG4gICAgICAgIGNvdW50VHJhaWxpbmdBc3Npc3RhbnRNZXNzYWdlcyhtZXNzYWdlczIpIDwgbWF4U3RlcHNcbiAgICAgICkge1xuICAgICAgICBhd2FpdCB0cmlnZ2VyUmVxdWVzdCh7IG1lc3NhZ2VzOiBtZXNzYWdlczIgfSk7XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBtdXRhdGUsXG4gICAgICBtdXRhdGVMb2FkaW5nLFxuICAgICAgYXBpLFxuICAgICAgZXh0cmFNZXRhZGF0YVJlZixcbiAgICAgIG9uUmVzcG9uc2UsXG4gICAgICBvbkZpbmlzaCxcbiAgICAgIG9uRXJyb3IsXG4gICAgICBzZXRFcnJvcixcbiAgICAgIG11dGF0ZVN0cmVhbURhdGEsXG4gICAgICBzdHJlYW1EYXRhUmVmLFxuICAgICAgc3RyZWFtUHJvdG9jb2wsXG4gICAgICBzZW5kRXh0cmFNZXNzYWdlRmllbGRzLFxuICAgICAgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsLFxuICAgICAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gICAgICBleHBlcmltZW50YWxfcHJlcGFyZVJlcXVlc3RCb2R5LFxuICAgICAgb25Ub29sQ2FsbCxcbiAgICAgIG1heFN0ZXBzLFxuICAgICAgbWVzc2FnZXNSZWYsXG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYsXG4gICAgICBnZW5lcmF0ZUlkMixcbiAgICAgIGZldGNoMixcbiAgICAgIGtlZXBMYXN0TWVzc2FnZU9uRXJyb3IsXG4gICAgICB0aHJvdHRsZVdhaXRNc1xuICAgIF1cbiAgKTtcbiAgY29uc3QgYXBwZW5kID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jIChtZXNzYWdlLCB7XG4gICAgICBvcHRpb25zLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgIHRvb2xzLFxuICAgICAgdG9vbF9jaG9pY2UsXG4gICAgICBkYXRhLFxuICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICBib2R5OiBib2R5MixcbiAgICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50c1xuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgdmFyIF9hLCBfYjtcbiAgICAgIGlmICghbWVzc2FnZS5pZCkge1xuICAgICAgICBtZXNzYWdlLmlkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzRm9yUmVxdWVzdCA9IGF3YWl0IHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QoXG4gICAgICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50c1xuICAgICAgKTtcbiAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzMiAhPSBudWxsID8gaGVhZGVyczIgOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IGJvZHkyICE9IG51bGwgPyBib2R5MiA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keVxuICAgICAgfTtcbiAgICAgIGNvbnN0IG1lc3NhZ2VzMiA9IG1lc3NhZ2VzUmVmLmN1cnJlbnQuY29uY2F0KHtcbiAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgaWQ6IChfYSA9IG1lc3NhZ2UuaWQpICE9IG51bGwgPyBfYSA6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIGNyZWF0ZWRBdDogKF9iID0gbWVzc2FnZS5jcmVhdGVkQXQpICE9IG51bGwgPyBfYiA6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICBleHBlcmltZW50YWxfYXR0YWNobWVudHM6IGF0dGFjaG1lbnRzRm9yUmVxdWVzdC5sZW5ndGggPiAwID8gYXR0YWNobWVudHNGb3JSZXF1ZXN0IDogdm9pZCAwXG4gICAgICB9KTtcbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXMyLFxuICAgICAgICBvcHRpb25zOiByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgaGVhZGVyczogcmVxdWVzdE9wdGlvbnMuaGVhZGVycyxcbiAgICAgICAgYm9keTogcmVxdWVzdE9wdGlvbnMuYm9keSxcbiAgICAgICAgZGF0YSxcbiAgICAgICAgLi4uZnVuY3Rpb25zICE9PSB2b2lkIDAgJiYgeyBmdW5jdGlvbnMgfSxcbiAgICAgICAgLi4uZnVuY3Rpb25fY2FsbCAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25fY2FsbCB9LFxuICAgICAgICAuLi50b29scyAhPT0gdm9pZCAwICYmIHsgdG9vbHMgfSxcbiAgICAgICAgLi4udG9vbF9jaG9pY2UgIT09IHZvaWQgMCAmJiB7IHRvb2xfY2hvaWNlIH1cbiAgICAgIH07XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QpO1xuICAgIH0sXG4gICAgW3RyaWdnZXJSZXF1ZXN0LCBnZW5lcmF0ZUlkMl1cbiAgKTtcbiAgY29uc3QgcmVsb2FkID0gdXNlQ2FsbGJhY2syKFxuICAgIGFzeW5jICh7XG4gICAgICBvcHRpb25zLFxuICAgICAgZnVuY3Rpb25zLFxuICAgICAgZnVuY3Rpb25fY2FsbCxcbiAgICAgIHRvb2xzLFxuICAgICAgdG9vbF9jaG9pY2UsXG4gICAgICBkYXRhLFxuICAgICAgaGVhZGVyczogaGVhZGVyczIsXG4gICAgICBib2R5OiBib2R5MlxuICAgIH0gPSB7fSkgPT4ge1xuICAgICAgaWYgKG1lc3NhZ2VzUmVmLmN1cnJlbnQubGVuZ3RoID09PSAwKVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIGNvbnN0IHJlcXVlc3RPcHRpb25zID0ge1xuICAgICAgICBoZWFkZXJzOiBoZWFkZXJzMiAhPSBudWxsID8gaGVhZGVyczIgOiBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IGJvZHkyICE9IG51bGwgPyBib2R5MiA6IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuYm9keVxuICAgICAgfTtcbiAgICAgIGNvbnN0IGxhc3RNZXNzYWdlID0gbWVzc2FnZXNSZWYuY3VycmVudFttZXNzYWdlc1JlZi5jdXJyZW50Lmxlbmd0aCAtIDFdO1xuICAgICAgaWYgKGxhc3RNZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIpIHtcbiAgICAgICAgY29uc3QgY2hhdFJlcXVlc3QyID0ge1xuICAgICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlc1JlZi5jdXJyZW50LnNsaWNlKDAsIC0xKSxcbiAgICAgICAgICBvcHRpb25zOiByZXF1ZXN0T3B0aW9ucyxcbiAgICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICAgIGJvZHk6IHJlcXVlc3RPcHRpb25zLmJvZHksXG4gICAgICAgICAgZGF0YSxcbiAgICAgICAgICAuLi5mdW5jdGlvbnMgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9ucyB9LFxuICAgICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSxcbiAgICAgICAgICAuLi50b29scyAhPT0gdm9pZCAwICYmIHsgdG9vbHMgfSxcbiAgICAgICAgICAuLi50b29sX2Nob2ljZSAhPT0gdm9pZCAwICYmIHsgdG9vbF9jaG9pY2UgfVxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QoY2hhdFJlcXVlc3QyKTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGNoYXRSZXF1ZXN0ID0ge1xuICAgICAgICBtZXNzYWdlczogbWVzc2FnZXNSZWYuY3VycmVudCxcbiAgICAgICAgb3B0aW9uczogcmVxdWVzdE9wdGlvbnMsXG4gICAgICAgIGhlYWRlcnM6IHJlcXVlc3RPcHRpb25zLmhlYWRlcnMsXG4gICAgICAgIGJvZHk6IHJlcXVlc3RPcHRpb25zLmJvZHksXG4gICAgICAgIGRhdGEsXG4gICAgICAgIC4uLmZ1bmN0aW9ucyAhPT0gdm9pZCAwICYmIHsgZnVuY3Rpb25zIH0sXG4gICAgICAgIC4uLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCAmJiB7IGZ1bmN0aW9uX2NhbGwgfSxcbiAgICAgICAgLi4udG9vbHMgIT09IHZvaWQgMCAmJiB7IHRvb2xzIH0sXG4gICAgICAgIC4uLnRvb2xfY2hvaWNlICE9PSB2b2lkIDAgJiYgeyB0b29sX2Nob2ljZSB9XG4gICAgICB9O1xuICAgICAgcmV0dXJuIHRyaWdnZXJSZXF1ZXN0KGNoYXRSZXF1ZXN0KTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrMigoKSA9PiB7XG4gICAgaWYgKGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSB7XG4gICAgICBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudC5hYm9ydCgpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzZXRNZXNzYWdlcyA9IHVzZUNhbGxiYWNrMihcbiAgICAobWVzc2FnZXMyKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIG1lc3NhZ2VzMiA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG1lc3NhZ2VzMiA9IG1lc3NhZ2VzMihtZXNzYWdlc1JlZi5jdXJyZW50KTtcbiAgICAgIH1cbiAgICAgIG11dGF0ZShtZXNzYWdlczIsIGZhbHNlKTtcbiAgICAgIG1lc3NhZ2VzUmVmLmN1cnJlbnQgPSBtZXNzYWdlczI7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBzZXREYXRhID0gdXNlQ2FsbGJhY2syKFxuICAgIChkYXRhKSA9PiB7XG4gICAgICBpZiAodHlwZW9mIGRhdGEgPT09IFwiZnVuY3Rpb25cIikge1xuICAgICAgICBkYXRhID0gZGF0YShzdHJlYW1EYXRhUmVmLmN1cnJlbnQpO1xuICAgICAgfVxuICAgICAgbXV0YXRlU3RyZWFtRGF0YShkYXRhLCBmYWxzZSk7XG4gICAgICBzdHJlYW1EYXRhUmVmLmN1cnJlbnQgPSBkYXRhO1xuICAgIH0sXG4gICAgW211dGF0ZVN0cmVhbURhdGFdXG4gICk7XG4gIGNvbnN0IFtpbnB1dCwgc2V0SW5wdXRdID0gdXNlU3RhdGUyKGluaXRpYWxJbnB1dCk7XG4gIGNvbnN0IGhhbmRsZVN1Ym1pdCA9IHVzZUNhbGxiYWNrMihcbiAgICBhc3luYyAoZXZlbnQsIG9wdGlvbnMgPSB7fSwgbWV0YWRhdGEpID0+IHtcbiAgICAgIHZhciBfYSwgX2IsIF9jLCBfZCwgX2U7XG4gICAgICAoX2EgPSBldmVudCA9PSBudWxsID8gdm9pZCAwIDogZXZlbnQucHJldmVudERlZmF1bHQpID09IG51bGwgPyB2b2lkIDAgOiBfYS5jYWxsKGV2ZW50KTtcbiAgICAgIGlmICghaW5wdXQgJiYgIW9wdGlvbnMuYWxsb3dFbXB0eVN1Ym1pdClcbiAgICAgICAgcmV0dXJuO1xuICAgICAgaWYgKG1ldGFkYXRhKSB7XG4gICAgICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQsXG4gICAgICAgICAgLi4ubWV0YWRhdGFcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnN0IGF0dGFjaG1lbnRzRm9yUmVxdWVzdCA9IGF3YWl0IHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QoXG4gICAgICAgIG9wdGlvbnMuZXhwZXJpbWVudGFsX2F0dGFjaG1lbnRzXG4gICAgICApO1xuICAgICAgY29uc3QgcmVxdWVzdE9wdGlvbnMgPSB7XG4gICAgICAgIGhlYWRlcnM6IChfYyA9IG9wdGlvbnMuaGVhZGVycykgIT0gbnVsbCA/IF9jIDogKF9iID0gb3B0aW9ucy5vcHRpb25zKSA9PSBudWxsID8gdm9pZCAwIDogX2IuaGVhZGVycyxcbiAgICAgICAgYm9keTogKF9lID0gb3B0aW9ucy5ib2R5KSAhPSBudWxsID8gX2UgOiAoX2QgPSBvcHRpb25zLm9wdGlvbnMpID09IG51bGwgPyB2b2lkIDAgOiBfZC5ib2R5XG4gICAgICB9O1xuICAgICAgY29uc3QgbWVzc2FnZXMyID0gIWlucHV0ICYmICFhdHRhY2htZW50c0ZvclJlcXVlc3QubGVuZ3RoICYmIG9wdGlvbnMuYWxsb3dFbXB0eVN1Ym1pdCA/IG1lc3NhZ2VzUmVmLmN1cnJlbnQgOiBtZXNzYWdlc1JlZi5jdXJyZW50LmNvbmNhdCh7XG4gICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICBjcmVhdGVkQXQ6IC8qIEBfX1BVUkVfXyAqLyBuZXcgRGF0ZSgpLFxuICAgICAgICByb2xlOiBcInVzZXJcIixcbiAgICAgICAgY29udGVudDogaW5wdXQsXG4gICAgICAgIGV4cGVyaW1lbnRhbF9hdHRhY2htZW50czogYXR0YWNobWVudHNGb3JSZXF1ZXN0Lmxlbmd0aCA+IDAgPyBhdHRhY2htZW50c0ZvclJlcXVlc3QgOiB2b2lkIDBcbiAgICAgIH0pO1xuICAgICAgY29uc3QgY2hhdFJlcXVlc3QgPSB7XG4gICAgICAgIG1lc3NhZ2VzOiBtZXNzYWdlczIsXG4gICAgICAgIG9wdGlvbnM6IHJlcXVlc3RPcHRpb25zLFxuICAgICAgICBoZWFkZXJzOiByZXF1ZXN0T3B0aW9ucy5oZWFkZXJzLFxuICAgICAgICBib2R5OiByZXF1ZXN0T3B0aW9ucy5ib2R5LFxuICAgICAgICBkYXRhOiBvcHRpb25zLmRhdGFcbiAgICAgIH07XG4gICAgICB0cmlnZ2VyUmVxdWVzdChjaGF0UmVxdWVzdCk7XG4gICAgICBzZXRJbnB1dChcIlwiKTtcbiAgICB9LFxuICAgIFtpbnB1dCwgZ2VuZXJhdGVJZDIsIHRyaWdnZXJSZXF1ZXN0XVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IChlKSA9PiB7XG4gICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICB9O1xuICBjb25zdCBhZGRUb29sUmVzdWx0ID0gKHtcbiAgICB0b29sQ2FsbElkLFxuICAgIHJlc3VsdFxuICB9KSA9PiB7XG4gICAgY29uc3QgdXBkYXRlZE1lc3NhZ2VzID0gbWVzc2FnZXNSZWYuY3VycmVudC5tYXAoXG4gICAgICAobWVzc2FnZSwgaW5kZXgsIGFycikgPT4gKFxuICAgICAgICAvLyB1cGRhdGUgdGhlIHRvb2wgY2FsbHMgaW4gdGhlIGxhc3QgYXNzaXN0YW50IG1lc3NhZ2U6XG4gICAgICAgIGluZGV4ID09PSBhcnIubGVuZ3RoIC0gMSAmJiBtZXNzYWdlLnJvbGUgPT09IFwiYXNzaXN0YW50XCIgJiYgbWVzc2FnZS50b29sSW52b2NhdGlvbnMgPyB7XG4gICAgICAgICAgLi4ubWVzc2FnZSxcbiAgICAgICAgICB0b29sSW52b2NhdGlvbnM6IG1lc3NhZ2UudG9vbEludm9jYXRpb25zLm1hcChcbiAgICAgICAgICAgICh0b29sSW52b2NhdGlvbikgPT4gdG9vbEludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdG9vbENhbGxJZCA/IHsgLi4udG9vbEludm9jYXRpb24sIHJlc3VsdCB9IDogdG9vbEludm9jYXRpb25cbiAgICAgICAgICApXG4gICAgICAgIH0gOiBtZXNzYWdlXG4gICAgICApXG4gICAgKTtcbiAgICBtdXRhdGUodXBkYXRlZE1lc3NhZ2VzLCBmYWxzZSk7XG4gICAgY29uc3QgbGFzdE1lc3NhZ2UgPSB1cGRhdGVkTWVzc2FnZXNbdXBkYXRlZE1lc3NhZ2VzLmxlbmd0aCAtIDFdO1xuICAgIGlmIChpc0Fzc2lzdGFudE1lc3NhZ2VXaXRoQ29tcGxldGVkVG9vbENhbGxzKGxhc3RNZXNzYWdlKSkge1xuICAgICAgdHJpZ2dlclJlcXVlc3QoeyBtZXNzYWdlczogdXBkYXRlZE1lc3NhZ2VzIH0pO1xuICAgIH1cbiAgfTtcbiAgcmV0dXJuIHtcbiAgICBtZXNzYWdlczogbWVzc2FnZXMgfHwgW10sXG4gICAgc2V0TWVzc2FnZXMsXG4gICAgZGF0YTogc3RyZWFtRGF0YSxcbiAgICBzZXREYXRhLFxuICAgIGVycm9yLFxuICAgIGFwcGVuZCxcbiAgICByZWxvYWQsXG4gICAgc3RvcCxcbiAgICBpbnB1dCxcbiAgICBzZXRJbnB1dCxcbiAgICBoYW5kbGVJbnB1dENoYW5nZSxcbiAgICBoYW5kbGVTdWJtaXQsXG4gICAgaXNMb2FkaW5nLFxuICAgIGFkZFRvb2xSZXN1bHQsXG4gICAgZXhwZXJpbWVudGFsX2FkZFRvb2xSZXN1bHQ6IGFkZFRvb2xSZXN1bHRcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzQXNzaXN0YW50TWVzc2FnZVdpdGhDb21wbGV0ZWRUb29sQ2FsbHMobWVzc2FnZSkge1xuICByZXR1cm4gbWVzc2FnZS5yb2xlID09PSBcImFzc2lzdGFudFwiICYmIG1lc3NhZ2UudG9vbEludm9jYXRpb25zICYmIG1lc3NhZ2UudG9vbEludm9jYXRpb25zLmxlbmd0aCA+IDAgJiYgbWVzc2FnZS50b29sSW52b2NhdGlvbnMuZXZlcnkoKHRvb2xJbnZvY2F0aW9uKSA9PiBcInJlc3VsdFwiIGluIHRvb2xJbnZvY2F0aW9uKTtcbn1cbmZ1bmN0aW9uIGNvdW50VHJhaWxpbmdBc3Npc3RhbnRNZXNzYWdlcyhtZXNzYWdlcykge1xuICBsZXQgY291bnQgPSAwO1xuICBmb3IgKGxldCBpID0gbWVzc2FnZXMubGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBpZiAobWVzc2FnZXNbaV0ucm9sZSA9PT0gXCJhc3Npc3RhbnRcIikge1xuICAgICAgY291bnQrKztcbiAgICB9IGVsc2Uge1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG4gIHJldHVybiBjb3VudDtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByZXBhcmVBdHRhY2htZW50c0ZvclJlcXVlc3QoYXR0YWNobWVudHNGcm9tT3B0aW9ucykge1xuICBpZiAoYXR0YWNobWVudHNGcm9tT3B0aW9ucyA9PSBudWxsKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIGlmIChhdHRhY2htZW50c0Zyb21PcHRpb25zIGluc3RhbmNlb2YgRmlsZUxpc3QpIHtcbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoXG4gICAgICBBcnJheS5mcm9tKGF0dGFjaG1lbnRzRnJvbU9wdGlvbnMpLm1hcChhc3luYyAoYXR0YWNobWVudCkgPT4ge1xuICAgICAgICBjb25zdCB7IG5hbWUsIHR5cGUgfSA9IGF0dGFjaG1lbnQ7XG4gICAgICAgIGNvbnN0IGRhdGFVcmwgPSBhd2FpdCBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XG4gICAgICAgICAgY29uc3QgcmVhZGVyID0gbmV3IEZpbGVSZWFkZXIoKTtcbiAgICAgICAgICByZWFkZXIub25sb2FkID0gKHJlYWRlckV2ZW50KSA9PiB7XG4gICAgICAgICAgICB2YXIgX2E7XG4gICAgICAgICAgICByZXNvbHZlKChfYSA9IHJlYWRlckV2ZW50LnRhcmdldCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnJlc3VsdCk7XG4gICAgICAgICAgfTtcbiAgICAgICAgICByZWFkZXIub25lcnJvciA9IChlcnJvcikgPT4gcmVqZWN0KGVycm9yKTtcbiAgICAgICAgICByZWFkZXIucmVhZEFzRGF0YVVSTChhdHRhY2htZW50KTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgbmFtZSxcbiAgICAgICAgICBjb250ZW50VHlwZTogdHlwZSxcbiAgICAgICAgICB1cmw6IGRhdGFVcmxcbiAgICAgICAgfTtcbiAgICAgIH0pXG4gICAgKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShhdHRhY2htZW50c0Zyb21PcHRpb25zKSkge1xuICAgIHJldHVybiBhdHRhY2htZW50c0Zyb21PcHRpb25zO1xuICB9XG4gIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgYXR0YWNobWVudHMgdHlwZVwiKTtcbn1cblxuLy8gc3JjL3VzZS1jb21wbGV0aW9uLnRzXG5pbXBvcnQge1xuICBjYWxsQ29tcGxldGlvbkFwaVxufSBmcm9tIFwiQGFpLXNkay91aS11dGlsc1wiO1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2sgYXMgdXNlQ2FsbGJhY2szLCB1c2VFZmZlY3QgYXMgdXNlRWZmZWN0MiwgdXNlSWQgYXMgdXNlSWQyLCB1c2VSZWYgYXMgdXNlUmVmMywgdXNlU3RhdGUgYXMgdXNlU3RhdGUzIH0gZnJvbSBcInJlYWN0XCI7XG5pbXBvcnQgdXNlU1dSMiBmcm9tIFwic3dyXCI7XG5mdW5jdGlvbiB1c2VDb21wbGV0aW9uKHtcbiAgYXBpID0gXCIvYXBpL2NvbXBsZXRpb25cIixcbiAgaWQsXG4gIGluaXRpYWxDb21wbGV0aW9uID0gXCJcIixcbiAgaW5pdGlhbElucHV0ID0gXCJcIixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGJvZHksXG4gIHN0cmVhbU1vZGUsXG4gIHN0cmVhbVByb3RvY29sLFxuICBmZXRjaDogZmV0Y2gyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgZXhwZXJpbWVudGFsX3Rocm90dGxlOiB0aHJvdHRsZVdhaXRNc1xufSA9IHt9KSB7XG4gIGlmIChzdHJlYW1Nb2RlKSB7XG4gICAgc3RyZWFtUHJvdG9jb2wgIT0gbnVsbCA/IHN0cmVhbVByb3RvY29sIDogc3RyZWFtUHJvdG9jb2wgPSBzdHJlYW1Nb2RlID09PSBcInRleHRcIiA/IFwidGV4dFwiIDogdm9pZCAwO1xuICB9XG4gIGNvbnN0IGhvb2tJZCA9IHVzZUlkMigpO1xuICBjb25zdCBjb21wbGV0aW9uSWQgPSBpZCB8fCBob29rSWQ7XG4gIGNvbnN0IHsgZGF0YSwgbXV0YXRlIH0gPSB1c2VTV1IyKFthcGksIGNvbXBsZXRpb25JZF0sIG51bGwsIHtcbiAgICBmYWxsYmFja0RhdGE6IGluaXRpYWxDb21wbGV0aW9uXG4gIH0pO1xuICBjb25zdCB7IGRhdGE6IGlzTG9hZGluZyA9IGZhbHNlLCBtdXRhdGU6IG11dGF0ZUxvYWRpbmcgfSA9IHVzZVNXUjIoXG4gICAgW2NvbXBsZXRpb25JZCwgXCJsb2FkaW5nXCJdLFxuICAgIG51bGxcbiAgKTtcbiAgY29uc3QgeyBkYXRhOiBzdHJlYW1EYXRhLCBtdXRhdGU6IG11dGF0ZVN0cmVhbURhdGEgfSA9IHVzZVNXUjIoW2NvbXBsZXRpb25JZCwgXCJzdHJlYW1EYXRhXCJdLCBudWxsKTtcbiAgY29uc3QgW2Vycm9yLCBzZXRFcnJvcl0gPSB1c2VTdGF0ZTModm9pZCAwKTtcbiAgY29uc3QgY29tcGxldGlvbiA9IGRhdGE7XG4gIGNvbnN0IFthYm9ydENvbnRyb2xsZXIsIHNldEFib3J0Q29udHJvbGxlcl0gPSB1c2VTdGF0ZTMobnVsbCk7XG4gIGNvbnN0IGV4dHJhTWV0YWRhdGFSZWYgPSB1c2VSZWYzKHtcbiAgICBjcmVkZW50aWFscyxcbiAgICBoZWFkZXJzLFxuICAgIGJvZHlcbiAgfSk7XG4gIHVzZUVmZmVjdDIoKCkgPT4ge1xuICAgIGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudCA9IHtcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVycyxcbiAgICAgIGJvZHlcbiAgICB9O1xuICB9LCBbY3JlZGVudGlhbHMsIGhlYWRlcnMsIGJvZHldKTtcbiAgY29uc3QgdHJpZ2dlclJlcXVlc3QgPSB1c2VDYWxsYmFjazMoXG4gICAgYXN5bmMgKHByb21wdCwgb3B0aW9ucykgPT4gY2FsbENvbXBsZXRpb25BcGkoe1xuICAgICAgYXBpLFxuICAgICAgcHJvbXB0LFxuICAgICAgY3JlZGVudGlhbHM6IGV4dHJhTWV0YWRhdGFSZWYuY3VycmVudC5jcmVkZW50aWFscyxcbiAgICAgIGhlYWRlcnM6IHsgLi4uZXh0cmFNZXRhZGF0YVJlZi5jdXJyZW50LmhlYWRlcnMsIC4uLm9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuaGVhZGVycyB9LFxuICAgICAgYm9keToge1xuICAgICAgICAuLi5leHRyYU1ldGFkYXRhUmVmLmN1cnJlbnQuYm9keSxcbiAgICAgICAgLi4ub3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5ib2R5XG4gICAgICB9LFxuICAgICAgc3RyZWFtUHJvdG9jb2wsXG4gICAgICBmZXRjaDogZmV0Y2gyLFxuICAgICAgLy8gdGhyb3R0bGUgc3RyZWFtZWQgdWkgdXBkYXRlczpcbiAgICAgIHNldENvbXBsZXRpb246IHRocm90dGxlKFxuICAgICAgICAoY29tcGxldGlvbjIpID0+IG11dGF0ZShjb21wbGV0aW9uMiwgZmFsc2UpLFxuICAgICAgICB0aHJvdHRsZVdhaXRNc1xuICAgICAgKSxcbiAgICAgIG9uRGF0YTogdGhyb3R0bGUoXG4gICAgICAgIChkYXRhMikgPT4gbXV0YXRlU3RyZWFtRGF0YShbLi4uc3RyZWFtRGF0YSAhPSBudWxsID8gc3RyZWFtRGF0YSA6IFtdLCAuLi5kYXRhMiAhPSBudWxsID8gZGF0YTIgOiBbXV0sIGZhbHNlKSxcbiAgICAgICAgdGhyb3R0bGVXYWl0TXNcbiAgICAgICksXG4gICAgICBzZXRMb2FkaW5nOiBtdXRhdGVMb2FkaW5nLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yXG4gICAgfSksXG4gICAgW1xuICAgICAgbXV0YXRlLFxuICAgICAgbXV0YXRlTG9hZGluZyxcbiAgICAgIGFwaSxcbiAgICAgIGV4dHJhTWV0YWRhdGFSZWYsXG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIsXG4gICAgICBvblJlc3BvbnNlLFxuICAgICAgb25GaW5pc2gsXG4gICAgICBvbkVycm9yLFxuICAgICAgc2V0RXJyb3IsXG4gICAgICBzdHJlYW1EYXRhLFxuICAgICAgc3RyZWFtUHJvdG9jb2wsXG4gICAgICBmZXRjaDIsXG4gICAgICBtdXRhdGVTdHJlYW1EYXRhLFxuICAgICAgdGhyb3R0bGVXYWl0TXNcbiAgICBdXG4gICk7XG4gIGNvbnN0IHN0b3AgPSB1c2VDYWxsYmFjazMoKCkgPT4ge1xuICAgIGlmIChhYm9ydENvbnRyb2xsZXIpIHtcbiAgICAgIGFib3J0Q29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIH1cbiAgfSwgW2Fib3J0Q29udHJvbGxlcl0pO1xuICBjb25zdCBzZXRDb21wbGV0aW9uID0gdXNlQ2FsbGJhY2szKFxuICAgIChjb21wbGV0aW9uMikgPT4ge1xuICAgICAgbXV0YXRlKGNvbXBsZXRpb24yLCBmYWxzZSk7XG4gICAgfSxcbiAgICBbbXV0YXRlXVxuICApO1xuICBjb25zdCBjb21wbGV0ZSA9IHVzZUNhbGxiYWNrMyhcbiAgICBhc3luYyAocHJvbXB0LCBvcHRpb25zKSA9PiB7XG4gICAgICByZXR1cm4gdHJpZ2dlclJlcXVlc3QocHJvbXB0LCBvcHRpb25zKTtcbiAgICB9LFxuICAgIFt0cmlnZ2VyUmVxdWVzdF1cbiAgKTtcbiAgY29uc3QgW2lucHV0LCBzZXRJbnB1dF0gPSB1c2VTdGF0ZTMoaW5pdGlhbElucHV0KTtcbiAgY29uc3QgaGFuZGxlU3VibWl0ID0gdXNlQ2FsbGJhY2szKFxuICAgIChldmVudCkgPT4ge1xuICAgICAgdmFyIF9hO1xuICAgICAgKF9hID0gZXZlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50LnByZXZlbnREZWZhdWx0KSA9PSBudWxsID8gdm9pZCAwIDogX2EuY2FsbChldmVudCk7XG4gICAgICByZXR1cm4gaW5wdXQgPyBjb21wbGV0ZShpbnB1dCkgOiB2b2lkIDA7XG4gICAgfSxcbiAgICBbaW5wdXQsIGNvbXBsZXRlXVxuICApO1xuICBjb25zdCBoYW5kbGVJbnB1dENoYW5nZSA9IHVzZUNhbGxiYWNrMyhcbiAgICAoZSkgPT4ge1xuICAgICAgc2V0SW5wdXQoZS50YXJnZXQudmFsdWUpO1xuICAgIH0sXG4gICAgW3NldElucHV0XVxuICApO1xuICByZXR1cm4ge1xuICAgIGNvbXBsZXRpb24sXG4gICAgY29tcGxldGUsXG4gICAgZXJyb3IsXG4gICAgc2V0Q29tcGxldGlvbixcbiAgICBzdG9wLFxuICAgIGlucHV0LFxuICAgIHNldElucHV0LFxuICAgIGhhbmRsZUlucHV0Q2hhbmdlLFxuICAgIGhhbmRsZVN1Ym1pdCxcbiAgICBpc0xvYWRpbmcsXG4gICAgZGF0YTogc3RyZWFtRGF0YVxuICB9O1xufVxuXG4vLyBzcmMvdXNlLW9iamVjdC50c1xuaW1wb3J0IHtcbiAgaXNBYm9ydEVycm9yIGFzIGlzQWJvcnRFcnJvcjIsXG4gIHNhZmVWYWxpZGF0ZVR5cGVzXG59IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQge1xuICBhc1NjaGVtYSxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBwYXJzZVBhcnRpYWxKc29uXG59IGZyb20gXCJAYWktc2RrL3VpLXV0aWxzXCI7XG5pbXBvcnQgeyB1c2VDYWxsYmFjayBhcyB1c2VDYWxsYmFjazQsIHVzZUlkIGFzIHVzZUlkMywgdXNlUmVmIGFzIHVzZVJlZjQsIHVzZVN0YXRlIGFzIHVzZVN0YXRlNCB9IGZyb20gXCJyZWFjdFwiO1xuaW1wb3J0IHVzZVNXUjMgZnJvbSBcInN3clwiO1xudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZmV0Y2g7XG5mdW5jdGlvbiB1c2VPYmplY3Qoe1xuICBhcGksXG4gIGlkLFxuICBzY2hlbWEsXG4gIC8vIHJlcXVpcmVkLCBpbiB0aGUgZnV0dXJlIHdlIHdpbGwgdXNlIGl0IGZvciB2YWxpZGF0aW9uXG4gIGluaXRpYWxWYWx1ZSxcbiAgZmV0Y2g6IGZldGNoMixcbiAgb25FcnJvcixcbiAgb25GaW5pc2gsXG4gIGhlYWRlcnNcbn0pIHtcbiAgY29uc3QgaG9va0lkID0gdXNlSWQzKCk7XG4gIGNvbnN0IGNvbXBsZXRpb25JZCA9IGlkICE9IG51bGwgPyBpZCA6IGhvb2tJZDtcbiAgY29uc3QgeyBkYXRhLCBtdXRhdGUgfSA9IHVzZVNXUjMoXG4gICAgW2FwaSwgY29tcGxldGlvbklkXSxcbiAgICBudWxsLFxuICAgIHsgZmFsbGJhY2tEYXRhOiBpbml0aWFsVmFsdWUgfVxuICApO1xuICBjb25zdCBbZXJyb3IsIHNldEVycm9yXSA9IHVzZVN0YXRlNCh2b2lkIDApO1xuICBjb25zdCBbaXNMb2FkaW5nLCBzZXRJc0xvYWRpbmddID0gdXNlU3RhdGU0KGZhbHNlKTtcbiAgY29uc3QgYWJvcnRDb250cm9sbGVyUmVmID0gdXNlUmVmNChudWxsKTtcbiAgY29uc3Qgc3RvcCA9IHVzZUNhbGxiYWNrNCgoKSA9PiB7XG4gICAgdmFyIF9hO1xuICAgIHRyeSB7XG4gICAgICAoX2EgPSBhYm9ydENvbnRyb2xsZXJSZWYuY3VycmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLmFib3J0KCk7XG4gICAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIH0gZmluYWxseSB7XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgIH1cbiAgfSwgW10pO1xuICBjb25zdCBzdWJtaXQgPSBhc3luYyAoaW5wdXQpID0+IHtcbiAgICB2YXIgX2E7XG4gICAgdHJ5IHtcbiAgICAgIG11dGF0ZSh2b2lkIDApO1xuICAgICAgc2V0SXNMb2FkaW5nKHRydWUpO1xuICAgICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICAgIGNvbnN0IGFib3J0Q29udHJvbGxlciA9IG5ldyBBYm9ydENvbnRyb2xsZXIoKTtcbiAgICAgIGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50ID0gYWJvcnRDb250cm9sbGVyO1xuICAgICAgY29uc3QgYWN0dWFsRmV0Y2ggPSBmZXRjaDIgIT0gbnVsbCA/IGZldGNoMiA6IGdldE9yaWdpbmFsRmV0Y2gyKCk7XG4gICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGFjdHVhbEZldGNoKGFwaSwge1xuICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgICB9LFxuICAgICAgICBzaWduYWw6IGFib3J0Q29udHJvbGxlci5zaWduYWwsXG4gICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGlucHV0KVxuICAgICAgfSk7XG4gICAgICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAoX2EgPSBhd2FpdCByZXNwb25zZS50ZXh0KCkpICE9IG51bGwgPyBfYSA6IFwiRmFpbGVkIHRvIGZldGNoIHRoZSByZXNwb25zZS5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgICB9XG4gICAgICBsZXQgYWNjdW11bGF0ZWRUZXh0ID0gXCJcIjtcbiAgICAgIGxldCBsYXRlc3RPYmplY3QgPSB2b2lkIDA7XG4gICAgICBhd2FpdCByZXNwb25zZS5ib2R5LnBpcGVUaHJvdWdoKG5ldyBUZXh0RGVjb2RlclN0cmVhbSgpKS5waXBlVG8oXG4gICAgICAgIG5ldyBXcml0YWJsZVN0cmVhbSh7XG4gICAgICAgICAgd3JpdGUoY2h1bmspIHtcbiAgICAgICAgICAgIGFjY3VtdWxhdGVkVGV4dCArPSBjaHVuaztcbiAgICAgICAgICAgIGNvbnN0IHsgdmFsdWUgfSA9IHBhcnNlUGFydGlhbEpzb24oYWNjdW11bGF0ZWRUZXh0KTtcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRPYmplY3QgPSB2YWx1ZTtcbiAgICAgICAgICAgIGlmICghaXNEZWVwRXF1YWxEYXRhKGxhdGVzdE9iamVjdCwgY3VycmVudE9iamVjdCkpIHtcbiAgICAgICAgICAgICAgbGF0ZXN0T2JqZWN0ID0gY3VycmVudE9iamVjdDtcbiAgICAgICAgICAgICAgbXV0YXRlKGN1cnJlbnRPYmplY3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgY2xvc2UoKSB7XG4gICAgICAgICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQgPSBudWxsO1xuICAgICAgICAgICAgaWYgKG9uRmluaXNoICE9IG51bGwpIHtcbiAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGlvblJlc3VsdCA9IHNhZmVWYWxpZGF0ZVR5cGVzKHtcbiAgICAgICAgICAgICAgICB2YWx1ZTogbGF0ZXN0T2JqZWN0LFxuICAgICAgICAgICAgICAgIHNjaGVtYTogYXNTY2hlbWEoc2NoZW1hKVxuICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgb25GaW5pc2goXG4gICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdC5zdWNjZXNzID8geyBvYmplY3Q6IHZhbGlkYXRpb25SZXN1bHQudmFsdWUsIGVycm9yOiB2b2lkIDAgfSA6IHsgb2JqZWN0OiB2b2lkIDAsIGVycm9yOiB2YWxpZGF0aW9uUmVzdWx0LmVycm9yIH1cbiAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH0pXG4gICAgICApO1xuICAgIH0gY2F0Y2ggKGVycm9yMikge1xuICAgICAgaWYgKGlzQWJvcnRFcnJvcjIoZXJyb3IyKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAob25FcnJvciAmJiBlcnJvcjIgaW5zdGFuY2VvZiBFcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycm9yMik7XG4gICAgICB9XG4gICAgICBzZXRJc0xvYWRpbmcoZmFsc2UpO1xuICAgICAgc2V0RXJyb3IoZXJyb3IyIGluc3RhbmNlb2YgRXJyb3IgPyBlcnJvcjIgOiBuZXcgRXJyb3IoU3RyaW5nKGVycm9yMikpKTtcbiAgICB9XG4gIH07XG4gIHJldHVybiB7XG4gICAgc2V0SW5wdXQ6IHN1Ym1pdCxcbiAgICAvLyBEZXByZWNhdGVkXG4gICAgc3VibWl0LFxuICAgIG9iamVjdDogZGF0YSxcbiAgICBlcnJvcixcbiAgICBpc0xvYWRpbmcsXG4gICAgc3RvcFxuICB9O1xufVxudmFyIGV4cGVyaW1lbnRhbF91c2VPYmplY3QgPSB1c2VPYmplY3Q7XG5leHBvcnQge1xuICBleHBlcmltZW50YWxfdXNlQXNzaXN0YW50LFxuICBleHBlcmltZW50YWxfdXNlT2JqZWN0LFxuICB1c2VBc3Npc3RhbnQsXG4gIHVzZUNoYXQsXG4gIHVzZUNvbXBsZXRpb25cbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/react/dist/index.mjs\n");

/***/ }),

/***/ "(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   formatStreamPart: () => (/* binding */ formatStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   parseStreamPart: () => (/* binding */ parseStreamPart),\n/* harmony export */   processChatStream: () => (/* binding */ processChatStream),\n/* harmony export */   processDataProtocolResponse: () => (/* binding */ processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* binding */ readDataStream),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(ssr)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! secure-json-parse */ \"(ssr)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(ssr)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/index.ts\n\n\n// src/process-data-protocol-response.ts\n\n\n// src/parse-partial-json.ts\n\n\n// src/fix-json.ts\nfunction fixJson(input) {\n  const stack = [\"ROOT\"];\n  let lastValidIndex = -1;\n  let literalStart = null;\n  function processValueStart(char, i, swapState) {\n    {\n      switch (char) {\n        case '\"': {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_STRING\");\n          break;\n        }\n        case \"f\":\n        case \"t\":\n        case \"n\": {\n          lastValidIndex = i;\n          literalStart = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_LITERAL\");\n          break;\n        }\n        case \"-\": {\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"0\":\n        case \"1\":\n        case \"2\":\n        case \"3\":\n        case \"4\":\n        case \"5\":\n        case \"6\":\n        case \"7\":\n        case \"8\":\n        case \"9\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_NUMBER\");\n          break;\n        }\n        case \"{\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_OBJECT_START\");\n          break;\n        }\n        case \"[\": {\n          lastValidIndex = i;\n          stack.pop();\n          stack.push(swapState);\n          stack.push(\"INSIDE_ARRAY_START\");\n          break;\n        }\n      }\n    }\n  }\n  function processAfterObjectValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n        break;\n      }\n      case \"}\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  function processAfterArrayValue(char, i) {\n    switch (char) {\n      case \",\": {\n        stack.pop();\n        stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n        break;\n      }\n      case \"]\": {\n        lastValidIndex = i;\n        stack.pop();\n        break;\n      }\n    }\n  }\n  for (let i = 0; i < input.length; i++) {\n    const char = input[i];\n    const currentState = stack[stack.length - 1];\n    switch (currentState) {\n      case \"ROOT\":\n        processValueStart(char, i, \"FINISH\");\n        break;\n      case \"INSIDE_OBJECT_START\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n          case \"}\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_COMMA\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_KEY\": {\n        switch (char) {\n          case \":\": {\n            stack.pop();\n            stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_OBJECT_BEFORE_VALUE\": {\n        processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        processAfterObjectValue(char, i);\n        break;\n      }\n      case \"INSIDE_STRING\": {\n        switch (char) {\n          case '\"': {\n            stack.pop();\n            lastValidIndex = i;\n            break;\n          }\n          case \"\\\\\": {\n            stack.push(\"INSIDE_STRING_ESCAPE\");\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_START\": {\n        switch (char) {\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        switch (char) {\n          case \",\": {\n            stack.pop();\n            stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n            break;\n          }\n          case \"]\": {\n            lastValidIndex = i;\n            stack.pop();\n            break;\n          }\n          default: {\n            lastValidIndex = i;\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_ARRAY_AFTER_COMMA\": {\n        processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n        break;\n      }\n      case \"INSIDE_STRING_ESCAPE\": {\n        stack.pop();\n        lastValidIndex = i;\n        break;\n      }\n      case \"INSIDE_NUMBER\": {\n        switch (char) {\n          case \"0\":\n          case \"1\":\n          case \"2\":\n          case \"3\":\n          case \"4\":\n          case \"5\":\n          case \"6\":\n          case \"7\":\n          case \"8\":\n          case \"9\": {\n            lastValidIndex = i;\n            break;\n          }\n          case \"e\":\n          case \"E\":\n          case \"-\":\n          case \".\": {\n            break;\n          }\n          case \",\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"}\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n              processAfterObjectValue(char, i);\n            }\n            break;\n          }\n          case \"]\": {\n            stack.pop();\n            if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n              processAfterArrayValue(char, i);\n            }\n            break;\n          }\n          default: {\n            stack.pop();\n            break;\n          }\n        }\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, i + 1);\n        if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n          stack.pop();\n          if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n            processAfterObjectValue(char, i);\n          } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n            processAfterArrayValue(char, i);\n          }\n        } else {\n          lastValidIndex = i;\n        }\n        break;\n      }\n    }\n  }\n  let result = input.slice(0, lastValidIndex + 1);\n  for (let i = stack.length - 1; i >= 0; i--) {\n    const state = stack[i];\n    switch (state) {\n      case \"INSIDE_STRING\": {\n        result += '\"';\n        break;\n      }\n      case \"INSIDE_OBJECT_KEY\":\n      case \"INSIDE_OBJECT_AFTER_KEY\":\n      case \"INSIDE_OBJECT_AFTER_COMMA\":\n      case \"INSIDE_OBJECT_START\":\n      case \"INSIDE_OBJECT_BEFORE_VALUE\":\n      case \"INSIDE_OBJECT_AFTER_VALUE\": {\n        result += \"}\";\n        break;\n      }\n      case \"INSIDE_ARRAY_START\":\n      case \"INSIDE_ARRAY_AFTER_COMMA\":\n      case \"INSIDE_ARRAY_AFTER_VALUE\": {\n        result += \"]\";\n        break;\n      }\n      case \"INSIDE_LITERAL\": {\n        const partialLiteral = input.substring(literalStart, input.length);\n        if (\"true\".startsWith(partialLiteral)) {\n          result += \"true\".slice(partialLiteral.length);\n        } else if (\"false\".startsWith(partialLiteral)) {\n          result += \"false\".slice(partialLiteral.length);\n        } else if (\"null\".startsWith(partialLiteral)) {\n          result += \"null\".slice(partialLiteral.length);\n        }\n      }\n    }\n  }\n  return result;\n}\n\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n  if (jsonText === void 0) {\n    return { value: void 0, state: \"undefined-input\" };\n  }\n  try {\n    return {\n      value: secure_json_parse__WEBPACK_IMPORTED_MODULE_0__.parse(jsonText),\n      state: \"successful-parse\"\n    };\n  } catch (ignored) {\n    try {\n      return {\n        value: secure_json_parse__WEBPACK_IMPORTED_MODULE_0__.parse(fixJson(jsonText)),\n        state: \"repaired-parse\"\n      };\n    } catch (ignored2) {\n    }\n  }\n  return { value: void 0, state: \"failed-parse\" };\n}\n\n// src/stream-parts.ts\nvar textStreamPart = {\n  code: \"0\",\n  name: \"text\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"text\" parts expect a string value.');\n    }\n    return { type: \"text\", value };\n  }\n};\nvar functionCallStreamPart = {\n  code: \"1\",\n  name: \"function_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n      throw new Error(\n        '\"function_call\" parts expect an object with a \"function_call\" property.'\n      );\n    }\n    return {\n      type: \"function_call\",\n      value\n    };\n  }\n};\nvar dataStreamPart = {\n  code: \"2\",\n  name: \"data\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"data\" parts expect an array value.');\n    }\n    return { type: \"data\", value };\n  }\n};\nvar errorStreamPart = {\n  code: \"3\",\n  name: \"error\",\n  parse: (value) => {\n    if (typeof value !== \"string\") {\n      throw new Error('\"error\" parts expect a string value.');\n    }\n    return { type: \"error\", value };\n  }\n};\nvar assistantMessageStreamPart = {\n  code: \"4\",\n  name: \"assistant_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every(\n      (item) => item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\"\n    )) {\n      throw new Error(\n        '\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.'\n      );\n    }\n    return {\n      type: \"assistant_message\",\n      value\n    };\n  }\n};\nvar assistantControlDataStreamPart = {\n  code: \"5\",\n  name: \"assistant_control_data\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n      throw new Error(\n        '\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.'\n      );\n    }\n    return {\n      type: \"assistant_control_data\",\n      value: {\n        threadId: value.threadId,\n        messageId: value.messageId\n      }\n    };\n  }\n};\nvar dataMessageStreamPart = {\n  code: \"6\",\n  name: \"data_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n      throw new Error(\n        '\"data_message\" parts expect an object with a \"role\" and \"data\" property.'\n      );\n    }\n    return {\n      type: \"data_message\",\n      value\n    };\n  }\n};\nvar toolCallsStreamPart = {\n  code: \"7\",\n  name: \"tool_calls\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some(\n      (tc) => tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\"\n    )) {\n      throw new Error(\n        '\"tool_calls\" parts expect an object with a ToolCallPayload.'\n      );\n    }\n    return {\n      type: \"tool_calls\",\n      value\n    };\n  }\n};\nvar messageAnnotationsStreamPart = {\n  code: \"8\",\n  name: \"message_annotations\",\n  parse: (value) => {\n    if (!Array.isArray(value)) {\n      throw new Error('\"message_annotations\" parts expect an array value.');\n    }\n    return { type: \"message_annotations\", value };\n  }\n};\nvar toolCallStreamPart = {\n  code: \"9\",\n  name: \"tool_call\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n      throw new Error(\n        '\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.'\n      );\n    }\n    return {\n      type: \"tool_call\",\n      value\n    };\n  }\n};\nvar toolResultStreamPart = {\n  code: \"a\",\n  name: \"tool_result\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n      throw new Error(\n        '\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.'\n      );\n    }\n    return {\n      type: \"tool_result\",\n      value\n    };\n  }\n};\nvar toolCallStreamingStartStreamPart = {\n  code: \"b\",\n  name: \"tool_call_streaming_start\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n      throw new Error(\n        '\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_streaming_start\",\n      value\n    };\n  }\n};\nvar toolCallDeltaStreamPart = {\n  code: \"c\",\n  name: \"tool_call_delta\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n      throw new Error(\n        '\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.'\n      );\n    }\n    return {\n      type: \"tool_call_delta\",\n      value\n    };\n  }\n};\nvar finishMessageStreamPart = {\n  code: \"d\",\n  name: \"finish_message\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_message\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    return {\n      type: \"finish_message\",\n      value: result\n    };\n  }\n};\nvar finishStepStreamPart = {\n  code: \"e\",\n  name: \"finish_step\",\n  parse: (value) => {\n    if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n      throw new Error(\n        '\"finish_step\" parts expect an object with a \"finishReason\" property.'\n      );\n    }\n    const result = {\n      finishReason: value.finishReason,\n      isContinued: false\n    };\n    if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n      result.usage = {\n        promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n        completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n      };\n    }\n    if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n      result.isContinued = value.isContinued;\n    }\n    return {\n      type: \"finish_step\",\n      value: result\n    };\n  }\n};\nvar streamParts = [\n  textStreamPart,\n  functionCallStreamPart,\n  dataStreamPart,\n  errorStreamPart,\n  assistantMessageStreamPart,\n  assistantControlDataStreamPart,\n  dataMessageStreamPart,\n  toolCallsStreamPart,\n  messageAnnotationsStreamPart,\n  toolCallStreamPart,\n  toolResultStreamPart,\n  toolCallStreamingStartStreamPart,\n  toolCallDeltaStreamPart,\n  finishMessageStreamPart,\n  finishStepStreamPart\n];\nvar streamPartsByCode = {\n  [textStreamPart.code]: textStreamPart,\n  [functionCallStreamPart.code]: functionCallStreamPart,\n  [dataStreamPart.code]: dataStreamPart,\n  [errorStreamPart.code]: errorStreamPart,\n  [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n  [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n  [dataMessageStreamPart.code]: dataMessageStreamPart,\n  [toolCallsStreamPart.code]: toolCallsStreamPart,\n  [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n  [toolCallStreamPart.code]: toolCallStreamPart,\n  [toolResultStreamPart.code]: toolResultStreamPart,\n  [toolCallStreamingStartStreamPart.code]: toolCallStreamingStartStreamPart,\n  [toolCallDeltaStreamPart.code]: toolCallDeltaStreamPart,\n  [finishMessageStreamPart.code]: finishMessageStreamPart,\n  [finishStepStreamPart.code]: finishStepStreamPart\n};\nvar StreamStringPrefixes = {\n  [textStreamPart.name]: textStreamPart.code,\n  [functionCallStreamPart.name]: functionCallStreamPart.code,\n  [dataStreamPart.name]: dataStreamPart.code,\n  [errorStreamPart.name]: errorStreamPart.code,\n  [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n  [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n  [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n  [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n  [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n  [toolCallStreamPart.name]: toolCallStreamPart.code,\n  [toolResultStreamPart.name]: toolResultStreamPart.code,\n  [toolCallStreamingStartStreamPart.name]: toolCallStreamingStartStreamPart.code,\n  [toolCallDeltaStreamPart.name]: toolCallDeltaStreamPart.code,\n  [finishMessageStreamPart.name]: finishMessageStreamPart.code,\n  [finishStepStreamPart.name]: finishStepStreamPart.code\n};\nvar validCodes = streamParts.map((part) => part.code);\nvar parseStreamPart = (line) => {\n  const firstSeparatorIndex = line.indexOf(\":\");\n  if (firstSeparatorIndex === -1) {\n    throw new Error(\"Failed to parse stream string. No separator found.\");\n  }\n  const prefix = line.slice(0, firstSeparatorIndex);\n  if (!validCodes.includes(prefix)) {\n    throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n  }\n  const code = prefix;\n  const textValue = line.slice(firstSeparatorIndex + 1);\n  const jsonValue = JSON.parse(textValue);\n  return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n  const streamPart = streamParts.find((part) => part.name === type);\n  if (!streamPart) {\n    throw new Error(`Invalid stream part type: ${type}`);\n  }\n  return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n\n// src/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n  const concatenatedChunks = new Uint8Array(totalLength);\n  let offset = 0;\n  for (const chunk of chunks) {\n    concatenatedChunks.set(chunk, offset);\n    offset += chunk.length;\n  }\n  chunks.length = 0;\n  return concatenatedChunks;\n}\nasync function* readDataStream(reader, {\n  isAborted\n} = {}) {\n  const decoder = new TextDecoder();\n  const chunks = [];\n  let totalLength = 0;\n  while (true) {\n    const { value } = await reader.read();\n    if (value) {\n      chunks.push(value);\n      totalLength += value.length;\n      if (value[value.length - 1] !== NEWLINE) {\n        continue;\n      }\n    }\n    if (chunks.length === 0) {\n      break;\n    }\n    const concatenatedChunks = concatChunks(chunks, totalLength);\n    totalLength = 0;\n    const streamParts2 = decoder.decode(concatenatedChunks, { stream: true }).split(\"\\n\").filter((line) => line !== \"\").map(parseStreamPart);\n    for (const streamPart of streamParts2) {\n      yield streamPart;\n    }\n    if (isAborted == null ? void 0 : isAborted()) {\n      reader.cancel();\n      break;\n    }\n  }\n}\n\n// src/process-data-protocol-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n  if (!message || !annotations || !annotations.length)\n    return message;\n  return { ...message, annotations: [...annotations] };\n}\nasync function processDataProtocolResponse({\n  reader,\n  abortControllerRef,\n  update,\n  onToolCall,\n  onFinish,\n  generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId,\n  getCurrentDate = () => /* @__PURE__ */ new Date()\n}) {\n  var _a;\n  const createdAt = getCurrentDate();\n  let prefixMap = {};\n  let nextPrefixMap = void 0;\n  const previousMessages = [];\n  const data = [];\n  let messageAnnotations = void 0;\n  const partialToolCalls = {};\n  let usage = {\n    completionTokens: NaN,\n    promptTokens: NaN,\n    totalTokens: NaN\n  };\n  let finishReason = \"unknown\";\n  for await (const { type, value } of readDataStream(reader, {\n    isAborted: () => (abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n  })) {\n    if (type === \"error\") {\n      throw new Error(value);\n    }\n    if (type === \"finish_step\") {\n      if (!value.isContinued) {\n        nextPrefixMap = {};\n      }\n      continue;\n    }\n    if (type === \"finish_message\") {\n      finishReason = value.finishReason;\n      if (value.usage != null) {\n        const { completionTokens, promptTokens } = value.usage;\n        usage = {\n          completionTokens,\n          promptTokens,\n          totalTokens: completionTokens + promptTokens\n        };\n      }\n      continue;\n    }\n    if (nextPrefixMap != null && (type === \"text\" || type === \"tool_call\" || type === \"tool_call_streaming_start\" || type === \"tool_call_delta\" || type === \"tool_result\")) {\n      if (prefixMap.text) {\n        previousMessages.push(prefixMap.text);\n      }\n      if (prefixMap.function_call) {\n        previousMessages.push(prefixMap.function_call);\n      }\n      if (prefixMap.tool_calls) {\n        previousMessages.push(prefixMap.tool_calls);\n      }\n      prefixMap = nextPrefixMap;\n      nextPrefixMap = void 0;\n    }\n    if (type === \"text\") {\n      if (prefixMap[\"text\"]) {\n        prefixMap[\"text\"] = {\n          ...prefixMap[\"text\"],\n          content: (prefixMap[\"text\"].content || \"\") + value\n        };\n      } else {\n        prefixMap[\"text\"] = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: value,\n          createdAt\n        };\n      }\n    }\n    if (type === \"tool_call_streaming_start\") {\n      if (prefixMap.text == null) {\n        prefixMap.text = {\n          id: generateId2(),\n          role: \"assistant\",\n          content: \"\",\n          createdAt\n        };\n      }\n      if (prefixMap.text.toolInvocations == null) {\n        prefixMap.text.toolInvocations = [];\n      }\n      partialToolCalls[value.toolCallId] = {\n        text: \"\",\n        toolName: value.toolName,\n        prefixMapIndex: prefixMap.text.toolInvocations.length\n      };\n      prefixMap.text.toolInvocations.push({\n        state: \"partial-call\",\n        toolCallId: value.toolCallId,\n        toolName: value.toolName,\n        args: void 0\n      });\n    } else if (type === \"tool_call_delta\") {\n      const partialToolCall = partialToolCalls[value.toolCallId];\n      partialToolCall.text += value.argsTextDelta;\n      const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n      prefixMap.text.toolInvocations[partialToolCall.prefixMapIndex] = {\n        state: \"partial-call\",\n        toolCallId: value.toolCallId,\n        toolName: partialToolCall.toolName,\n        args: partialArgs\n      };\n      prefixMap.text.internalUpdateId = generateId2();\n    } else if (type === \"tool_call\") {\n      if (partialToolCalls[value.toolCallId] != null) {\n        prefixMap.text.toolInvocations[partialToolCalls[value.toolCallId].prefixMapIndex] = { state: \"call\", ...value };\n      } else {\n        if (prefixMap.text == null) {\n          prefixMap.text = {\n            id: generateId2(),\n            role: \"assistant\",\n            content: \"\",\n            createdAt\n          };\n        }\n        if (prefixMap.text.toolInvocations == null) {\n          prefixMap.text.toolInvocations = [];\n        }\n        prefixMap.text.toolInvocations.push({\n          state: \"call\",\n          ...value\n        });\n      }\n      prefixMap.text.internalUpdateId = generateId2();\n      if (onToolCall) {\n        const result = await onToolCall({ toolCall: value });\n        if (result != null) {\n          prefixMap.text.toolInvocations[prefixMap.text.toolInvocations.length - 1] = { state: \"result\", ...value, result };\n        }\n      }\n    } else if (type === \"tool_result\") {\n      const toolInvocations = (_a = prefixMap.text) == null ? void 0 : _a.toolInvocations;\n      if (toolInvocations == null) {\n        throw new Error(\"tool_result must be preceded by a tool_call\");\n      }\n      const toolInvocationIndex = toolInvocations.findIndex(\n        (invocation) => invocation.toolCallId === value.toolCallId\n      );\n      if (toolInvocationIndex === -1) {\n        throw new Error(\n          \"tool_result must be preceded by a tool_call with the same toolCallId\"\n        );\n      }\n      toolInvocations[toolInvocationIndex] = {\n        ...toolInvocations[toolInvocationIndex],\n        state: \"result\",\n        ...value\n      };\n    }\n    let functionCallMessage = null;\n    if (type === \"function_call\") {\n      prefixMap[\"function_call\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        function_call: value.function_call,\n        name: value.function_call.name,\n        createdAt\n      };\n      functionCallMessage = prefixMap[\"function_call\"];\n    }\n    let toolCallMessage = null;\n    if (type === \"tool_calls\") {\n      prefixMap[\"tool_calls\"] = {\n        id: generateId2(),\n        role: \"assistant\",\n        content: \"\",\n        tool_calls: value.tool_calls,\n        createdAt\n      };\n      toolCallMessage = prefixMap[\"tool_calls\"];\n    }\n    if (type === \"data\") {\n      data.push(...value);\n    }\n    let responseMessage = prefixMap[\"text\"];\n    if (type === \"message_annotations\") {\n      if (!messageAnnotations) {\n        messageAnnotations = [...value];\n      } else {\n        messageAnnotations.push(...value);\n      }\n      functionCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"function_call\"],\n        messageAnnotations\n      );\n      toolCallMessage = assignAnnotationsToMessage(\n        prefixMap[\"tool_calls\"],\n        messageAnnotations\n      );\n      responseMessage = assignAnnotationsToMessage(\n        prefixMap[\"text\"],\n        messageAnnotations\n      );\n      if (prefixMap.text != null) {\n        prefixMap.text.internalUpdateId = generateId2();\n      }\n    }\n    if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n      if (prefixMap.text) {\n        prefixMap.text.annotations = [...messageAnnotations];\n      }\n      if (prefixMap.function_call) {\n        prefixMap.function_call.annotations = [...messageAnnotations];\n      }\n      if (prefixMap.tool_calls) {\n        prefixMap.tool_calls.annotations = [...messageAnnotations];\n      }\n    }\n    const merged = [functionCallMessage, toolCallMessage, responseMessage].filter(Boolean).map((message) => ({\n      ...assignAnnotationsToMessage(message, messageAnnotations)\n    }));\n    update([...previousMessages, ...merged], [...data]);\n  }\n  onFinish == null ? void 0 : onFinish({ message: prefixMap.text, finishReason, usage });\n  return {\n    messages: [\n      prefixMap.text,\n      prefixMap.function_call,\n      prefixMap.tool_calls\n    ].filter(Boolean),\n    data\n  };\n}\n\n// src/call-chat-api.ts\nvar getOriginalFetch = () => fetch;\nasync function callChatApi({\n  api,\n  body,\n  streamProtocol = \"data\",\n  credentials,\n  headers,\n  abortController,\n  restoreMessagesOnFailure,\n  onResponse,\n  onUpdate,\n  onFinish,\n  onToolCall,\n  generateId: generateId2,\n  fetch: fetch2 = getOriginalFetch()\n}) {\n  var _a, _b;\n  const response = await fetch2(api, {\n    method: \"POST\",\n    body: JSON.stringify(body),\n    headers: {\n      \"Content-Type\": \"application/json\",\n      ...headers\n    },\n    signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n    credentials\n  }).catch((err) => {\n    restoreMessagesOnFailure();\n    throw err;\n  });\n  if (onResponse) {\n    try {\n      await onResponse(response);\n    } catch (err) {\n      throw err;\n    }\n  }\n  if (!response.ok) {\n    restoreMessagesOnFailure();\n    throw new Error(\n      (_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\"\n    );\n  }\n  if (!response.body) {\n    throw new Error(\"The response body is empty.\");\n  }\n  const reader = response.body.getReader();\n  switch (streamProtocol) {\n    case \"text\": {\n      const decoder = createChunkDecoder();\n      const resultMessage = {\n        id: generateId2(),\n        createdAt: /* @__PURE__ */ new Date(),\n        role: \"assistant\",\n        content: \"\"\n      };\n      while (true) {\n        const { done, value } = await reader.read();\n        if (done) {\n          break;\n        }\n        resultMessage.content += decoder(value);\n        onUpdate([{ ...resultMessage }], []);\n        if ((abortController == null ? void 0 : abortController()) === null) {\n          reader.cancel();\n          break;\n        }\n      }\n      onFinish == null ? void 0 : onFinish(resultMessage, {\n        usage: { completionTokens: NaN, promptTokens: NaN, totalTokens: NaN },\n        finishReason: \"unknown\"\n      });\n      return {\n        messages: [resultMessage],\n        data: []\n      };\n    }\n    case \"data\": {\n      return await processDataProtocolResponse({\n        reader,\n        abortControllerRef: abortController != null ? { current: abortController() } : void 0,\n        update: onUpdate,\n        onToolCall,\n        onFinish({ message, finishReason, usage }) {\n          if (onFinish && message != null) {\n            onFinish(message, { usage, finishReason });\n          }\n        },\n        generateId: generateId2\n      });\n    }\n    default: {\n      const exhaustiveCheck = streamProtocol;\n      throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n    }\n  }\n}\n\n// src/call-completion-api.ts\nvar getOriginalFetch2 = () => fetch;\nasync function callCompletionApi({\n  api,\n  prompt,\n  credentials,\n  headers,\n  body,\n  streamProtocol = \"data\",\n  setCompletion,\n  setLoading,\n  setError,\n  setAbortController,\n  onResponse,\n  onFinish,\n  onError,\n  onData,\n  fetch: fetch2 = getOriginalFetch2()\n}) {\n  try {\n    setLoading(true);\n    setError(void 0);\n    const abortController = new AbortController();\n    setAbortController(abortController);\n    setCompletion(\"\");\n    const res = await fetch2(api, {\n      method: \"POST\",\n      body: JSON.stringify({\n        prompt,\n        ...body\n      }),\n      credentials,\n      headers: {\n        \"Content-Type\": \"application/json\",\n        ...headers\n      },\n      signal: abortController.signal\n    }).catch((err) => {\n      throw err;\n    });\n    if (onResponse) {\n      try {\n        await onResponse(res);\n      } catch (err) {\n        throw err;\n      }\n    }\n    if (!res.ok) {\n      throw new Error(\n        await res.text() || \"Failed to fetch the chat response.\"\n      );\n    }\n    if (!res.body) {\n      throw new Error(\"The response body is empty.\");\n    }\n    let result = \"\";\n    const reader = res.body.getReader();\n    switch (streamProtocol) {\n      case \"text\": {\n        const decoder = createChunkDecoder();\n        while (true) {\n          const { done, value } = await reader.read();\n          if (done) {\n            break;\n          }\n          result += decoder(value);\n          setCompletion(result);\n          if (abortController === null) {\n            reader.cancel();\n            break;\n          }\n        }\n        break;\n      }\n      case \"data\": {\n        for await (const { type, value } of readDataStream(reader, {\n          isAborted: () => abortController === null\n        })) {\n          switch (type) {\n            case \"text\": {\n              result += value;\n              setCompletion(result);\n              break;\n            }\n            case \"data\": {\n              onData == null ? void 0 : onData(value);\n              break;\n            }\n          }\n        }\n        break;\n      }\n      default: {\n        const exhaustiveCheck = streamProtocol;\n        throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n      }\n    }\n    if (onFinish) {\n      onFinish(prompt, result);\n    }\n    setAbortController(null);\n    return result;\n  } catch (err) {\n    if (err.name === \"AbortError\") {\n      setAbortController(null);\n      return null;\n    }\n    if (err instanceof Error) {\n      if (onError) {\n        onError(err);\n      }\n    }\n    setError(err);\n  } finally {\n    setLoading(false);\n  }\n}\n\n// src/create-chunk-decoder.ts\nfunction createChunkDecoder(complex) {\n  const decoder = new TextDecoder();\n  if (!complex) {\n    return function(chunk) {\n      if (!chunk)\n        return \"\";\n      return decoder.decode(chunk, { stream: true });\n    };\n  }\n  return function(chunk) {\n    const decoded = decoder.decode(chunk, { stream: true }).split(\"\\n\").filter((line) => line !== \"\");\n    return decoded.map(parseStreamPart).filter(Boolean);\n  };\n}\n\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n  const [header, base64Content] = dataUrl.split(\",\");\n  const mimeType = header.split(\";\")[0].split(\":\")[1];\n  if (mimeType == null || base64Content == null) {\n    throw new Error(\"Invalid data URL format\");\n  }\n  try {\n    return window.atob(base64Content);\n  } catch (error) {\n    throw new Error(`Error decoding data URL`);\n  }\n}\n\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n  if (obj1 === obj2)\n    return true;\n  if (obj1 == null || obj2 == null)\n    return false;\n  if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\")\n    return obj1 === obj2;\n  if (obj1.constructor !== obj2.constructor)\n    return false;\n  if (obj1 instanceof Date && obj2 instanceof Date) {\n    return obj1.getTime() === obj2.getTime();\n  }\n  if (Array.isArray(obj1)) {\n    if (obj1.length !== obj2.length)\n      return false;\n    for (let i = 0; i < obj1.length; i++) {\n      if (!isDeepEqualData(obj1[i], obj2[i]))\n        return false;\n    }\n    return true;\n  }\n  const keys1 = Object.keys(obj1);\n  const keys2 = Object.keys(obj2);\n  if (keys1.length !== keys2.length)\n    return false;\n  for (const key of keys1) {\n    if (!keys2.includes(key))\n      return false;\n    if (!isDeepEqualData(obj1[key], obj2[key]))\n      return false;\n  }\n  return true;\n}\n\n// src/process-chat-stream.ts\nasync function processChatStream({\n  getStreamedResponse,\n  experimental_onFunctionCall,\n  experimental_onToolCall,\n  updateChatRequest,\n  getCurrentMessages\n}) {\n  while (true) {\n    const messagesAndDataOrJustMessage = await getStreamedResponse();\n    if (\"messages\" in messagesAndDataOrJustMessage) {\n      let hasFollowingResponse = false;\n      for (const message of messagesAndDataOrJustMessage.messages) {\n        if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n          continue;\n        }\n        hasFollowingResponse = true;\n        if (experimental_onFunctionCall) {\n          const functionCall = message.function_call;\n          if (typeof functionCall !== \"object\") {\n            console.warn(\n              \"experimental_onFunctionCall should not be defined when using tools\"\n            );\n            continue;\n          }\n          const functionCallResponse = await experimental_onFunctionCall(\n            getCurrentMessages(),\n            functionCall\n          );\n          if (functionCallResponse === void 0) {\n            hasFollowingResponse = false;\n            break;\n          }\n          updateChatRequest(functionCallResponse);\n        }\n        if (experimental_onToolCall) {\n          const toolCalls = message.tool_calls;\n          if (!Array.isArray(toolCalls) || toolCalls.some((toolCall) => typeof toolCall !== \"object\")) {\n            console.warn(\n              \"experimental_onToolCall should not be defined when using tools\"\n            );\n            continue;\n          }\n          const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n          if (toolCallResponse === void 0) {\n            hasFollowingResponse = false;\n            break;\n          }\n          updateChatRequest(toolCallResponse);\n        }\n      }\n      if (!hasFollowingResponse) {\n        break;\n      }\n    } else {\n      let fixFunctionCallArguments2 = function(response) {\n        for (const message of response.messages) {\n          if (message.tool_calls !== void 0) {\n            for (const toolCall of message.tool_calls) {\n              if (typeof toolCall === \"object\") {\n                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                  toolCall.function.arguments = JSON.stringify(\n                    toolCall.function.arguments\n                  );\n                }\n              }\n            }\n          }\n          if (message.function_call !== void 0) {\n            if (typeof message.function_call === \"object\") {\n              if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                message.function_call.arguments = JSON.stringify(\n                  message.function_call.arguments\n                );\n              }\n            }\n          }\n        }\n      };\n      var fixFunctionCallArguments = fixFunctionCallArguments2;\n      const streamedResponseMessage = messagesAndDataOrJustMessage;\n      if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n        break;\n      }\n      if (experimental_onFunctionCall) {\n        const functionCall = streamedResponseMessage.function_call;\n        if (!(typeof functionCall === \"object\")) {\n          console.warn(\n            \"experimental_onFunctionCall should not be defined when using tools\"\n          );\n          continue;\n        }\n        const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n        if (functionCallResponse === void 0)\n          break;\n        fixFunctionCallArguments2(functionCallResponse);\n        updateChatRequest(functionCallResponse);\n      }\n      if (experimental_onToolCall) {\n        const toolCalls = streamedResponseMessage.tool_calls;\n        if (!(typeof toolCalls === \"object\")) {\n          console.warn(\n            \"experimental_onToolCall should not be defined when using functions\"\n          );\n          continue;\n        }\n        const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n        if (toolCallResponse === void 0)\n          break;\n        fixFunctionCallArguments2(toolCallResponse);\n        updateChatRequest(toolCallResponse);\n      }\n    }\n  }\n}\n\n// src/schema.ts\n\n\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, {\n  validate\n} = {}) {\n  return {\n    [schemaSymbol]: true,\n    _type: void 0,\n    // should never be used directly\n    [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.validatorSymbol]: true,\n    jsonSchema: jsonSchema2,\n    validate\n  };\n}\nfunction isSchema(value) {\n  return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n  return isSchema(schema) ? schema : zodSchema(schema);\n}\nfunction zodSchema(zodSchema2) {\n  return jsonSchema(\n    // we assume that zodToJsonSchema will return a valid JSONSchema7:\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema2),\n    {\n      validate: (value) => {\n        const result = zodSchema2.safeParse(value);\n        return result.success ? { success: true, value: result.data } : { success: false, error: result.error };\n      }\n    }\n  );\n}\n\n//# sourceMappingURL=index.mjs.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUNvRDs7QUFFcEQ7QUFDMEU7O0FBRTFFO0FBQzJDOztBQUUzQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZUFBZTtBQUNmO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQixrQkFBa0I7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUNBQWlDLFFBQVE7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0EsYUFBYSxvREFBZ0I7QUFDN0I7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0EsZUFBZSxvREFBZ0I7QUFDL0I7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0EsV0FBVztBQUNYOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLE9BQU87QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlELEtBQUs7QUFDdEQ7QUFDQSxZQUFZLGdCQUFnQixHQUFHO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0QsZ0JBQWdCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QyxjQUFjO0FBQzFEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0IsaUJBQWlCO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ3lEO0FBQ1I7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsRUFBRSxJQUFJO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLLG1FQUFlO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSw4REFBZTtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0Msb0NBQW9DLElBQUk7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFpQkU7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL25leHRqcy1maXJzdF9jaGF0Ym90Ly4vbm9kZV9tb2R1bGVzL0BhaS1zZGsvdWktdXRpbHMvZGlzdC9pbmRleC5tanM/NzdjYSJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBzcmMvaW5kZXgudHNcbmltcG9ydCB7IGdlbmVyYXRlSWQgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvcHJvY2Vzcy1kYXRhLXByb3RvY29sLXJlc3BvbnNlLnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIGFzIGdlbmVyYXRlSWRGdW5jdGlvbiB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5cbi8vIHNyYy9wYXJzZS1wYXJ0aWFsLWpzb24udHNcbmltcG9ydCBTZWN1cmVKU09OIGZyb20gXCJzZWN1cmUtanNvbi1wYXJzZVwiO1xuXG4vLyBzcmMvZml4LWpzb24udHNcbmZ1bmN0aW9uIGZpeEpzb24oaW5wdXQpIHtcbiAgY29uc3Qgc3RhY2sgPSBbXCJST09UXCJdO1xuICBsZXQgbGFzdFZhbGlkSW5kZXggPSAtMTtcbiAgbGV0IGxpdGVyYWxTdGFydCA9IG51bGw7XG4gIGZ1bmN0aW9uIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIHN3YXBTdGF0ZSkge1xuICAgIHtcbiAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJmXCI6XG4gICAgICAgIGNhc2UgXCJ0XCI6XG4gICAgICAgIGNhc2UgXCJuXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgbGl0ZXJhbFN0YXJ0ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9MSVRFUkFMXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCItXCI6IHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIjBcIjpcbiAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgY2FzZSBcIjNcIjpcbiAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgY2FzZSBcIjZcIjpcbiAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgY2FzZSBcIjlcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9OVU1CRVJcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIntcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgY2FzZSBcIltcIjoge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBzdGFjay5wdXNoKHN3YXBTdGF0ZSk7XG4gICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9TVEFSVFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpIHtcbiAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbnB1dC5sZW5ndGg7IGkrKykge1xuICAgIGNvbnN0IGNoYXIgPSBpbnB1dFtpXTtcbiAgICBjb25zdCBjdXJyZW50U3RhdGUgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICBzd2l0Y2ggKGN1cnJlbnRTdGF0ZSkge1xuICAgICAgY2FzZSBcIlJPT1RcIjpcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJGSU5JU0hcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfS0VZXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCI6XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlICdcIic6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJcXFxcXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9TVEFSVFwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgcHJvY2Vzc1ZhbHVlU3RhcnQoY2hhciwgaSwgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdfRVNDQVBFXCI6IHtcbiAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX05VTUJFUlwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgICAgY2FzZSBcIjFcIjpcbiAgICAgICAgICBjYXNlIFwiMlwiOlxuICAgICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgICAgY2FzZSBcIjRcIjpcbiAgICAgICAgICBjYXNlIFwiNVwiOlxuICAgICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgICAgY2FzZSBcIjdcIjpcbiAgICAgICAgICBjYXNlIFwiOFwiOlxuICAgICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiZVwiOlxuICAgICAgICAgIGNhc2UgXCJFXCI6XG4gICAgICAgICAgY2FzZSBcIi1cIjpcbiAgICAgICAgICBjYXNlIFwiLlwiOiB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgICAgcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0xJVEVSQUxcIjoge1xuICAgICAgICBjb25zdCBwYXJ0aWFsTGl0ZXJhbCA9IGlucHV0LnN1YnN0cmluZyhsaXRlcmFsU3RhcnQsIGkgKyAxKTtcbiAgICAgICAgaWYgKCFcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkgJiYgIVwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcIm51bGxcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSkge1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH0gZWxzZSBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpIHtcbiAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgbGV0IHJlc3VsdCA9IGlucHV0LnNsaWNlKDAsIGxhc3RWYWxpZEluZGV4ICsgMSk7XG4gIGZvciAobGV0IGkgPSBzdGFjay5sZW5ndGggLSAxOyBpID49IDA7IGktLSkge1xuICAgIGNvbnN0IHN0YXRlID0gc3RhY2tbaV07XG4gICAgc3dpdGNoIChzdGF0ZSkge1xuICAgICAgY2FzZSBcIklOU0lERV9TVFJJTkdcIjoge1xuICAgICAgICByZXN1bHQgKz0gJ1wiJztcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0tFWVwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9CRUZPUkVfVkFMVUVcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwifVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICByZXN1bHQgKz0gXCJdXCI7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpbnB1dC5sZW5ndGgpO1xuICAgICAgICBpZiAoXCJ0cnVlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJ0cnVlXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfSBlbHNlIGlmIChcImZhbHNlXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJmYWxzZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICByZXN1bHQgKz0gXCJudWxsXCIuc2xpY2UocGFydGlhbExpdGVyYWwubGVuZ3RoKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzdWx0O1xufVxuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5mdW5jdGlvbiBwYXJzZVBhcnRpYWxKc29uKGpzb25UZXh0KSB7XG4gIGlmIChqc29uVGV4dCA9PT0gdm9pZCAwKSB7XG4gICAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwidW5kZWZpbmVkLWlucHV0XCIgfTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB7XG4gICAgICB2YWx1ZTogU2VjdXJlSlNPTi5wYXJzZShqc29uVGV4dCksXG4gICAgICBzdGF0ZTogXCJzdWNjZXNzZnVsLXBhcnNlXCJcbiAgICB9O1xuICB9IGNhdGNoIChpZ25vcmVkKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIHZhbHVlOiBTZWN1cmVKU09OLnBhcnNlKGZpeEpzb24oanNvblRleHQpKSxcbiAgICAgICAgc3RhdGU6IFwicmVwYWlyZWQtcGFyc2VcIlxuICAgICAgfTtcbiAgICB9IGNhdGNoIChpZ25vcmVkMikge1xuICAgIH1cbiAgfVxuICByZXR1cm4geyB2YWx1ZTogdm9pZCAwLCBzdGF0ZTogXCJmYWlsZWQtcGFyc2VcIiB9O1xufVxuXG4vLyBzcmMvc3RyZWFtLXBhcnRzLnRzXG52YXIgdGV4dFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMFwiLFxuICBuYW1lOiBcInRleHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh0eXBlb2YgdmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJ0ZXh0XCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcInRleHRcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjFcIixcbiAgbmFtZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZ1bmN0aW9uX2NhbGxcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUuZnVuY3Rpb25fY2FsbCA9PSBudWxsIHx8ICEoXCJuYW1lXCIgaW4gdmFsdWUuZnVuY3Rpb25fY2FsbCkgfHwgIShcImFyZ3VtZW50c1wiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLm5hbWUgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZ1bmN0aW9uX2NhbGxcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZ1bmN0aW9uX2NhbGxcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmdW5jdGlvbl9jYWxsXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgZGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiMlwiLFxuICBuYW1lOiBcImRhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJkYXRhXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImRhdGFcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBlcnJvclN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiM1wiLFxuICBuYW1lOiBcImVycm9yXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZXJyb3JcIiBwYXJ0cyBleHBlY3QgYSBzdHJpbmcgdmFsdWUuJyk7XG4gICAgfVxuICAgIHJldHVybiB7IHR5cGU6IFwiZXJyb3JcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI0XCIsXG4gIG5hbWU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB2YWx1ZSkgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImNvbnRlbnRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmlkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiYXNzaXN0YW50XCIgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUuY29udGVudCkgfHwgIXZhbHVlLmNvbnRlbnQuZXZlcnkoXG4gICAgICAoaXRlbSkgPT4gaXRlbSAhPSBudWxsICYmIHR5cGVvZiBpdGVtID09PSBcIm9iamVjdFwiICYmIFwidHlwZVwiIGluIGl0ZW0gJiYgaXRlbS50eXBlID09PSBcInRleHRcIiAmJiBcInRleHRcIiBpbiBpdGVtICYmIGl0ZW0udGV4dCAhPSBudWxsICYmIHR5cGVvZiBpdGVtLnRleHQgPT09IFwib2JqZWN0XCIgJiYgXCJ2YWx1ZVwiIGluIGl0ZW0udGV4dCAmJiB0eXBlb2YgaXRlbS50ZXh0LnZhbHVlID09PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhbiBcImlkXCIsIFwicm9sZVwiLCBhbmQgXCJjb250ZW50XCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiYXNzaXN0YW50X21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNVwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidGhyZWFkSWRcIiBpbiB2YWx1ZSkgfHwgIShcIm1lc3NhZ2VJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudGhyZWFkSWQgIT09IFwic3RyaW5nXCIgfHwgdHlwZW9mIHZhbHVlLm1lc3NhZ2VJZCAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0aHJlYWRJZFwiIGFuZCBcIm1lc3NhZ2VJZFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9jb250cm9sX2RhdGFcIixcbiAgICAgIHZhbHVlOiB7XG4gICAgICAgIHRocmVhZElkOiB2YWx1ZS50aHJlYWRJZCxcbiAgICAgICAgbWVzc2FnZUlkOiB2YWx1ZS5tZXNzYWdlSWRcbiAgICAgIH1cbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCI2XCIsXG4gIG5hbWU6IFwiZGF0YV9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInJvbGVcIiBpbiB2YWx1ZSkgfHwgIShcImRhdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnJvbGUgIT09IFwic3RyaW5nXCIgfHwgdmFsdWUucm9sZSAhPT0gXCJkYXRhXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZGF0YV9tZXNzYWdlXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJyb2xlXCIgYW5kIFwiZGF0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImRhdGFfbWVzc2FnZVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiN1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbHNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbF9jYWxsc1wiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbF9jYWxscyAhPT0gXCJvYmplY3RcIiB8fCB2YWx1ZS50b29sX2NhbGxzID09IG51bGwgfHwgIUFycmF5LmlzQXJyYXkodmFsdWUudG9vbF9jYWxscykgfHwgdmFsdWUudG9vbF9jYWxscy5zb21lKFxuICAgICAgKHRjKSA9PiB0YyA9PSBudWxsIHx8IHR5cGVvZiB0YyAhPT0gXCJvYmplY3RcIiB8fCAhKFwiaWRcIiBpbiB0YykgfHwgdHlwZW9mIHRjLmlkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0eXBlXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy50eXBlICE9PSBcInN0cmluZ1wiIHx8ICEoXCJmdW5jdGlvblwiIGluIHRjKSB8fCB0Yy5mdW5jdGlvbiA9PSBudWxsIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbiAhPT0gXCJvYmplY3RcIiB8fCAhKFwiYXJndW1lbnRzXCIgaW4gdGMuZnVuY3Rpb24pIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB0Yy5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCJcbiAgICApKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbHNcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBUb29sQ2FsbFBheWxvYWQuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwidG9vbF9jYWxsc1wiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOFwiLFxuICBuYW1lOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignXCJtZXNzYWdlX2Fubm90YXRpb25zXCIgcGFydHMgZXhwZWN0IGFuIGFycmF5IHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcIm1lc3NhZ2VfYW5ub3RhdGlvbnNcIiwgdmFsdWUgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiOVwiLFxuICBuYW1lOiBcInRvb2xfY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJ0b29sTmFtZVwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbE5hbWUgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3MgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIsIFwidG9vbE5hbWVcIiwgYW5kIFwiYXJnc1wiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xSZXN1bHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImFcIixcbiAgbmFtZTogXCJ0b29sX3Jlc3VsdFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJyZXN1bHRcIiBpbiB2YWx1ZSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9yZXN1bHRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgYSBcInJlc3VsdFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfcmVzdWx0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiYlwiLFxuICBuYW1lOiBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidG9vbE5hbWVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcInRvb2xDYWxsSWRcIiBhbmQgXCJ0b29sTmFtZVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJjXCIsXG4gIG5hbWU6IFwidG9vbF9jYWxsX2RlbHRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcImFyZ3NUZXh0RGVsdGFcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmFyZ3NUZXh0RGVsdGEgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1widG9vbF9jYWxsX2RlbHRhXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIFwiYXJnc1RleHREZWx0YVwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbF9kZWx0YVwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImRcIixcbiAgbmFtZTogXCJmaW5pc2hfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmaW5pc2hSZWFzb25cIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZpbmlzaFJlYXNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmaW5pc2hfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZmluaXNoUmVhc29uXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZmluaXNoUmVhc29uOiB2YWx1ZS5maW5pc2hSZWFzb25cbiAgICB9O1xuICAgIGlmIChcInVzYWdlXCIgaW4gdmFsdWUgJiYgdmFsdWUudXNhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudXNhZ2UgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9tcHRUb2tlbnNcIiBpbiB2YWx1ZS51c2FnZSAmJiBcImNvbXBsZXRpb25Ub2tlbnNcIiBpbiB2YWx1ZS51c2FnZSkge1xuICAgICAgcmVzdWx0LnVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgOiBOdW1iZXIuTmFOLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgOiBOdW1iZXIuTmFOXG4gICAgICB9O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmaW5pc2hfbWVzc2FnZVwiLFxuICAgICAgdmFsdWU6IHJlc3VsdFxuICAgIH07XG4gIH1cbn07XG52YXIgZmluaXNoU3RlcFN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiZVwiLFxuICBuYW1lOiBcImZpbmlzaF9zdGVwXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImZpbmlzaFJlYXNvblwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUuZmluaXNoUmVhc29uICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImZpbmlzaF9zdGVwXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmaW5pc2hSZWFzb25cIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICBmaW5pc2hSZWFzb246IHZhbHVlLmZpbmlzaFJlYXNvbixcbiAgICAgIGlzQ29udGludWVkOiBmYWxzZVxuICAgIH07XG4gICAgaWYgKFwidXNhZ2VcIiBpbiB2YWx1ZSAmJiB2YWx1ZS51c2FnZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZS51c2FnZSA9PT0gXCJvYmplY3RcIiAmJiBcInByb21wdFRva2Vuc1wiIGluIHZhbHVlLnVzYWdlICYmIFwiY29tcGxldGlvblRva2Vuc1wiIGluIHZhbHVlLnVzYWdlKSB7XG4gICAgICByZXN1bHQudXNhZ2UgPSB7XG4gICAgICAgIHByb21wdFRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLnByb21wdFRva2VucyA6IE51bWJlci5OYU4sXG4gICAgICAgIGNvbXBsZXRpb25Ub2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA6IE51bWJlci5OYU5cbiAgICAgIH07XG4gICAgfVxuICAgIGlmIChcImlzQ29udGludWVkXCIgaW4gdmFsdWUgJiYgdHlwZW9mIHZhbHVlLmlzQ29udGludWVkID09PSBcImJvb2xlYW5cIikge1xuICAgICAgcmVzdWx0LmlzQ29udGludWVkID0gdmFsdWUuaXNDb250aW51ZWQ7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImZpbmlzaF9zdGVwXCIsXG4gICAgICB2YWx1ZTogcmVzdWx0XG4gICAgfTtcbiAgfVxufTtcbnZhciBzdHJlYW1QYXJ0cyA9IFtcbiAgdGV4dFN0cmVhbVBhcnQsXG4gIGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQsXG4gIGRhdGFTdHJlYW1QYXJ0LFxuICBlcnJvclN0cmVhbVBhcnQsXG4gIGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgbWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1QYXJ0LFxuICB0b29sUmVzdWx0U3RyZWFtUGFydCxcbiAgdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LFxuICBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCxcbiAgZmluaXNoU3RlcFN0cmVhbVBhcnRcbl07XG52YXIgc3RyZWFtUGFydHNCeUNvZGUgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5jb2RlXTogdGV4dFN0cmVhbVBhcnQsXG4gIFtmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LmNvZGVdOiBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBbZGF0YVN0cmVhbVBhcnQuY29kZV06IGRhdGFTdHJlYW1QYXJ0LFxuICBbZXJyb3JTdHJlYW1QYXJ0LmNvZGVdOiBlcnJvclN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydCxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxzU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxzU3RyZWFtUGFydCxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgW3Rvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGVdOiB0b29sUmVzdWx0U3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCxcbiAgW2ZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGVdOiBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCxcbiAgW2ZpbmlzaFN0ZXBTdHJlYW1QYXJ0LmNvZGVdOiBmaW5pc2hTdGVwU3RyZWFtUGFydFxufTtcbnZhciBTdHJlYW1TdHJpbmdQcmVmaXhlcyA9IHtcbiAgW3RleHRTdHJlYW1QYXJ0Lm5hbWVdOiB0ZXh0U3RyZWFtUGFydC5jb2RlLFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5uYW1lXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YVN0cmVhbVBhcnQubmFtZV06IGRhdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtlcnJvclN0cmVhbVBhcnQubmFtZV06IGVycm9yU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFthc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQubmFtZV06IGFzc2lzdGFudENvbnRyb2xEYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQuY29kZSxcbiAgW21lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQubmFtZV06IG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5uYW1lXTogdG9vbFJlc3VsdFN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbENhbGxEZWx0YVN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmaW5pc2hNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQuY29kZSxcbiAgW2ZpbmlzaFN0ZXBTdHJlYW1QYXJ0Lm5hbWVdOiBmaW5pc2hTdGVwU3RyZWFtUGFydC5jb2RlXG59O1xudmFyIHZhbGlkQ29kZXMgPSBzdHJlYW1QYXJ0cy5tYXAoKHBhcnQpID0+IHBhcnQuY29kZSk7XG52YXIgcGFyc2VTdHJlYW1QYXJ0ID0gKGxpbmUpID0+IHtcbiAgY29uc3QgZmlyc3RTZXBhcmF0b3JJbmRleCA9IGxpbmUuaW5kZXhPZihcIjpcIik7XG4gIGlmIChmaXJzdFNlcGFyYXRvckluZGV4ID09PSAtMSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkZhaWxlZCB0byBwYXJzZSBzdHJlYW0gc3RyaW5nLiBObyBzZXBhcmF0b3IgZm91bmQuXCIpO1xuICB9XG4gIGNvbnN0IHByZWZpeCA9IGxpbmUuc2xpY2UoMCwgZmlyc3RTZXBhcmF0b3JJbmRleCk7XG4gIGlmICghdmFsaWRDb2Rlcy5pbmNsdWRlcyhwcmVmaXgpKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gSW52YWxpZCBjb2RlICR7cHJlZml4fS5gKTtcbiAgfVxuICBjb25zdCBjb2RlID0gcHJlZml4O1xuICBjb25zdCB0ZXh0VmFsdWUgPSBsaW5lLnNsaWNlKGZpcnN0U2VwYXJhdG9ySW5kZXggKyAxKTtcbiAgY29uc3QganNvblZhbHVlID0gSlNPTi5wYXJzZSh0ZXh0VmFsdWUpO1xuICByZXR1cm4gc3RyZWFtUGFydHNCeUNvZGVbY29kZV0ucGFyc2UoanNvblZhbHVlKTtcbn07XG5mdW5jdGlvbiBmb3JtYXRTdHJlYW1QYXJ0KHR5cGUsIHZhbHVlKSB7XG4gIGNvbnN0IHN0cmVhbVBhcnQgPSBzdHJlYW1QYXJ0cy5maW5kKChwYXJ0KSA9PiBwYXJ0Lm5hbWUgPT09IHR5cGUpO1xuICBpZiAoIXN0cmVhbVBhcnQpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEludmFsaWQgc3RyZWFtIHBhcnQgdHlwZTogJHt0eXBlfWApO1xuICB9XG4gIHJldHVybiBgJHtzdHJlYW1QYXJ0LmNvZGV9OiR7SlNPTi5zdHJpbmdpZnkodmFsdWUpfVxuYDtcbn1cblxuLy8gc3JjL3JlYWQtZGF0YS1zdHJlYW0udHNcbnZhciBORVdMSU5FID0gXCJcXG5cIi5jaGFyQ29kZUF0KDApO1xuZnVuY3Rpb24gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpIHtcbiAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gbmV3IFVpbnQ4QXJyYXkodG90YWxMZW5ndGgpO1xuICBsZXQgb2Zmc2V0ID0gMDtcbiAgZm9yIChjb25zdCBjaHVuayBvZiBjaHVua3MpIHtcbiAgICBjb25jYXRlbmF0ZWRDaHVua3Muc2V0KGNodW5rLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSBjaHVuay5sZW5ndGg7XG4gIH1cbiAgY2h1bmtzLmxlbmd0aCA9IDA7XG4gIHJldHVybiBjb25jYXRlbmF0ZWRDaHVua3M7XG59XG5hc3luYyBmdW5jdGlvbiogcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gIGlzQWJvcnRlZFxufSA9IHt9KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgY29uc3QgY2h1bmtzID0gW107XG4gIGxldCB0b3RhbExlbmd0aCA9IDA7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgeyB2YWx1ZSB9ID0gYXdhaXQgcmVhZGVyLnJlYWQoKTtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIGNodW5rcy5wdXNoKHZhbHVlKTtcbiAgICAgIHRvdGFsTGVuZ3RoICs9IHZhbHVlLmxlbmd0aDtcbiAgICAgIGlmICh2YWx1ZVt2YWx1ZS5sZW5ndGggLSAxXSAhPT0gTkVXTElORSkge1xuICAgICAgICBjb250aW51ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKGNodW5rcy5sZW5ndGggPT09IDApIHtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgICBjb25zdCBjb25jYXRlbmF0ZWRDaHVua3MgPSBjb25jYXRDaHVua3MoY2h1bmtzLCB0b3RhbExlbmd0aCk7XG4gICAgdG90YWxMZW5ndGggPSAwO1xuICAgIGNvbnN0IHN0cmVhbVBhcnRzMiA9IGRlY29kZXIuZGVjb2RlKGNvbmNhdGVuYXRlZENodW5rcywgeyBzdHJlYW06IHRydWUgfSkuc3BsaXQoXCJcXG5cIikuZmlsdGVyKChsaW5lKSA9PiBsaW5lICE9PSBcIlwiKS5tYXAocGFyc2VTdHJlYW1QYXJ0KTtcbiAgICBmb3IgKGNvbnN0IHN0cmVhbVBhcnQgb2Ygc3RyZWFtUGFydHMyKSB7XG4gICAgICB5aWVsZCBzdHJlYW1QYXJ0O1xuICAgIH1cbiAgICBpZiAoaXNBYm9ydGVkID09IG51bGwgPyB2b2lkIDAgOiBpc0Fib3J0ZWQoKSkge1xuICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9wcm9jZXNzLWRhdGEtcHJvdG9jb2wtcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIGFubm90YXRpb25zKSB7XG4gIGlmICghbWVzc2FnZSB8fCAhYW5ub3RhdGlvbnMgfHwgIWFubm90YXRpb25zLmxlbmd0aClcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgcmV0dXJuIHsgLi4ubWVzc2FnZSwgYW5ub3RhdGlvbnM6IFsuLi5hbm5vdGF0aW9uc10gfTtcbn1cbmFzeW5jIGZ1bmN0aW9uIHByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSh7XG4gIHJlYWRlcixcbiAgYWJvcnRDb250cm9sbGVyUmVmLFxuICB1cGRhdGUsXG4gIG9uVG9vbENhbGwsXG4gIG9uRmluaXNoLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMiA9IGdlbmVyYXRlSWRGdW5jdGlvbixcbiAgZ2V0Q3VycmVudERhdGUgPSAoKSA9PiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKVxufSkge1xuICB2YXIgX2E7XG4gIGNvbnN0IGNyZWF0ZWRBdCA9IGdldEN1cnJlbnREYXRlKCk7XG4gIGxldCBwcmVmaXhNYXAgPSB7fTtcbiAgbGV0IG5leHRQcmVmaXhNYXAgPSB2b2lkIDA7XG4gIGNvbnN0IHByZXZpb3VzTWVzc2FnZXMgPSBbXTtcbiAgY29uc3QgZGF0YSA9IFtdO1xuICBsZXQgbWVzc2FnZUFubm90YXRpb25zID0gdm9pZCAwO1xuICBjb25zdCBwYXJ0aWFsVG9vbENhbGxzID0ge307XG4gIGxldCB1c2FnZSA9IHtcbiAgICBjb21wbGV0aW9uVG9rZW5zOiBOYU4sXG4gICAgcHJvbXB0VG9rZW5zOiBOYU4sXG4gICAgdG90YWxUb2tlbnM6IE5hTlxuICB9O1xuICBsZXQgZmluaXNoUmVhc29uID0gXCJ1bmtub3duXCI7XG4gIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgIGlzQWJvcnRlZDogKCkgPT4gKGFib3J0Q29udHJvbGxlclJlZiA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyUmVmLmN1cnJlbnQpID09PSBudWxsXG4gIH0pKSB7XG4gICAgaWYgKHR5cGUgPT09IFwiZXJyb3JcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKHZhbHVlKTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiZmluaXNoX3N0ZXBcIikge1xuICAgICAgaWYgKCF2YWx1ZS5pc0NvbnRpbnVlZCkge1xuICAgICAgICBuZXh0UHJlZml4TWFwID0ge307XG4gICAgICB9XG4gICAgICBjb250aW51ZTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiZmluaXNoX21lc3NhZ2VcIikge1xuICAgICAgZmluaXNoUmVhc29uID0gdmFsdWUuZmluaXNoUmVhc29uO1xuICAgICAgaWYgKHZhbHVlLnVzYWdlICE9IG51bGwpIHtcbiAgICAgICAgY29uc3QgeyBjb21wbGV0aW9uVG9rZW5zLCBwcm9tcHRUb2tlbnMgfSA9IHZhbHVlLnVzYWdlO1xuICAgICAgICB1c2FnZSA9IHtcbiAgICAgICAgICBjb21wbGV0aW9uVG9rZW5zLFxuICAgICAgICAgIHByb21wdFRva2VucyxcbiAgICAgICAgICB0b3RhbFRva2VuczogY29tcGxldGlvblRva2VucyArIHByb21wdFRva2Vuc1xuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmIChuZXh0UHJlZml4TWFwICE9IG51bGwgJiYgKHR5cGUgPT09IFwidGV4dFwiIHx8IHR5cGUgPT09IFwidG9vbF9jYWxsXCIgfHwgdHlwZSA9PT0gXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIgfHwgdHlwZSA9PT0gXCJ0b29sX2NhbGxfZGVsdGFcIiB8fCB0eXBlID09PSBcInRvb2xfcmVzdWx0XCIpKSB7XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQpIHtcbiAgICAgICAgcHJldmlvdXNNZXNzYWdlcy5wdXNoKHByZWZpeE1hcC50ZXh0KTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICBwcmV2aW91c01lc3NhZ2VzLnB1c2gocHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwpO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC50b29sX2NhbGxzKSB7XG4gICAgICAgIHByZXZpb3VzTWVzc2FnZXMucHVzaChwcmVmaXhNYXAudG9vbF9jYWxscyk7XG4gICAgICB9XG4gICAgICBwcmVmaXhNYXAgPSBuZXh0UHJlZml4TWFwO1xuICAgICAgbmV4dFByZWZpeE1hcCA9IHZvaWQgMDtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwidGV4dFwiKSB7XG4gICAgICBpZiAocHJlZml4TWFwW1widGV4dFwiXSkge1xuICAgICAgICBwcmVmaXhNYXBbXCJ0ZXh0XCJdID0ge1xuICAgICAgICAgIC4uLnByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgICAgY29udGVudDogKHByZWZpeE1hcFtcInRleHRcIl0uY29udGVudCB8fCBcIlwiKSArIHZhbHVlXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwcmVmaXhNYXBbXCJ0ZXh0XCJdID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogdmFsdWUsXG4gICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgIH07XG4gICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcInRvb2xfY2FsbF9zdHJlYW1pbmdfc3RhcnRcIikge1xuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ID09IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9IFtdO1xuICAgICAgfVxuICAgICAgcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXSA9IHtcbiAgICAgICAgdGV4dDogXCJcIixcbiAgICAgICAgdG9vbE5hbWU6IHZhbHVlLnRvb2xOYW1lLFxuICAgICAgICBwcmVmaXhNYXBJbmRleDogcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLmxlbmd0aFxuICAgICAgfTtcbiAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucy5wdXNoKHtcbiAgICAgICAgc3RhdGU6IFwicGFydGlhbC1jYWxsXCIsXG4gICAgICAgIHRvb2xDYWxsSWQ6IHZhbHVlLnRvb2xDYWxsSWQsXG4gICAgICAgIHRvb2xOYW1lOiB2YWx1ZS50b29sTmFtZSxcbiAgICAgICAgYXJnczogdm9pZCAwXG4gICAgICB9KTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidG9vbF9jYWxsX2RlbHRhXCIpIHtcbiAgICAgIGNvbnN0IHBhcnRpYWxUb29sQ2FsbCA9IHBhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF07XG4gICAgICBwYXJ0aWFsVG9vbENhbGwudGV4dCArPSB2YWx1ZS5hcmdzVGV4dERlbHRhO1xuICAgICAgY29uc3QgeyB2YWx1ZTogcGFydGlhbEFyZ3MgfSA9IHBhcnNlUGFydGlhbEpzb24ocGFydGlhbFRvb2xDYWxsLnRleHQpO1xuICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zW3BhcnRpYWxUb29sQ2FsbC5wcmVmaXhNYXBJbmRleF0gPSB7XG4gICAgICAgIHN0YXRlOiBcInBhcnRpYWwtY2FsbFwiLFxuICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZTogcGFydGlhbFRvb2xDYWxsLnRvb2xOYW1lLFxuICAgICAgICBhcmdzOiBwYXJ0aWFsQXJnc1xuICAgICAgfTtcbiAgICAgIHByZWZpeE1hcC50ZXh0LmludGVybmFsVXBkYXRlSWQgPSBnZW5lcmF0ZUlkMigpO1xuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxcIikge1xuICAgICAgaWYgKHBhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF0gIT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnNbcGFydGlhbFRvb2xDYWxsc1t2YWx1ZS50b29sQ2FsbElkXS5wcmVmaXhNYXBJbmRleF0gPSB7IHN0YXRlOiBcImNhbGxcIiwgLi4udmFsdWUgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChwcmVmaXhNYXAudGV4dCA9PSBudWxsKSB7XG4gICAgICAgICAgcHJlZml4TWFwLnRleHQgPSB7XG4gICAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgICBjb250ZW50OiBcIlwiLFxuICAgICAgICAgICAgY3JlYXRlZEF0XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID09IG51bGwpIHtcbiAgICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMucHVzaCh7XG4gICAgICAgICAgc3RhdGU6IFwiY2FsbFwiLFxuICAgICAgICAgIC4uLnZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcHJlZml4TWFwLnRleHQuaW50ZXJuYWxVcGRhdGVJZCA9IGdlbmVyYXRlSWQyKCk7XG4gICAgICBpZiAob25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCBvblRvb2xDYWxsKHsgdG9vbENhbGw6IHZhbHVlIH0pO1xuICAgICAgICBpZiAocmVzdWx0ICE9IG51bGwpIHtcbiAgICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnNbcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLmxlbmd0aCAtIDFdID0geyBzdGF0ZTogXCJyZXN1bHRcIiwgLi4udmFsdWUsIHJlc3VsdCB9O1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRvb2xfcmVzdWx0XCIpIHtcbiAgICAgIGNvbnN0IHRvb2xJbnZvY2F0aW9ucyA9IChfYSA9IHByZWZpeE1hcC50ZXh0KSA9PSBudWxsID8gdm9pZCAwIDogX2EudG9vbEludm9jYXRpb25zO1xuICAgICAgaWYgKHRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcInRvb2xfcmVzdWx0IG11c3QgYmUgcHJlY2VkZWQgYnkgYSB0b29sX2NhbGxcIik7XG4gICAgICB9XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbkluZGV4ID0gdG9vbEludm9jYXRpb25zLmZpbmRJbmRleChcbiAgICAgICAgKGludm9jYXRpb24pID0+IGludm9jYXRpb24udG9vbENhbGxJZCA9PT0gdmFsdWUudG9vbENhbGxJZFxuICAgICAgKTtcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbkluZGV4ID09PSAtMSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgXCJ0b29sX3Jlc3VsdCBtdXN0IGJlIHByZWNlZGVkIGJ5IGEgdG9vbF9jYWxsIHdpdGggdGhlIHNhbWUgdG9vbENhbGxJZFwiXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICB0b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0gPSB7XG4gICAgICAgIC4uLnRvb2xJbnZvY2F0aW9uc1t0b29sSW52b2NhdGlvbkluZGV4XSxcbiAgICAgICAgc3RhdGU6IFwicmVzdWx0XCIsXG4gICAgICAgIC4uLnZhbHVlXG4gICAgICB9O1xuICAgIH1cbiAgICBsZXQgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKHR5cGUgPT09IFwiZnVuY3Rpb25fY2FsbFwiKSB7XG4gICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgZnVuY3Rpb25fY2FsbDogdmFsdWUuZnVuY3Rpb25fY2FsbCxcbiAgICAgICAgbmFtZTogdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lLFxuICAgICAgICBjcmVhdGVkQXRcbiAgICAgIH07XG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXTtcbiAgICB9XG4gICAgbGV0IHRvb2xDYWxsTWVzc2FnZSA9IG51bGw7XG4gICAgaWYgKHR5cGUgPT09IFwidG9vbF9jYWxsc1wiKSB7XG4gICAgICBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgdG9vbF9jYWxsczogdmFsdWUudG9vbF9jYWxscyxcbiAgICAgICAgY3JlYXRlZEF0XG4gICAgICB9O1xuICAgICAgdG9vbENhbGxNZXNzYWdlID0gcHJlZml4TWFwW1widG9vbF9jYWxsc1wiXTtcbiAgICB9XG4gICAgaWYgKHR5cGUgPT09IFwiZGF0YVwiKSB7XG4gICAgICBkYXRhLnB1c2goLi4udmFsdWUpO1xuICAgIH1cbiAgICBsZXQgcmVzcG9uc2VNZXNzYWdlID0gcHJlZml4TWFwW1widGV4dFwiXTtcbiAgICBpZiAodHlwZSA9PT0gXCJtZXNzYWdlX2Fubm90YXRpb25zXCIpIHtcbiAgICAgIGlmICghbWVzc2FnZUFubm90YXRpb25zKSB7XG4gICAgICAgIG1lc3NhZ2VBbm5vdGF0aW9ucyA9IFsuLi52YWx1ZV07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBtZXNzYWdlQW5ub3RhdGlvbnMucHVzaCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICBmdW5jdGlvbkNhbGxNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl0sXG4gICAgICAgIG1lc3NhZ2VBbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJ0b29sX2NhbGxzXCJdLFxuICAgICAgICBtZXNzYWdlQW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICByZXNwb25zZU1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSxcbiAgICAgICAgbWVzc2FnZUFubm90YXRpb25zXG4gICAgICApO1xuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0ICE9IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQuaW50ZXJuYWxVcGRhdGVJZCA9IGdlbmVyYXRlSWQyKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChtZXNzYWdlQW5ub3RhdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG1lc3NhZ2VBbm5vdGF0aW9ucy5sZW5ndGgpIHtcbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlQW5ub3RhdGlvbnNdO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VBbm5vdGF0aW9uc107XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4TWFwLnRvb2xfY2FsbHMpIHtcbiAgICAgICAgcHJlZml4TWFwLnRvb2xfY2FsbHMuYW5ub3RhdGlvbnMgPSBbLi4ubWVzc2FnZUFubm90YXRpb25zXTtcbiAgICAgIH1cbiAgICB9XG4gICAgY29uc3QgbWVyZ2VkID0gW2Z1bmN0aW9uQ2FsbE1lc3NhZ2UsIHRvb2xDYWxsTWVzc2FnZSwgcmVzcG9uc2VNZXNzYWdlXS5maWx0ZXIoQm9vbGVhbikubWFwKChtZXNzYWdlKSA9PiAoe1xuICAgICAgLi4uYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UobWVzc2FnZSwgbWVzc2FnZUFubm90YXRpb25zKVxuICAgIH0pKTtcbiAgICB1cGRhdGUoWy4uLnByZXZpb3VzTWVzc2FnZXMsIC4uLm1lcmdlZF0sIFsuLi5kYXRhXSk7XG4gIH1cbiAgb25GaW5pc2ggPT0gbnVsbCA/IHZvaWQgMCA6IG9uRmluaXNoKHsgbWVzc2FnZTogcHJlZml4TWFwLnRleHQsIGZpbmlzaFJlYXNvbiwgdXNhZ2UgfSk7XG4gIHJldHVybiB7XG4gICAgbWVzc2FnZXM6IFtcbiAgICAgIHByZWZpeE1hcC50ZXh0LFxuICAgICAgcHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwsXG4gICAgICBwcmVmaXhNYXAudG9vbF9jYWxsc1xuICAgIF0uZmlsdGVyKEJvb2xlYW4pLFxuICAgIGRhdGFcbiAgfTtcbn1cblxuLy8gc3JjL2NhbGwtY2hhdC1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ2hhdEFwaSh7XG4gIGFwaSxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgY3JlZGVudGlhbHMsXG4gIGhlYWRlcnMsXG4gIGFib3J0Q29udHJvbGxlcixcbiAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlLFxuICBvblJlc3BvbnNlLFxuICBvblVwZGF0ZSxcbiAgb25GaW5pc2gsXG4gIG9uVG9vbENhbGwsXG4gIGdlbmVyYXRlSWQ6IGdlbmVyYXRlSWQyLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaCgpXG59KSB7XG4gIHZhciBfYSwgX2I7XG4gIGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgYm9keTogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgaGVhZGVyczoge1xuICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAuLi5oZWFkZXJzXG4gICAgfSxcbiAgICBzaWduYWw6IChfYSA9IGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09IG51bGwgPyB2b2lkIDAgOiBfYS5zaWduYWwsXG4gICAgY3JlZGVudGlhbHNcbiAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IGVycjtcbiAgfSk7XG4gIGlmIChvblJlc3BvbnNlKSB7XG4gICAgdHJ5IHtcbiAgICAgIGF3YWl0IG9uUmVzcG9uc2UocmVzcG9uc2UpO1xuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBpZiAoIXJlc3BvbnNlLm9rKSB7XG4gICAgcmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlKCk7XG4gICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgKF9iID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpKSAhPSBudWxsID8gX2IgOiBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICk7XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICB9XG4gIGNvbnN0IHJlYWRlciA9IHJlc3BvbnNlLmJvZHkuZ2V0UmVhZGVyKCk7XG4gIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICBjb25zdCBkZWNvZGVyID0gY3JlYXRlQ2h1bmtEZWNvZGVyKCk7XG4gICAgICBjb25zdCByZXN1bHRNZXNzYWdlID0ge1xuICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgY3JlYXRlZEF0OiAvKiBAX19QVVJFX18gKi8gbmV3IERhdGUoKSxcbiAgICAgICAgcm9sZTogXCJhc3Npc3RhbnRcIixcbiAgICAgICAgY29udGVudDogXCJcIlxuICAgICAgfTtcbiAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgcmVzdWx0TWVzc2FnZS5jb250ZW50ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICBvblVwZGF0ZShbeyAuLi5yZXN1bHRNZXNzYWdlIH1dLCBbXSk7XG4gICAgICAgIGlmICgoYWJvcnRDb250cm9sbGVyID09IG51bGwgPyB2b2lkIDAgOiBhYm9ydENvbnRyb2xsZXIoKSkgPT09IG51bGwpIHtcbiAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaChyZXN1bHRNZXNzYWdlLCB7XG4gICAgICAgIHVzYWdlOiB7IGNvbXBsZXRpb25Ub2tlbnM6IE5hTiwgcHJvbXB0VG9rZW5zOiBOYU4sIHRvdGFsVG9rZW5zOiBOYU4gfSxcbiAgICAgICAgZmluaXNoUmVhc29uOiBcInVua25vd25cIlxuICAgICAgfSk7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBtZXNzYWdlczogW3Jlc3VsdE1lc3NhZ2VdLFxuICAgICAgICBkYXRhOiBbXVxuICAgICAgfTtcbiAgICB9XG4gICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgcmV0dXJuIGF3YWl0IHByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSh7XG4gICAgICAgIHJlYWRlcixcbiAgICAgICAgYWJvcnRDb250cm9sbGVyUmVmOiBhYm9ydENvbnRyb2xsZXIgIT0gbnVsbCA/IHsgY3VycmVudDogYWJvcnRDb250cm9sbGVyKCkgfSA6IHZvaWQgMCxcbiAgICAgICAgdXBkYXRlOiBvblVwZGF0ZSxcbiAgICAgICAgb25Ub29sQ2FsbCxcbiAgICAgICAgb25GaW5pc2goeyBtZXNzYWdlLCBmaW5pc2hSZWFzb24sIHVzYWdlIH0pIHtcbiAgICAgICAgICBpZiAob25GaW5pc2ggJiYgbWVzc2FnZSAhPSBudWxsKSB7XG4gICAgICAgICAgICBvbkZpbmlzaChtZXNzYWdlLCB7IHVzYWdlLCBmaW5pc2hSZWFzb24gfSk7XG4gICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMlxuICAgICAgfSk7XG4gICAgfVxuICAgIGRlZmF1bHQ6IHtcbiAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHN0cmVhbVByb3RvY29sO1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBVbmtub3duIHN0cmVhbSBwcm90b2NvbDogJHtleGhhdXN0aXZlQ2hlY2t9YCk7XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9jYWxsLWNvbXBsZXRpb24tYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaDIgPSAoKSA9PiBmZXRjaDtcbmFzeW5jIGZ1bmN0aW9uIGNhbGxDb21wbGV0aW9uQXBpKHtcbiAgYXBpLFxuICBwcm9tcHQsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBzdHJlYW1Qcm90b2NvbCA9IFwiZGF0YVwiLFxuICBzZXRDb21wbGV0aW9uLFxuICBzZXRMb2FkaW5nLFxuICBzZXRFcnJvcixcbiAgc2V0QWJvcnRDb250cm9sbGVyLFxuICBvblJlc3BvbnNlLFxuICBvbkZpbmlzaCxcbiAgb25FcnJvcixcbiAgb25EYXRhLFxuICBmZXRjaDogZmV0Y2gyID0gZ2V0T3JpZ2luYWxGZXRjaDIoKVxufSkge1xuICB0cnkge1xuICAgIHNldExvYWRpbmcodHJ1ZSk7XG4gICAgc2V0RXJyb3Iodm9pZCAwKTtcbiAgICBjb25zdCBhYm9ydENvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKGFib3J0Q29udHJvbGxlcik7XG4gICAgc2V0Q29tcGxldGlvbihcIlwiKTtcbiAgICBjb25zdCByZXMgPSBhd2FpdCBmZXRjaDIoYXBpLCB7XG4gICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoe1xuICAgICAgICBwcm9tcHQsXG4gICAgICAgIC4uLmJvZHlcbiAgICAgIH0pLFxuICAgICAgY3JlZGVudGlhbHMsXG4gICAgICBoZWFkZXJzOiB7XG4gICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAuLi5oZWFkZXJzXG4gICAgICB9LFxuICAgICAgc2lnbmFsOiBhYm9ydENvbnRyb2xsZXIuc2lnbmFsXG4gICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH0pO1xuICAgIGlmIChvblJlc3BvbnNlKSB7XG4gICAgICB0cnkge1xuICAgICAgICBhd2FpdCBvblJlc3BvbnNlKHJlcyk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAoIXJlcy5vaykge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICBhd2FpdCByZXMudGV4dCgpIHx8IFwiRmFpbGVkIHRvIGZldGNoIHRoZSBjaGF0IHJlc3BvbnNlLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBpZiAoIXJlcy5ib2R5KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJUaGUgcmVzcG9uc2UgYm9keSBpcyBlbXB0eS5cIik7XG4gICAgfVxuICAgIGxldCByZXN1bHQgPSBcIlwiO1xuICAgIGNvbnN0IHJlYWRlciA9IHJlcy5ib2R5LmdldFJlYWRlcigpO1xuICAgIHN3aXRjaCAoc3RyZWFtUHJvdG9jb2wpIHtcbiAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICAgIGNvbnN0IHsgZG9uZSwgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICByZXN1bHQgKz0gZGVjb2Rlcih2YWx1ZSk7XG4gICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgIGlmIChhYm9ydENvbnRyb2xsZXIgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgZm9yIGF3YWl0IChjb25zdCB7IHR5cGUsIHZhbHVlIH0gb2YgcmVhZERhdGFTdHJlYW0ocmVhZGVyLCB7XG4gICAgICAgICAgaXNBYm9ydGVkOiAoKSA9PiBhYm9ydENvbnRyb2xsZXIgPT09IG51bGxcbiAgICAgICAgfSkpIHtcbiAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcbiAgICAgICAgICAgIGNhc2UgXCJ0ZXh0XCI6IHtcbiAgICAgICAgICAgICAgcmVzdWx0ICs9IHZhbHVlO1xuICAgICAgICAgICAgICBzZXRDb21wbGV0aW9uKHJlc3VsdCk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBcImRhdGFcIjoge1xuICAgICAgICAgICAgICBvbkRhdGEgPT0gbnVsbCA/IHZvaWQgMCA6IG9uRGF0YSh2YWx1ZSk7XG4gICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgY29uc3QgZXhoYXVzdGl2ZUNoZWNrID0gc3RyZWFtUHJvdG9jb2w7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAob25GaW5pc2gpIHtcbiAgICAgIG9uRmluaXNoKHByb21wdCwgcmVzdWx0KTtcbiAgICB9XG4gICAgc2V0QWJvcnRDb250cm9sbGVyKG51bGwpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChlcnIubmFtZSA9PT0gXCJBYm9ydEVycm9yXCIpIHtcbiAgICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbiAgICBpZiAoZXJyIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgIGlmIChvbkVycm9yKSB7XG4gICAgICAgIG9uRXJyb3IoZXJyKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2V0RXJyb3IoZXJyKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBzZXRMb2FkaW5nKGZhbHNlKTtcbiAgfVxufVxuXG4vLyBzcmMvY3JlYXRlLWNodW5rLWRlY29kZXIudHNcbmZ1bmN0aW9uIGNyZWF0ZUNodW5rRGVjb2Rlcihjb21wbGV4KSB7XG4gIGNvbnN0IGRlY29kZXIgPSBuZXcgVGV4dERlY29kZXIoKTtcbiAgaWYgKCFjb21wbGV4KSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgICBpZiAoIWNodW5rKVxuICAgICAgICByZXR1cm4gXCJcIjtcbiAgICAgIHJldHVybiBkZWNvZGVyLmRlY29kZShjaHVuaywgeyBzdHJlYW06IHRydWUgfSk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4gZnVuY3Rpb24oY2h1bmspIHtcbiAgICBjb25zdCBkZWNvZGVkID0gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIik7XG4gICAgcmV0dXJuIGRlY29kZWQubWFwKHBhcnNlU3RyZWFtUGFydCkuZmlsdGVyKEJvb2xlYW4pO1xuICB9O1xufVxuXG4vLyBzcmMvZGF0YS11cmwudHNcbmZ1bmN0aW9uIGdldFRleHRGcm9tRGF0YVVybChkYXRhVXJsKSB7XG4gIGNvbnN0IFtoZWFkZXIsIGJhc2U2NENvbnRlbnRdID0gZGF0YVVybC5zcGxpdChcIixcIik7XG4gIGNvbnN0IG1pbWVUeXBlID0gaGVhZGVyLnNwbGl0KFwiO1wiKVswXS5zcGxpdChcIjpcIilbMV07XG4gIGlmIChtaW1lVHlwZSA9PSBudWxsIHx8IGJhc2U2NENvbnRlbnQgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgZGF0YSBVUkwgZm9ybWF0XCIpO1xuICB9XG4gIHRyeSB7XG4gICAgcmV0dXJuIHdpbmRvdy5hdG9iKGJhc2U2NENvbnRlbnQpO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihgRXJyb3IgZGVjb2RpbmcgZGF0YSBVUkxgKTtcbiAgfVxufVxuXG4vLyBzcmMvaXMtZGVlcC1lcXVhbC1kYXRhLnRzXG5mdW5jdGlvbiBpc0RlZXBFcXVhbERhdGEob2JqMSwgb2JqMikge1xuICBpZiAob2JqMSA9PT0gb2JqMilcbiAgICByZXR1cm4gdHJ1ZTtcbiAgaWYgKG9iajEgPT0gbnVsbCB8fCBvYmoyID09IG51bGwpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBpZiAodHlwZW9mIG9iajEgIT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIG9iajIgIT09IFwib2JqZWN0XCIpXG4gICAgcmV0dXJuIG9iajEgPT09IG9iajI7XG4gIGlmIChvYmoxLmNvbnN0cnVjdG9yICE9PSBvYmoyLmNvbnN0cnVjdG9yKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKG9iajEgaW5zdGFuY2VvZiBEYXRlICYmIG9iajIgaW5zdGFuY2VvZiBEYXRlKSB7XG4gICAgcmV0dXJuIG9iajEuZ2V0VGltZSgpID09PSBvYmoyLmdldFRpbWUoKTtcbiAgfVxuICBpZiAoQXJyYXkuaXNBcnJheShvYmoxKSkge1xuICAgIGlmIChvYmoxLmxlbmd0aCAhPT0gb2JqMi5sZW5ndGgpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBvYmoxLmxlbmd0aDsgaSsrKSB7XG4gICAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2ldLCBvYmoyW2ldKSlcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICBjb25zdCBrZXlzMSA9IE9iamVjdC5rZXlzKG9iajEpO1xuICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iajIpO1xuICBpZiAoa2V5czEubGVuZ3RoICE9PSBrZXlzMi5sZW5ndGgpXG4gICAgcmV0dXJuIGZhbHNlO1xuICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzMSkge1xuICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSlcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICBpZiAoIWlzRGVlcEVxdWFsRGF0YShvYmoxW2tleV0sIG9iajJba2V5XSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIHNyYy9wcm9jZXNzLWNoYXQtc3RyZWFtLnRzXG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzQ2hhdFN0cmVhbSh7XG4gIGdldFN0cmVhbWVkUmVzcG9uc2UsXG4gIGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCxcbiAgZXhwZXJpbWVudGFsX29uVG9vbENhbGwsXG4gIHVwZGF0ZUNoYXRSZXF1ZXN0LFxuICBnZXRDdXJyZW50TWVzc2FnZXNcbn0pIHtcbiAgd2hpbGUgKHRydWUpIHtcbiAgICBjb25zdCBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlID0gYXdhaXQgZ2V0U3RyZWFtZWRSZXNwb25zZSgpO1xuICAgIGlmIChcIm1lc3NhZ2VzXCIgaW4gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSkge1xuICAgICAgbGV0IGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZS5tZXNzYWdlcykge1xuICAgICAgICBpZiAoKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpICYmIChtZXNzYWdlLnRvb2xfY2FsbHMgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWVzc2FnZS50b29sX2NhbGxzID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gdHJ1ZTtcbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbCA9IG1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgICBpZiAodHlwZW9mIGZ1bmN0aW9uQ2FsbCAhPT0gXCJvYmplY3RcIikge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKFxuICAgICAgICAgICAgZ2V0Q3VycmVudE1lc3NhZ2VzKCksXG4gICAgICAgICAgICBmdW5jdGlvbkNhbGxcbiAgICAgICAgICApO1xuICAgICAgICAgIGlmIChmdW5jdGlvbkNhbGxSZXNwb25zZSA9PT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBtZXNzYWdlLnRvb2xfY2FsbHM7XG4gICAgICAgICAgaWYgKCFBcnJheS5pc0FycmF5KHRvb2xDYWxscykgfHwgdG9vbENhbGxzLnNvbWUoKHRvb2xDYWxsKSA9PiB0eXBlb2YgdG9vbENhbGwgIT09IFwib2JqZWN0XCIpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCB0b29sQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG4gICAgICAgICAgaWYgKHRvb2xDYWxsUmVzcG9uc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdCh0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCFoYXNGb2xsb3dpbmdSZXNwb25zZSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgbGV0IGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czIgPSBmdW5jdGlvbihyZXNwb25zZSkge1xuICAgICAgICBmb3IgKGNvbnN0IG1lc3NhZ2Ugb2YgcmVzcG9uc2UubWVzc2FnZXMpIHtcbiAgICAgICAgICBpZiAobWVzc2FnZS50b29sX2NhbGxzICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgdG9vbENhbGwgb2YgbWVzc2FnZS50b29sX2NhbGxzKSB7XG4gICAgICAgICAgICAgIGlmICh0eXBlb2YgdG9vbENhbGwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgICBpZiAodG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzICYmIHR5cGVvZiB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICAgIHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHNcbiAgICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgIT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgICAgaWYgKG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgJiYgdHlwZW9mIG1lc3NhZ2UuZnVuY3Rpb25fY2FsbC5hcmd1bWVudHMgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzID0gSlNPTi5zdHJpbmdpZnkoXG4gICAgICAgICAgICAgICAgICBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIHZhciBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMgPSBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyO1xuICAgICAgY29uc3Qgc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UgPSBtZXNzYWdlc0FuZERhdGFPckp1c3RNZXNzYWdlO1xuICAgICAgaWYgKChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSB2b2lkIDAgfHwgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IFwic3RyaW5nXCIpICYmIChzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSB2b2lkIDAgfHwgdHlwZW9mIHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlLnRvb2xfY2FsbHMgPT09IFwic3RyaW5nXCIpKSB7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCkge1xuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsO1xuICAgICAgICBpZiAoISh0eXBlb2YgZnVuY3Rpb25DYWxsID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uRnVuY3Rpb25DYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCBmdW5jdGlvbkNhbGwpO1xuICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHZvaWQgMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMihmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KGZ1bmN0aW9uQ2FsbFJlc3BvbnNlKTtcbiAgICAgIH1cbiAgICAgIGlmIChleHBlcmltZW50YWxfb25Ub29sQ2FsbCkge1xuICAgICAgICBjb25zdCB0b29sQ2FsbHMgPSBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICBpZiAoISh0eXBlb2YgdG9vbENhbGxzID09PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgIFwiZXhwZXJpbWVudGFsX29uVG9vbENhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgZnVuY3Rpb25zXCJcbiAgICAgICAgICApO1xuICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHRvb2xDYWxsUmVzcG9uc2UgPSBhd2FpdCBleHBlcmltZW50YWxfb25Ub29sQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgdG9vbENhbGxzKTtcbiAgICAgICAgaWYgKHRvb2xDYWxsUmVzcG9uc2UgPT09IHZvaWQgMClcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMih0b29sQ2FsbFJlc3BvbnNlKTtcbiAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8vIHNyYy9zY2hlbWEudHNcbmltcG9ydCB7IHZhbGlkYXRvclN5bWJvbCB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyLXV0aWxzXCI7XG5pbXBvcnQgem9kVG9Kc29uU2NoZW1hIGZyb20gXCJ6b2QtdG8tanNvbi1zY2hlbWFcIjtcbnZhciBzY2hlbWFTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnNjaGVtYVwiKTtcbmZ1bmN0aW9uIGpzb25TY2hlbWEoanNvblNjaGVtYTIsIHtcbiAgdmFsaWRhdGVcbn0gPSB7fSkge1xuICByZXR1cm4ge1xuICAgIFtzY2hlbWFTeW1ib2xdOiB0cnVlLFxuICAgIF90eXBlOiB2b2lkIDAsXG4gICAgLy8gc2hvdWxkIG5ldmVyIGJlIHVzZWQgZGlyZWN0bHlcbiAgICBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSxcbiAgICBqc29uU2NoZW1hOiBqc29uU2NoZW1hMixcbiAgICB2YWxpZGF0ZVxuICB9O1xufVxuZnVuY3Rpb24gaXNTY2hlbWEodmFsdWUpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiB2YWx1ZSAhPT0gbnVsbCAmJiBzY2hlbWFTeW1ib2wgaW4gdmFsdWUgJiYgdmFsdWVbc2NoZW1hU3ltYm9sXSA9PT0gdHJ1ZSAmJiBcImpzb25TY2hlbWFcIiBpbiB2YWx1ZSAmJiBcInZhbGlkYXRlXCIgaW4gdmFsdWU7XG59XG5mdW5jdGlvbiBhc1NjaGVtYShzY2hlbWEpIHtcbiAgcmV0dXJuIGlzU2NoZW1hKHNjaGVtYSkgPyBzY2hlbWEgOiB6b2RTY2hlbWEoc2NoZW1hKTtcbn1cbmZ1bmN0aW9uIHpvZFNjaGVtYSh6b2RTY2hlbWEyKSB7XG4gIHJldHVybiBqc29uU2NoZW1hKFxuICAgIC8vIHdlIGFzc3VtZSB0aGF0IHpvZFRvSnNvblNjaGVtYSB3aWxsIHJldHVybiBhIHZhbGlkIEpTT05TY2hlbWE3OlxuICAgIHpvZFRvSnNvblNjaGVtYSh6b2RTY2hlbWEyKSxcbiAgICB7XG4gICAgICB2YWxpZGF0ZTogKHZhbHVlKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlc3VsdCA9IHpvZFNjaGVtYTIuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdC5zdWNjZXNzID8geyBzdWNjZXNzOiB0cnVlLCB2YWx1ZTogcmVzdWx0LmRhdGEgfSA6IHsgc3VjY2VzczogZmFsc2UsIGVycm9yOiByZXN1bHQuZXJyb3IgfTtcbiAgICAgIH1cbiAgICB9XG4gICk7XG59XG5leHBvcnQge1xuICBhc1NjaGVtYSxcbiAgY2FsbENoYXRBcGksXG4gIGNhbGxDb21wbGV0aW9uQXBpLFxuICBjcmVhdGVDaHVua0RlY29kZXIsXG4gIGZvcm1hdFN0cmVhbVBhcnQsXG4gIGdlbmVyYXRlSWQsXG4gIGdldFRleHRGcm9tRGF0YVVybCxcbiAgaXNEZWVwRXF1YWxEYXRhLFxuICBqc29uU2NoZW1hLFxuICBwYXJzZVBhcnRpYWxKc29uLFxuICBwYXJzZVN0cmVhbVBhcnQsXG4gIHByb2Nlc3NDaGF0U3RyZWFtLFxuICBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2UsXG4gIHJlYWREYXRhU3RyZWFtLFxuICB6b2RTY2hlbWFcbn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmRleC5tanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs":
/*!************************************************************!*\
  !*** ./node_modules/@ai-sdk/provider-utils/dist/index.mjs ***!
  \************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asValidator: () => (/* binding */ asValidator),\n/* harmony export */   combineHeaders: () => (/* binding */ combineHeaders),\n/* harmony export */   convertAsyncGeneratorToReadableStream: () => (/* binding */ convertAsyncGeneratorToReadableStream),\n/* harmony export */   convertBase64ToUint8Array: () => (/* binding */ convertBase64ToUint8Array),\n/* harmony export */   convertUint8ArrayToBase64: () => (/* binding */ convertUint8ArrayToBase64),\n/* harmony export */   createEventSourceResponseHandler: () => (/* binding */ createEventSourceResponseHandler),\n/* harmony export */   createIdGenerator: () => (/* binding */ createIdGenerator),\n/* harmony export */   createJsonErrorResponseHandler: () => (/* binding */ createJsonErrorResponseHandler),\n/* harmony export */   createJsonResponseHandler: () => (/* binding */ createJsonResponseHandler),\n/* harmony export */   createJsonStreamResponseHandler: () => (/* binding */ createJsonStreamResponseHandler),\n/* harmony export */   extractResponseHeaders: () => (/* binding */ extractResponseHeaders),\n/* harmony export */   generateId: () => (/* binding */ generateId),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isAbortError: () => (/* binding */ isAbortError),\n/* harmony export */   isParsableJson: () => (/* binding */ isParsableJson),\n/* harmony export */   isParseableJson: () => (/* binding */ isParseableJson),\n/* harmony export */   isValidator: () => (/* binding */ isValidator),\n/* harmony export */   loadApiKey: () => (/* binding */ loadApiKey),\n/* harmony export */   loadOptionalSetting: () => (/* binding */ loadOptionalSetting),\n/* harmony export */   loadSetting: () => (/* binding */ loadSetting),\n/* harmony export */   parseJSON: () => (/* binding */ parseJSON),\n/* harmony export */   postJsonToApi: () => (/* binding */ postJsonToApi),\n/* harmony export */   postToApi: () => (/* binding */ postToApi),\n/* harmony export */   safeParseJSON: () => (/* binding */ safeParseJSON),\n/* harmony export */   safeValidateTypes: () => (/* binding */ safeValidateTypes),\n/* harmony export */   validateTypes: () => (/* binding */ validateTypes),\n/* harmony export */   validator: () => (/* binding */ validator),\n/* harmony export */   validatorSymbol: () => (/* binding */ validatorSymbol),\n/* harmony export */   withoutTrailingSlash: () => (/* binding */ withoutTrailingSlash),\n/* harmony export */   zodValidator: () => (/* binding */ zodValidator)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider */ \"(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\");\n/* harmony import */ var nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! nanoid/non-secure */ \"(rsc)/./node_modules/nanoid/non-secure/index.js\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! eventsource-parser/stream */ \"(rsc)/./node_modules/eventsource-parser/dist/stream.js\");\n// src/combine-headers.ts\nfunction combineHeaders(...headers) {\n    return headers.reduce((combinedHeaders, currentHeaders)=>({\n            ...combinedHeaders,\n            ...currentHeaders != null ? currentHeaders : {}\n        }), {});\n}\n// src/convert-async-generator-to-readable-stream.ts\nfunction convertAsyncGeneratorToReadableStream(stream) {\n    return new ReadableStream({\n        /**\n     * Called when the consumer wants to pull more data from the stream.\n     *\n     * @param {ReadableStreamDefaultController<T>} controller - The controller to enqueue data into the stream.\n     * @returns {Promise<void>}\n     */ async pull (controller) {\n            try {\n                const { value, done } = await stream.next();\n                if (done) {\n                    controller.close();\n                } else {\n                    controller.enqueue(value);\n                }\n            } catch (error) {\n                controller.error(error);\n            }\n        },\n        /**\n     * Called when the consumer cancels the stream.\n     */ cancel () {}\n    });\n}\n// src/extract-response-headers.ts\nfunction extractResponseHeaders(response) {\n    const headers = {};\n    response.headers.forEach((value, key)=>{\n        headers[key] = value;\n    });\n    return headers;\n}\n// src/generate-id.ts\n\n\nvar createIdGenerator = ({ prefix, size: defaultSize = 7, alphabet = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\", separator = \"-\" } = {})=>{\n    const generator = (0,nanoid_non_secure__WEBPACK_IMPORTED_MODULE_0__.customAlphabet)(alphabet, defaultSize);\n    if (prefix == null) {\n        return generator;\n    }\n    if (alphabet.includes(separator)) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.InvalidArgumentError({\n            argument: \"separator\",\n            message: `The separator \"${separator}\" must not be part of the alphabet \"${alphabet}\".`\n        });\n    }\n    return (size)=>`${prefix}${separator}${generator(size)}`;\n};\nvar generateId = createIdGenerator();\n// src/get-error-message.ts\nfunction getErrorMessage(error) {\n    if (error == null) {\n        return \"unknown error\";\n    }\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return JSON.stringify(error);\n}\n// src/is-abort-error.ts\nfunction isAbortError(error) {\n    return error instanceof Error && (error.name === \"AbortError\" || error.name === \"TimeoutError\");\n}\n// src/load-api-key.ts\n\nfunction loadApiKey({ apiKey, environmentVariableName, apiKeyParameterName = \"apiKey\", description }) {\n    if (typeof apiKey === \"string\") {\n        return apiKey;\n    }\n    if (apiKey != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key must be a string.`\n        });\n    }\n    if (typeof process === \"undefined\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter. Environment variables is not supported in this environment.`\n        });\n    }\n    apiKey = process.env[environmentVariableName];\n    if (apiKey == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key is missing. Pass it using the '${apiKeyParameterName}' parameter or the ${environmentVariableName} environment variable.`\n        });\n    }\n    if (typeof apiKey !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadAPIKeyError({\n            message: `${description} API key must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n        });\n    }\n    return apiKey;\n}\n// src/load-setting.ts\n\nfunction loadSetting({ settingValue, environmentVariableName, settingName, description }) {\n    if (typeof settingValue === \"string\") {\n        return settingValue;\n    }\n    if (settingValue != null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting must be a string.`\n        });\n    }\n    if (typeof process === \"undefined\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting is missing. Pass it using the '${settingName}' parameter. Environment variables is not supported in this environment.`\n        });\n    }\n    settingValue = process.env[environmentVariableName];\n    if (settingValue == null) {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting is missing. Pass it using the '${settingName}' parameter or the ${environmentVariableName} environment variable.`\n        });\n    }\n    if (typeof settingValue !== \"string\") {\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.LoadSettingError({\n            message: `${description} setting must be a string. The value of the ${environmentVariableName} environment variable is not a string.`\n        });\n    }\n    return settingValue;\n}\n// src/load-optional-setting.ts\nfunction loadOptionalSetting({ settingValue, environmentVariableName }) {\n    if (typeof settingValue === \"string\") {\n        return settingValue;\n    }\n    if (settingValue != null || typeof process === \"undefined\") {\n        return void 0;\n    }\n    settingValue = process.env[environmentVariableName];\n    if (settingValue == null || typeof settingValue !== \"string\") {\n        return void 0;\n    }\n    return settingValue;\n}\n// src/parse-json.ts\n\n\n// src/validate-types.ts\n\n// src/validator.ts\nvar validatorSymbol = Symbol.for(\"vercel.ai.validator\");\nfunction validator(validate) {\n    return {\n        [validatorSymbol]: true,\n        validate\n    };\n}\nfunction isValidator(value) {\n    return typeof value === \"object\" && value !== null && validatorSymbol in value && value[validatorSymbol] === true && \"validate\" in value;\n}\nfunction asValidator(value) {\n    return isValidator(value) ? value : zodValidator(value);\n}\nfunction zodValidator(zodSchema) {\n    return validator((value)=>{\n        const result = zodSchema.safeParse(value);\n        return result.success ? {\n            success: true,\n            value: result.data\n        } : {\n            success: false,\n            error: result.error\n        };\n    });\n}\n// src/validate-types.ts\nfunction validateTypes({ value, schema: inputSchema }) {\n    const result = safeValidateTypes({\n        value,\n        schema: inputSchema\n    });\n    if (!result.success) {\n        throw _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({\n            value,\n            cause: result.error\n        });\n    }\n    return result.value;\n}\nfunction safeValidateTypes({ value, schema }) {\n    const validator2 = asValidator(schema);\n    try {\n        if (validator2.validate == null) {\n            return {\n                success: true,\n                value\n            };\n        }\n        const result = validator2.validate(value);\n        if (result.success) {\n            return result;\n        }\n        return {\n            success: false,\n            error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({\n                value,\n                cause: result.error\n            })\n        };\n    } catch (error) {\n        return {\n            success: false,\n            error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.wrap({\n                value,\n                cause: error\n            })\n        };\n    }\n}\n// src/parse-json.ts\nfunction parseJSON({ text, schema }) {\n    try {\n        const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n        if (schema == null) {\n            return value;\n        }\n        return validateTypes({\n            value,\n            schema\n        });\n    } catch (error) {\n        if (_ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.TypeValidationError.isTypeValidationError(error)) {\n            throw error;\n        }\n        throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({\n            text,\n            cause: error\n        });\n    }\n}\nfunction safeParseJSON({ text, schema }) {\n    try {\n        const value = secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(text);\n        if (schema == null) {\n            return {\n                success: true,\n                value\n            };\n        }\n        return safeValidateTypes({\n            value,\n            schema\n        });\n    } catch (error) {\n        return {\n            success: false,\n            error: _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError.isJSONParseError(error) ? error : new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.JSONParseError({\n                text,\n                cause: error\n            })\n        };\n    }\n}\nfunction isParsableJson(input) {\n    try {\n        secure_json_parse__WEBPACK_IMPORTED_MODULE_2__.parse(input);\n        return true;\n    } catch (e) {\n        return false;\n    }\n}\nvar isParseableJson = isParsableJson;\n// src/post-to-api.ts\n\n// src/remove-undefined-entries.ts\nfunction removeUndefinedEntries(record) {\n    return Object.fromEntries(Object.entries(record).filter(([_key, value])=>value != null));\n}\n// src/post-to-api.ts\nvar getOriginalFetch = ()=>globalThis.fetch;\nvar postJsonToApi = async ({ url, headers, body, failedResponseHandler, successfulResponseHandler, abortSignal, fetch })=>postToApi({\n        url,\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        body: {\n            content: JSON.stringify(body),\n            values: body\n        },\n        failedResponseHandler,\n        successfulResponseHandler,\n        abortSignal,\n        fetch\n    });\nvar postToApi = async ({ url, headers = {}, body, successfulResponseHandler, failedResponseHandler, abortSignal, fetch = getOriginalFetch() })=>{\n    try {\n        const response = await fetch(url, {\n            method: \"POST\",\n            headers: removeUndefinedEntries(headers),\n            body: body.content,\n            signal: abortSignal\n        });\n        const responseHeaders = extractResponseHeaders(response);\n        if (!response.ok) {\n            let errorInformation;\n            try {\n                errorInformation = await failedResponseHandler({\n                    response,\n                    url,\n                    requestBodyValues: body.values\n                });\n            } catch (error) {\n                if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n                    throw error;\n                }\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: \"Failed to process error response\",\n                    cause: error,\n                    statusCode: response.status,\n                    url,\n                    responseHeaders,\n                    requestBodyValues: body.values\n                });\n            }\n            throw errorInformation.value;\n        }\n        try {\n            return await successfulResponseHandler({\n                response,\n                url,\n                requestBodyValues: body.values\n            });\n        } catch (error) {\n            if (error instanceof Error) {\n                if (isAbortError(error) || _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError.isAPICallError(error)) {\n                    throw error;\n                }\n            }\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Failed to process successful response\",\n                cause: error,\n                statusCode: response.status,\n                url,\n                responseHeaders,\n                requestBodyValues: body.values\n            });\n        }\n    } catch (error) {\n        if (isAbortError(error)) {\n            throw error;\n        }\n        if (error instanceof TypeError && error.message === \"fetch failed\") {\n            const cause = error.cause;\n            if (cause != null) {\n                throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: `Cannot connect to API: ${cause.message}`,\n                    cause,\n                    url,\n                    requestBodyValues: body.values,\n                    isRetryable: true\n                });\n            }\n        }\n        throw error;\n    }\n};\n// src/response-handler.ts\n\n\nvar createJsonErrorResponseHandler = ({ errorSchema, errorToMessage, isRetryable })=>async ({ response, url, requestBodyValues })=>{\n        const responseBody = await response.text();\n        const responseHeaders = extractResponseHeaders(response);\n        if (responseBody.trim() === \"\") {\n            return {\n                responseHeaders,\n                value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: response.statusText,\n                    url,\n                    requestBodyValues,\n                    statusCode: response.status,\n                    responseHeaders,\n                    responseBody,\n                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n                })\n            };\n        }\n        try {\n            const parsedError = parseJSON({\n                text: responseBody,\n                schema: errorSchema\n            });\n            return {\n                responseHeaders,\n                value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: errorToMessage(parsedError),\n                    url,\n                    requestBodyValues,\n                    statusCode: response.status,\n                    responseHeaders,\n                    responseBody,\n                    data: parsedError,\n                    isRetryable: isRetryable == null ? void 0 : isRetryable(response, parsedError)\n                })\n            };\n        } catch (parseError) {\n            return {\n                responseHeaders,\n                value: new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                    message: response.statusText,\n                    url,\n                    requestBodyValues,\n                    statusCode: response.status,\n                    responseHeaders,\n                    responseBody,\n                    isRetryable: isRetryable == null ? void 0 : isRetryable(response)\n                })\n            };\n        }\n    };\nvar createEventSourceResponseHandler = (chunkSchema)=>async ({ response })=>{\n        const responseHeaders = extractResponseHeaders(response);\n        if (response.body == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n        }\n        return {\n            responseHeaders,\n            value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new eventsource_parser_stream__WEBPACK_IMPORTED_MODULE_3__.EventSourceParserStream()).pipeThrough(new TransformStream({\n                transform ({ data }, controller) {\n                    if (data === \"[DONE]\") {\n                        return;\n                    }\n                    controller.enqueue(safeParseJSON({\n                        text: data,\n                        schema: chunkSchema\n                    }));\n                }\n            }))\n        };\n    };\nvar createJsonStreamResponseHandler = (chunkSchema)=>async ({ response })=>{\n        const responseHeaders = extractResponseHeaders(response);\n        if (response.body == null) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.EmptyResponseBodyError({});\n        }\n        let buffer = \"\";\n        return {\n            responseHeaders,\n            value: response.body.pipeThrough(new TextDecoderStream()).pipeThrough(new TransformStream({\n                transform (chunkText, controller) {\n                    if (chunkText.endsWith(\"\\n\")) {\n                        controller.enqueue(safeParseJSON({\n                            text: buffer + chunkText,\n                            schema: chunkSchema\n                        }));\n                        buffer = \"\";\n                    } else {\n                        buffer += chunkText;\n                    }\n                }\n            }))\n        };\n    };\nvar createJsonResponseHandler = (responseSchema)=>async ({ response, url, requestBodyValues })=>{\n        const responseBody = await response.text();\n        const parsedResult = safeParseJSON({\n            text: responseBody,\n            schema: responseSchema\n        });\n        const responseHeaders = extractResponseHeaders(response);\n        if (!parsedResult.success) {\n            throw new _ai_sdk_provider__WEBPACK_IMPORTED_MODULE_1__.APICallError({\n                message: \"Invalid JSON response\",\n                cause: parsedResult.error,\n                statusCode: response.status,\n                responseHeaders,\n                responseBody,\n                url,\n                requestBodyValues\n            });\n        }\n        return {\n            responseHeaders,\n            value: parsedResult.value\n        };\n    };\n// src/uint8-utils.ts\nvar { btoa, atob } = globalThis;\nfunction convertBase64ToUint8Array(base64String) {\n    const base64Url = base64String.replace(/-/g, \"+\").replace(/_/g, \"/\");\n    const latin1string = atob(base64Url);\n    return Uint8Array.from(latin1string, (byte)=>byte.codePointAt(0));\n}\nfunction convertUint8ArrayToBase64(array) {\n    let latin1string = \"\";\n    for(let i = 0; i < array.length; i++){\n        latin1string += String.fromCodePoint(array[i]);\n    }\n    return btoa(latin1string);\n}\n// src/without-trailing-slash.ts\nfunction withoutTrailingSlash(url) {\n    return url == null ? void 0 : url.replace(/\\/$/, \"\");\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQUEseUJBQXlCO0FBQ3pCLFNBQVNBLGVBQWUsR0FBR0MsT0FBTztJQUNoQyxPQUFPQSxRQUFRQyxNQUFNLENBQ25CLENBQUNDLGlCQUFpQkMsaUJBQW9CO1lBQ3BDLEdBQUdELGVBQWU7WUFDbEIsR0FBR0Msa0JBQWtCLE9BQU9BLGlCQUFpQixDQUFDLENBQUM7UUFDakQsSUFDQSxDQUFDO0FBRUw7QUFFQSxvREFBb0Q7QUFDcEQsU0FBU0Msc0NBQXNDQyxNQUFNO0lBQ25ELE9BQU8sSUFBSUMsZUFBZTtRQUN4Qjs7Ozs7S0FLQyxHQUNELE1BQU1DLE1BQUtDLFVBQVU7WUFDbkIsSUFBSTtnQkFDRixNQUFNLEVBQUVDLEtBQUssRUFBRUMsSUFBSSxFQUFFLEdBQUcsTUFBTUwsT0FBT00sSUFBSTtnQkFDekMsSUFBSUQsTUFBTTtvQkFDUkYsV0FBV0ksS0FBSztnQkFDbEIsT0FBTztvQkFDTEosV0FBV0ssT0FBTyxDQUFDSjtnQkFDckI7WUFDRixFQUFFLE9BQU9LLE9BQU87Z0JBQ2ROLFdBQVdNLEtBQUssQ0FBQ0E7WUFDbkI7UUFDRjtRQUNBOztLQUVDLEdBQ0RDLFdBQ0E7SUFDRjtBQUNGO0FBRUEsa0NBQWtDO0FBQ2xDLFNBQVNDLHVCQUF1QkMsUUFBUTtJQUN0QyxNQUFNakIsVUFBVSxDQUFDO0lBQ2pCaUIsU0FBU2pCLE9BQU8sQ0FBQ2tCLE9BQU8sQ0FBQyxDQUFDVCxPQUFPVTtRQUMvQm5CLE9BQU8sQ0FBQ21CLElBQUksR0FBR1Y7SUFDakI7SUFDQSxPQUFPVDtBQUNUO0FBRUEscUJBQXFCO0FBQ21DO0FBQ0w7QUFDbkQsSUFBSXNCLG9CQUFvQixDQUFDLEVBQ3ZCQyxNQUFNLEVBQ05DLE1BQU1DLGNBQWMsQ0FBQyxFQUNyQkMsV0FBVyxnRUFBZ0UsRUFD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SUFDQSxPQUFPYixLQUFLTTtBQUNkO0FBRUEsZ0NBQWdDO0FBQ2hDLFNBQVNXLHFCQUFxQjVELEdBQUc7SUFDL0IsT0FBT0EsT0FBTyxPQUFPLEtBQUssSUFBSUEsSUFBSWdELE9BQU8sQ0FBQyxPQUFPO0FBQ25EO0FBZ0NFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcnN0X2NoYXRib3QvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci11dGlscy9kaXN0L2luZGV4Lm1qcz9hNzFkIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9jb21iaW5lLWhlYWRlcnMudHNcbmZ1bmN0aW9uIGNvbWJpbmVIZWFkZXJzKC4uLmhlYWRlcnMpIHtcbiAgcmV0dXJuIGhlYWRlcnMucmVkdWNlKFxuICAgIChjb21iaW5lZEhlYWRlcnMsIGN1cnJlbnRIZWFkZXJzKSA9PiAoe1xuICAgICAgLi4uY29tYmluZWRIZWFkZXJzLFxuICAgICAgLi4uY3VycmVudEhlYWRlcnMgIT0gbnVsbCA/IGN1cnJlbnRIZWFkZXJzIDoge31cbiAgICB9KSxcbiAgICB7fVxuICApO1xufVxuXG4vLyBzcmMvY29udmVydC1hc3luYy1nZW5lcmF0b3ItdG8tcmVhZGFibGUtc3RyZWFtLnRzXG5mdW5jdGlvbiBjb252ZXJ0QXN5bmNHZW5lcmF0b3JUb1JlYWRhYmxlU3RyZWFtKHN0cmVhbSkge1xuICByZXR1cm4gbmV3IFJlYWRhYmxlU3RyZWFtKHtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiB0aGUgY29uc3VtZXIgd2FudHMgdG8gcHVsbCBtb3JlIGRhdGEgZnJvbSB0aGUgc3RyZWFtLlxuICAgICAqXG4gICAgICogQHBhcmFtIHtSZWFkYWJsZVN0cmVhbURlZmF1bHRDb250cm9sbGVyPFQ+fSBjb250cm9sbGVyIC0gVGhlIGNvbnRyb2xsZXIgdG8gZW5xdWV1ZSBkYXRhIGludG8gdGhlIHN0cmVhbS5cbiAgICAgKiBAcmV0dXJucyB7UHJvbWlzZTx2b2lkPn1cbiAgICAgKi9cbiAgICBhc3luYyBwdWxsKGNvbnRyb2xsZXIpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIGRvbmUgfSA9IGF3YWl0IHN0cmVhbS5uZXh0KCk7XG4gICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgY29udHJvbGxlci5jbG9zZSgpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGNvbnRyb2xsZXIuZW5xdWV1ZSh2YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuZXJyb3IoZXJyb3IpO1xuICAgICAgfVxuICAgIH0sXG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbnN1bWVyIGNhbmNlbHMgdGhlIHN0cmVhbS5cbiAgICAgKi9cbiAgICBjYW5jZWwoKSB7XG4gICAgfVxuICB9KTtcbn1cblxuLy8gc3JjL2V4dHJhY3QtcmVzcG9uc2UtaGVhZGVycy50c1xuZnVuY3Rpb24gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSkge1xuICBjb25zdCBoZWFkZXJzID0ge307XG4gIHJlc3BvbnNlLmhlYWRlcnMuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuICAgIGhlYWRlcnNba2V5XSA9IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGhlYWRlcnM7XG59XG5cbi8vIHNyYy9nZW5lcmF0ZS1pZC50c1xuaW1wb3J0IHsgSW52YWxpZEFyZ3VtZW50RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHsgY3VzdG9tQWxwaGFiZXQgfSBmcm9tIFwibmFub2lkL25vbi1zZWN1cmVcIjtcbnZhciBjcmVhdGVJZEdlbmVyYXRvciA9ICh7XG4gIHByZWZpeCxcbiAgc2l6ZTogZGVmYXVsdFNpemUgPSA3LFxuICBhbHBoYWJldCA9IFwiMDEyMzQ1Njc4OUFCQ0RFRkdISUpLTE1OT1BRUlNUVVZXWFlaYWJjZGVmZ2hpamtsbW5vcHFyc3R1dnd4eXpcIixcbiAgc2VwYXJhdG9yID0gXCItXCJcbn0gPSB7fSkgPT4ge1xuICBjb25zdCBnZW5lcmF0b3IgPSBjdXN0b21BbHBoYWJldChhbHBoYWJldCwgZGVmYXVsdFNpemUpO1xuICBpZiAocHJlZml4ID09IG51bGwpIHtcbiAgICByZXR1cm4gZ2VuZXJhdG9yO1xuICB9XG4gIGlmIChhbHBoYWJldC5pbmNsdWRlcyhzZXBhcmF0b3IpKSB7XG4gICAgdGhyb3cgbmV3IEludmFsaWRBcmd1bWVudEVycm9yKHtcbiAgICAgIGFyZ3VtZW50OiBcInNlcGFyYXRvclwiLFxuICAgICAgbWVzc2FnZTogYFRoZSBzZXBhcmF0b3IgXCIke3NlcGFyYXRvcn1cIiBtdXN0IG5vdCBiZSBwYXJ0IG9mIHRoZSBhbHBoYWJldCBcIiR7YWxwaGFiZXR9XCIuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiAoc2l6ZSkgPT4gYCR7cHJlZml4fSR7c2VwYXJhdG9yfSR7Z2VuZXJhdG9yKHNpemUpfWA7XG59O1xudmFyIGdlbmVyYXRlSWQgPSBjcmVhdGVJZEdlbmVyYXRvcigpO1xuXG4vLyBzcmMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2lzLWFib3J0LWVycm9yLnRzXG5mdW5jdGlvbiBpc0Fib3J0RXJyb3IoZXJyb3IpIHtcbiAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgKGVycm9yLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiIHx8IGVycm9yLm5hbWUgPT09IFwiVGltZW91dEVycm9yXCIpO1xufVxuXG4vLyBzcmMvbG9hZC1hcGkta2V5LnRzXG5pbXBvcnQgeyBMb2FkQVBJS2V5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuZnVuY3Rpb24gbG9hZEFwaUtleSh7XG4gIGFwaUtleSxcbiAgZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUsXG4gIGFwaUtleVBhcmFtZXRlck5hbWUgPSBcImFwaUtleVwiLFxuICBkZXNjcmlwdGlvblxufSkge1xuICBpZiAodHlwZW9mIGFwaUtleSA9PT0gXCJzdHJpbmdcIikge1xuICAgIHJldHVybiBhcGlLZXk7XG4gIH1cbiAgaWYgKGFwaUtleSAhPSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBtdXN0IGJlIGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IGlzIG1pc3NpbmcuIFBhc3MgaXQgdXNpbmcgdGhlICcke2FwaUtleVBhcmFtZXRlck5hbWV9JyBwYXJhbWV0ZXIuIEVudmlyb25tZW50IHZhcmlhYmxlcyBpcyBub3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQuYFxuICAgIH0pO1xuICB9XG4gIGFwaUtleSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKGFwaUtleSA9PSBudWxsKSB7XG4gICAgdGhyb3cgbmV3IExvYWRBUElLZXlFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gQVBJIGtleSBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHthcGlLZXlQYXJhbWV0ZXJOYW1lfScgcGFyYW1ldGVyIG9yIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZS5gXG4gICAgfSk7XG4gIH1cbiAgaWYgKHR5cGVvZiBhcGlLZXkgIT09IFwic3RyaW5nXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZEFQSUtleUVycm9yKHtcbiAgICAgIG1lc3NhZ2U6IGAke2Rlc2NyaXB0aW9ufSBBUEkga2V5IG11c3QgYmUgYSBzdHJpbmcuIFRoZSB2YWx1ZSBvZiB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbm90IGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICByZXR1cm4gYXBpS2V5O1xufVxuXG4vLyBzcmMvbG9hZC1zZXR0aW5nLnRzXG5pbXBvcnQgeyBMb2FkU2V0dGluZ0Vycm9yIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXJcIjtcbmZ1bmN0aW9uIGxvYWRTZXR0aW5nKHtcbiAgc2V0dGluZ1ZhbHVlLFxuICBlbnZpcm9ubWVudFZhcmlhYmxlTmFtZSxcbiAgc2V0dGluZ05hbWUsXG4gIGRlc2NyaXB0aW9uXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBtdXN0IGJlIGEgc3RyaW5nLmBcbiAgICB9KTtcbiAgfVxuICBpZiAodHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHtzZXR0aW5nTmFtZX0nIHBhcmFtZXRlci4gRW52aXJvbm1lbnQgdmFyaWFibGVzIGlzIG5vdCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudC5gXG4gICAgfSk7XG4gIH1cbiAgc2V0dGluZ1ZhbHVlID0gcHJvY2Vzcy5lbnZbZW52aXJvbm1lbnRWYXJpYWJsZU5hbWVdO1xuICBpZiAoc2V0dGluZ1ZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgTG9hZFNldHRpbmdFcnJvcih7XG4gICAgICBtZXNzYWdlOiBgJHtkZXNjcmlwdGlvbn0gc2V0dGluZyBpcyBtaXNzaW5nLiBQYXNzIGl0IHVzaW5nIHRoZSAnJHtzZXR0aW5nTmFtZX0nIHBhcmFtZXRlciBvciB0aGUgJHtlbnZpcm9ubWVudFZhcmlhYmxlTmFtZX0gZW52aXJvbm1lbnQgdmFyaWFibGUuYFxuICAgIH0pO1xuICB9XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgdGhyb3cgbmV3IExvYWRTZXR0aW5nRXJyb3Ioe1xuICAgICAgbWVzc2FnZTogYCR7ZGVzY3JpcHRpb259IHNldHRpbmcgbXVzdCBiZSBhIHN0cmluZy4gVGhlIHZhbHVlIG9mIHRoZSAke2Vudmlyb25tZW50VmFyaWFibGVOYW1lfSBlbnZpcm9ubWVudCB2YXJpYWJsZSBpcyBub3QgYSBzdHJpbmcuYFxuICAgIH0pO1xuICB9XG4gIHJldHVybiBzZXR0aW5nVmFsdWU7XG59XG5cbi8vIHNyYy9sb2FkLW9wdGlvbmFsLXNldHRpbmcudHNcbmZ1bmN0aW9uIGxvYWRPcHRpb25hbFNldHRpbmcoe1xuICBzZXR0aW5nVmFsdWUsXG4gIGVudmlyb25tZW50VmFyaWFibGVOYW1lXG59KSB7XG4gIGlmICh0eXBlb2Ygc2V0dGluZ1ZhbHVlID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIHNldHRpbmdWYWx1ZTtcbiAgfVxuICBpZiAoc2V0dGluZ1ZhbHVlICE9IG51bGwgfHwgdHlwZW9mIHByb2Nlc3MgPT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHNldHRpbmdWYWx1ZSA9IHByb2Nlc3MuZW52W2Vudmlyb25tZW50VmFyaWFibGVOYW1lXTtcbiAgaWYgKHNldHRpbmdWYWx1ZSA9PSBudWxsIHx8IHR5cGVvZiBzZXR0aW5nVmFsdWUgIT09IFwic3RyaW5nXCIpIHtcbiAgICByZXR1cm4gdm9pZCAwO1xuICB9XG4gIHJldHVybiBzZXR0aW5nVmFsdWU7XG59XG5cbi8vIHNyYy9wYXJzZS1qc29uLnRzXG5pbXBvcnQge1xuICBKU09OUGFyc2VFcnJvcixcbiAgVHlwZVZhbGlkYXRpb25FcnJvciBhcyBUeXBlVmFsaWRhdGlvbkVycm9yMlxufSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IFNlY3VyZUpTT04gZnJvbSBcInNlY3VyZS1qc29uLXBhcnNlXCI7XG5cbi8vIHNyYy92YWxpZGF0ZS10eXBlcy50c1xuaW1wb3J0IHsgVHlwZVZhbGlkYXRpb25FcnJvciB9IGZyb20gXCJAYWktc2RrL3Byb3ZpZGVyXCI7XG5cbi8vIHNyYy92YWxpZGF0b3IudHNcbnZhciB2YWxpZGF0b3JTeW1ib2wgPSBTeW1ib2wuZm9yKFwidmVyY2VsLmFpLnZhbGlkYXRvclwiKTtcbmZ1bmN0aW9uIHZhbGlkYXRvcih2YWxpZGF0ZSkge1xuICByZXR1cm4geyBbdmFsaWRhdG9yU3ltYm9sXTogdHJ1ZSwgdmFsaWRhdGUgfTtcbn1cbmZ1bmN0aW9uIGlzVmFsaWRhdG9yKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgdmFsaWRhdG9yU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3ZhbGlkYXRvclN5bWJvbF0gPT09IHRydWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNWYWxpZGF0b3IodmFsdWUpIHtcbiAgcmV0dXJuIGlzVmFsaWRhdG9yKHZhbHVlKSA/IHZhbHVlIDogem9kVmFsaWRhdG9yKHZhbHVlKTtcbn1cbmZ1bmN0aW9uIHpvZFZhbGlkYXRvcih6b2RTY2hlbWEpIHtcbiAgcmV0dXJuIHZhbGlkYXRvcigodmFsdWUpID0+IHtcbiAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEuc2FmZVBhcnNlKHZhbHVlKTtcbiAgICByZXR1cm4gcmVzdWx0LnN1Y2Nlc3MgPyB7IHN1Y2Nlc3M6IHRydWUsIHZhbHVlOiByZXN1bHQuZGF0YSB9IDogeyBzdWNjZXNzOiBmYWxzZSwgZXJyb3I6IHJlc3VsdC5lcnJvciB9O1xuICB9KTtcbn1cblxuLy8gc3JjL3ZhbGlkYXRlLXR5cGVzLnRzXG5mdW5jdGlvbiB2YWxpZGF0ZVR5cGVzKHtcbiAgdmFsdWUsXG4gIHNjaGVtYTogaW5wdXRTY2hlbWFcbn0pIHtcbiAgY29uc3QgcmVzdWx0ID0gc2FmZVZhbGlkYXRlVHlwZXMoeyB2YWx1ZSwgc2NoZW1hOiBpbnB1dFNjaGVtYSB9KTtcbiAgaWYgKCFyZXN1bHQuc3VjY2Vzcykge1xuICAgIHRocm93IFR5cGVWYWxpZGF0aW9uRXJyb3Iud3JhcCh7IHZhbHVlLCBjYXVzZTogcmVzdWx0LmVycm9yIH0pO1xuICB9XG4gIHJldHVybiByZXN1bHQudmFsdWU7XG59XG5mdW5jdGlvbiBzYWZlVmFsaWRhdGVUeXBlcyh7XG4gIHZhbHVlLFxuICBzY2hlbWFcbn0pIHtcbiAgY29uc3QgdmFsaWRhdG9yMiA9IGFzVmFsaWRhdG9yKHNjaGVtYSk7XG4gIHRyeSB7XG4gICAgaWYgKHZhbGlkYXRvcjIudmFsaWRhdGUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHsgc3VjY2VzczogdHJ1ZSwgdmFsdWUgfTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0gdmFsaWRhdG9yMi52YWxpZGF0ZSh2YWx1ZSk7XG4gICAgaWYgKHJlc3VsdC5zdWNjZXNzKSB7XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogVHlwZVZhbGlkYXRpb25FcnJvci53cmFwKHsgdmFsdWUsIGNhdXNlOiByZXN1bHQuZXJyb3IgfSlcbiAgICB9O1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHJldHVybiB7XG4gICAgICBzdWNjZXNzOiBmYWxzZSxcbiAgICAgIGVycm9yOiBUeXBlVmFsaWRhdGlvbkVycm9yLndyYXAoeyB2YWx1ZSwgY2F1c2U6IGVycm9yIH0pXG4gICAgfTtcbiAgfVxufVxuXG4vLyBzcmMvcGFyc2UtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VKU09OKHtcbiAgdGV4dCxcbiAgc2NoZW1hXG59KSB7XG4gIHRyeSB7XG4gICAgY29uc3QgdmFsdWUgPSBTZWN1cmVKU09OLnBhcnNlKHRleHQpO1xuICAgIGlmIChzY2hlbWEgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIHZhbHVlO1xuICAgIH1cbiAgICByZXR1cm4gdmFsaWRhdGVUeXBlcyh7IHZhbHVlLCBzY2hlbWEgfSk7XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKEpTT05QYXJzZUVycm9yLmlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpIHx8IFR5cGVWYWxpZGF0aW9uRXJyb3IyLmlzVHlwZVZhbGlkYXRpb25FcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICB0aHJvdyBuZXcgSlNPTlBhcnNlRXJyb3IoeyB0ZXh0LCBjYXVzZTogZXJyb3IgfSk7XG4gIH1cbn1cbmZ1bmN0aW9uIHNhZmVQYXJzZUpTT04oe1xuICB0ZXh0LFxuICBzY2hlbWFcbn0pIHtcbiAgdHJ5IHtcbiAgICBjb25zdCB2YWx1ZSA9IFNlY3VyZUpTT04ucGFyc2UodGV4dCk7XG4gICAgaWYgKHNjaGVtYSA9PSBudWxsKSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICBzdWNjZXNzOiB0cnVlLFxuICAgICAgICB2YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHNhZmVWYWxpZGF0ZVR5cGVzKHsgdmFsdWUsIHNjaGVtYSB9KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICByZXR1cm4ge1xuICAgICAgc3VjY2VzczogZmFsc2UsXG4gICAgICBlcnJvcjogSlNPTlBhcnNlRXJyb3IuaXNKU09OUGFyc2VFcnJvcihlcnJvcikgPyBlcnJvciA6IG5ldyBKU09OUGFyc2VFcnJvcih7IHRleHQsIGNhdXNlOiBlcnJvciB9KVxuICAgIH07XG4gIH1cbn1cbmZ1bmN0aW9uIGlzUGFyc2FibGVKc29uKGlucHV0KSB7XG4gIHRyeSB7XG4gICAgU2VjdXJlSlNPTi5wYXJzZShpbnB1dCk7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gY2F0Y2ggKGUpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbn1cbnZhciBpc1BhcnNlYWJsZUpzb24gPSBpc1BhcnNhYmxlSnNvbjtcblxuLy8gc3JjL3Bvc3QtdG8tYXBpLnRzXG5pbXBvcnQgeyBBUElDYWxsRXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuXG4vLyBzcmMvcmVtb3ZlLXVuZGVmaW5lZC1lbnRyaWVzLnRzXG5mdW5jdGlvbiByZW1vdmVVbmRlZmluZWRFbnRyaWVzKHJlY29yZCkge1xuICByZXR1cm4gT2JqZWN0LmZyb21FbnRyaWVzKFxuICAgIE9iamVjdC5lbnRyaWVzKHJlY29yZCkuZmlsdGVyKChbX2tleSwgdmFsdWVdKSA9PiB2YWx1ZSAhPSBudWxsKVxuICApO1xufVxuXG4vLyBzcmMvcG9zdC10by1hcGkudHNcbnZhciBnZXRPcmlnaW5hbEZldGNoID0gKCkgPT4gZ2xvYmFsVGhpcy5mZXRjaDtcbnZhciBwb3N0SnNvblRvQXBpID0gYXN5bmMgKHtcbiAgdXJsLFxuICBoZWFkZXJzLFxuICBib2R5LFxuICBmYWlsZWRSZXNwb25zZUhhbmRsZXIsXG4gIHN1Y2Nlc3NmdWxSZXNwb25zZUhhbmRsZXIsXG4gIGFib3J0U2lnbmFsLFxuICBmZXRjaFxufSkgPT4gcG9zdFRvQXBpKHtcbiAgdXJsLFxuICBoZWFkZXJzOiB7XG4gICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgLi4uaGVhZGVyc1xuICB9LFxuICBib2R5OiB7XG4gICAgY29udGVudDogSlNPTi5zdHJpbmdpZnkoYm9keSksXG4gICAgdmFsdWVzOiBib2R5XG4gIH0sXG4gIGZhaWxlZFJlc3BvbnNlSGFuZGxlcixcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgYWJvcnRTaWduYWwsXG4gIGZldGNoXG59KTtcbnZhciBwb3N0VG9BcGkgPSBhc3luYyAoe1xuICB1cmwsXG4gIGhlYWRlcnMgPSB7fSxcbiAgYm9keSxcbiAgc3VjY2Vzc2Z1bFJlc3BvbnNlSGFuZGxlcixcbiAgZmFpbGVkUmVzcG9uc2VIYW5kbGVyLFxuICBhYm9ydFNpZ25hbCxcbiAgZmV0Y2ggPSBnZXRPcmlnaW5hbEZldGNoKClcbn0pID0+IHtcbiAgdHJ5IHtcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoKHVybCwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGhlYWRlcnM6IHJlbW92ZVVuZGVmaW5lZEVudHJpZXMoaGVhZGVycyksXG4gICAgICBib2R5OiBib2R5LmNvbnRlbnQsXG4gICAgICBzaWduYWw6IGFib3J0U2lnbmFsXG4gICAgfSk7XG4gICAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gICAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgICAgbGV0IGVycm9ySW5mb3JtYXRpb247XG4gICAgICB0cnkge1xuICAgICAgICBlcnJvckluZm9ybWF0aW9uID0gYXdhaXQgZmFpbGVkUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgICByZXNwb25zZSxcbiAgICAgICAgICB1cmwsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IFwiRmFpbGVkIHRvIHByb2Nlc3MgZXJyb3IgcmVzcG9uc2VcIixcbiAgICAgICAgICBjYXVzZTogZXJyb3IsXG4gICAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyb3JJbmZvcm1hdGlvbi52YWx1ZTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBhd2FpdCBzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyKHtcbiAgICAgICAgcmVzcG9uc2UsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgaWYgKGVycm9yIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikgfHwgQVBJQ2FsbEVycm9yLmlzQVBJQ2FsbEVycm9yKGVycm9yKSkge1xuICAgICAgICAgIHRocm93IGVycm9yO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ2FsbEVycm9yKHtcbiAgICAgICAgbWVzc2FnZTogXCJGYWlsZWQgdG8gcHJvY2VzcyBzdWNjZXNzZnVsIHJlc3BvbnNlXCIsXG4gICAgICAgIGNhdXNlOiBlcnJvcixcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICB1cmwsXG4gICAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXM6IGJvZHkudmFsdWVzXG4gICAgICB9KTtcbiAgICB9XG4gIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgaWYgKGlzQWJvcnRFcnJvcihlcnJvcikpIHtcbiAgICAgIHRocm93IGVycm9yO1xuICAgIH1cbiAgICBpZiAoZXJyb3IgaW5zdGFuY2VvZiBUeXBlRXJyb3IgJiYgZXJyb3IubWVzc2FnZSA9PT0gXCJmZXRjaCBmYWlsZWRcIikge1xuICAgICAgY29uc3QgY2F1c2UgPSBlcnJvci5jYXVzZTtcbiAgICAgIGlmIChjYXVzZSAhPSBudWxsKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDYWxsRXJyb3Ioe1xuICAgICAgICAgIG1lc3NhZ2U6IGBDYW5ub3QgY29ubmVjdCB0byBBUEk6ICR7Y2F1c2UubWVzc2FnZX1gLFxuICAgICAgICAgIGNhdXNlLFxuICAgICAgICAgIHVybCxcbiAgICAgICAgICByZXF1ZXN0Qm9keVZhbHVlczogYm9keS52YWx1ZXMsXG4gICAgICAgICAgaXNSZXRyeWFibGU6IHRydWVcbiAgICAgICAgICAvLyByZXRyeSB3aGVuIG5ldHdvcmsgZXJyb3JcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICAgIHRocm93IGVycm9yO1xuICB9XG59O1xuXG4vLyBzcmMvcmVzcG9uc2UtaGFuZGxlci50c1xuaW1wb3J0IHsgQVBJQ2FsbEVycm9yIGFzIEFQSUNhbGxFcnJvcjIsIEVtcHR5UmVzcG9uc2VCb2R5RXJyb3IgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlclwiO1xuaW1wb3J0IHtcbiAgRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW1cbn0gZnJvbSBcImV2ZW50c291cmNlLXBhcnNlci9zdHJlYW1cIjtcbnZhciBjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIgPSAoe1xuICBlcnJvclNjaGVtYSxcbiAgZXJyb3JUb01lc3NhZ2UsXG4gIGlzUmV0cnlhYmxlXG59KSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZUJvZHkudHJpbSgpID09PSBcIlwiKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbiAgdHJ5IHtcbiAgICBjb25zdCBwYXJzZWRFcnJvciA9IHBhcnNlSlNPTih7XG4gICAgICB0ZXh0OiByZXNwb25zZUJvZHksXG4gICAgICBzY2hlbWE6IGVycm9yU2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgIG1lc3NhZ2U6IGVycm9yVG9NZXNzYWdlKHBhcnNlZEVycm9yKSxcbiAgICAgICAgdXJsLFxuICAgICAgICByZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgICAgc3RhdHVzQ29kZTogcmVzcG9uc2Uuc3RhdHVzLFxuICAgICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIHJlc3BvbnNlQm9keSxcbiAgICAgICAgZGF0YTogcGFyc2VkRXJyb3IsXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UsIHBhcnNlZEVycm9yKVxuICAgICAgfSlcbiAgICB9O1xuICB9IGNhdGNoIChwYXJzZUVycm9yKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHJlc3BvbnNlSGVhZGVycyxcbiAgICAgIHZhbHVlOiBuZXcgQVBJQ2FsbEVycm9yMih7XG4gICAgICAgIG1lc3NhZ2U6IHJlc3BvbnNlLnN0YXR1c1RleHQsXG4gICAgICAgIHVybCxcbiAgICAgICAgcmVxdWVzdEJvZHlWYWx1ZXMsXG4gICAgICAgIHN0YXR1c0NvZGU6IHJlc3BvbnNlLnN0YXR1cyxcbiAgICAgICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgICAgICByZXNwb25zZUJvZHksXG4gICAgICAgIGlzUmV0cnlhYmxlOiBpc1JldHJ5YWJsZSA9PSBudWxsID8gdm9pZCAwIDogaXNSZXRyeWFibGUocmVzcG9uc2UpXG4gICAgICB9KVxuICAgIH07XG4gIH1cbn07XG52YXIgY3JlYXRlRXZlbnRTb3VyY2VSZXNwb25zZUhhbmRsZXIgPSAoY2h1bmtTY2hlbWEpID0+IGFzeW5jICh7IHJlc3BvbnNlIH0pID0+IHtcbiAgY29uc3QgcmVzcG9uc2VIZWFkZXJzID0gZXh0cmFjdFJlc3BvbnNlSGVhZGVycyhyZXNwb25zZSk7XG4gIGlmIChyZXNwb25zZS5ib2R5ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRW1wdHlSZXNwb25zZUJvZHlFcnJvcih7fSk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKG5ldyBFdmVudFNvdXJjZVBhcnNlclN0cmVhbSgpKS5waXBlVGhyb3VnaChcbiAgICAgIG5ldyBUcmFuc2Zvcm1TdHJlYW0oe1xuICAgICAgICB0cmFuc2Zvcm0oeyBkYXRhIH0sIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoZGF0YSA9PT0gXCJbRE9ORV1cIikge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICBzYWZlUGFyc2VKU09OKHtcbiAgICAgICAgICAgICAgdGV4dDogZGF0YSxcbiAgICAgICAgICAgICAgc2NoZW1hOiBjaHVua1NjaGVtYVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KVxuICAgIClcbiAgfTtcbn07XG52YXIgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlciA9IChjaHVua1NjaGVtYSkgPT4gYXN5bmMgKHsgcmVzcG9uc2UgfSkgPT4ge1xuICBjb25zdCByZXNwb25zZUhlYWRlcnMgPSBleHRyYWN0UmVzcG9uc2VIZWFkZXJzKHJlc3BvbnNlKTtcbiAgaWYgKHJlc3BvbnNlLmJvZHkgPT0gbnVsbCkge1xuICAgIHRocm93IG5ldyBFbXB0eVJlc3BvbnNlQm9keUVycm9yKHt9KTtcbiAgfVxuICBsZXQgYnVmZmVyID0gXCJcIjtcbiAgcmV0dXJuIHtcbiAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgdmFsdWU6IHJlc3BvbnNlLmJvZHkucGlwZVRocm91Z2gobmV3IFRleHREZWNvZGVyU3RyZWFtKCkpLnBpcGVUaHJvdWdoKFxuICAgICAgbmV3IFRyYW5zZm9ybVN0cmVhbSh7XG4gICAgICAgIHRyYW5zZm9ybShjaHVua1RleHQsIGNvbnRyb2xsZXIpIHtcbiAgICAgICAgICBpZiAoY2h1bmtUZXh0LmVuZHNXaXRoKFwiXFxuXCIpKSB7XG4gICAgICAgICAgICBjb250cm9sbGVyLmVucXVldWUoXG4gICAgICAgICAgICAgIHNhZmVQYXJzZUpTT04oe1xuICAgICAgICAgICAgICAgIHRleHQ6IGJ1ZmZlciArIGNodW5rVGV4dCxcbiAgICAgICAgICAgICAgICBzY2hlbWE6IGNodW5rU2NoZW1hXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICAgICAgYnVmZmVyID0gXCJcIjtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgYnVmZmVyICs9IGNodW5rVGV4dDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0pXG4gICAgKVxuICB9O1xufTtcbnZhciBjcmVhdGVKc29uUmVzcG9uc2VIYW5kbGVyID0gKHJlc3BvbnNlU2NoZW1hKSA9PiBhc3luYyAoeyByZXNwb25zZSwgdXJsLCByZXF1ZXN0Qm9keVZhbHVlcyB9KSA9PiB7XG4gIGNvbnN0IHJlc3BvbnNlQm9keSA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgY29uc3QgcGFyc2VkUmVzdWx0ID0gc2FmZVBhcnNlSlNPTih7XG4gICAgdGV4dDogcmVzcG9uc2VCb2R5LFxuICAgIHNjaGVtYTogcmVzcG9uc2VTY2hlbWFcbiAgfSk7XG4gIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGV4dHJhY3RSZXNwb25zZUhlYWRlcnMocmVzcG9uc2UpO1xuICBpZiAoIXBhcnNlZFJlc3VsdC5zdWNjZXNzKSB7XG4gICAgdGhyb3cgbmV3IEFQSUNhbGxFcnJvcjIoe1xuICAgICAgbWVzc2FnZTogXCJJbnZhbGlkIEpTT04gcmVzcG9uc2VcIixcbiAgICAgIGNhdXNlOiBwYXJzZWRSZXN1bHQuZXJyb3IsXG4gICAgICBzdGF0dXNDb2RlOiByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHksXG4gICAgICB1cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlc1xuICAgIH0pO1xuICB9XG4gIHJldHVybiB7XG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHZhbHVlOiBwYXJzZWRSZXN1bHQudmFsdWVcbiAgfTtcbn07XG5cbi8vIHNyYy91aW50OC11dGlscy50c1xudmFyIHsgYnRvYSwgYXRvYiB9ID0gZ2xvYmFsVGhpcztcbmZ1bmN0aW9uIGNvbnZlcnRCYXNlNjRUb1VpbnQ4QXJyYXkoYmFzZTY0U3RyaW5nKSB7XG4gIGNvbnN0IGJhc2U2NFVybCA9IGJhc2U2NFN0cmluZy5yZXBsYWNlKC8tL2csIFwiK1wiKS5yZXBsYWNlKC9fL2csIFwiL1wiKTtcbiAgY29uc3QgbGF0aW4xc3RyaW5nID0gYXRvYihiYXNlNjRVcmwpO1xuICByZXR1cm4gVWludDhBcnJheS5mcm9tKGxhdGluMXN0cmluZywgKGJ5dGUpID0+IGJ5dGUuY29kZVBvaW50QXQoMCkpO1xufVxuZnVuY3Rpb24gY29udmVydFVpbnQ4QXJyYXlUb0Jhc2U2NChhcnJheSkge1xuICBsZXQgbGF0aW4xc3RyaW5nID0gXCJcIjtcbiAgZm9yIChsZXQgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgIGxhdGluMXN0cmluZyArPSBTdHJpbmcuZnJvbUNvZGVQb2ludChhcnJheVtpXSk7XG4gIH1cbiAgcmV0dXJuIGJ0b2EobGF0aW4xc3RyaW5nKTtcbn1cblxuLy8gc3JjL3dpdGhvdXQtdHJhaWxpbmctc2xhc2gudHNcbmZ1bmN0aW9uIHdpdGhvdXRUcmFpbGluZ1NsYXNoKHVybCkge1xuICByZXR1cm4gdXJsID09IG51bGwgPyB2b2lkIDAgOiB1cmwucmVwbGFjZSgvXFwvJC8sIFwiXCIpO1xufVxuZXhwb3J0IHtcbiAgYXNWYWxpZGF0b3IsXG4gIGNvbWJpbmVIZWFkZXJzLFxuICBjb252ZXJ0QXN5bmNHZW5lcmF0b3JUb1JlYWRhYmxlU3RyZWFtLFxuICBjb252ZXJ0QmFzZTY0VG9VaW50OEFycmF5LFxuICBjb252ZXJ0VWludDhBcnJheVRvQmFzZTY0LFxuICBjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSWRHZW5lcmF0b3IsXG4gIGNyZWF0ZUpzb25FcnJvclJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblJlc3BvbnNlSGFuZGxlcixcbiAgY3JlYXRlSnNvblN0cmVhbVJlc3BvbnNlSGFuZGxlcixcbiAgZXh0cmFjdFJlc3BvbnNlSGVhZGVycyxcbiAgZ2VuZXJhdGVJZCxcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBpc0Fib3J0RXJyb3IsXG4gIGlzUGFyc2FibGVKc29uLFxuICBpc1BhcnNlYWJsZUpzb24sXG4gIGlzVmFsaWRhdG9yLFxuICBsb2FkQXBpS2V5LFxuICBsb2FkT3B0aW9uYWxTZXR0aW5nLFxuICBsb2FkU2V0dGluZyxcbiAgcGFyc2VKU09OLFxuICBwb3N0SnNvblRvQXBpLFxuICBwb3N0VG9BcGksXG4gIHNhZmVQYXJzZUpTT04sXG4gIHNhZmVWYWxpZGF0ZVR5cGVzLFxuICB2YWxpZGF0ZVR5cGVzLFxuICB2YWxpZGF0b3IsXG4gIHZhbGlkYXRvclN5bWJvbCxcbiAgd2l0aG91dFRyYWlsaW5nU2xhc2gsXG4gIHpvZFZhbGlkYXRvclxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsiY29tYmluZUhlYWRlcnMiLCJoZWFkZXJzIiwicmVkdWNlIiwiY29tYmluZWRIZWFkZXJzIiwiY3VycmVudEhlYWRlcnMiLCJjb252ZXJ0QXN5bmNHZW5lcmF0b3JUb1JlYWRhYmxlU3RyZWFtIiwic3RyZWFtIiwiUmVhZGFibGVTdHJlYW0iLCJwdWxsIiwiY29udHJvbGxlciIsInZhbHVlIiwiZG9uZSIsIm5leHQiLCJjbG9zZSIsImVucXVldWUiLCJlcnJvciIsImNhbmNlbCIsImV4dHJhY3RSZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZSIsImZvckVhY2giLCJrZXkiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImN1c3RvbUFscGhhYmV0IiwiY3JlYXRlSWRHZW5lcmF0b3IiLCJwcmVmaXgiLCJzaXplIiwiZGVmYXVsdFNpemUiLCJhbHBoYWJldCIsInNlcGFyYXRvciIsImdlbmVyYXRvciIsImluY2x1ZGVzIiwiYXJndW1lbnQiLCJtZXNzYWdlIiwiZ2VuZXJhdGVJZCIsImdldEVycm9yTWVzc2FnZSIsIkVycm9yIiwiSlNPTiIsInN0cmluZ2lmeSIsImlzQWJvcnRFcnJvciIsIm5hbWUiLCJMb2FkQVBJS2V5RXJyb3IiLCJsb2FkQXBpS2V5IiwiYXBpS2V5IiwiZW52aXJvbm1lbnRWYXJpYWJsZU5hbWUiLCJhcGlLZXlQYXJhbWV0ZXJOYW1lIiwiZGVzY3JpcHRpb24iLCJwcm9jZXNzIiwiZW52IiwiTG9hZFNldHRpbmdFcnJvciIsImxvYWRTZXR0aW5nIiwic2V0dGluZ1ZhbHVlIiwic2V0dGluZ05hbWUiLCJsb2FkT3B0aW9uYWxTZXR0aW5nIiwiSlNPTlBhcnNlRXJyb3IiLCJUeXBlVmFsaWRhdGlvbkVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvcjIiLCJTZWN1cmVKU09OIiwidmFsaWRhdG9yU3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwidmFsaWRhdG9yIiwidmFsaWRhdGUiLCJpc1ZhbGlkYXRvciIsImFzVmFsaWRhdG9yIiwiem9kVmFsaWRhdG9yIiwiem9kU2NoZW1hIiwicmVzdWx0Iiwic2FmZVBhcnNlIiwic3VjY2VzcyIsImRhdGEiLCJ2YWxpZGF0ZVR5cGVzIiwic2NoZW1hIiwiaW5wdXRTY2hlbWEiLCJzYWZlVmFsaWRhdGVUeXBlcyIsIndyYXAiLCJjYXVzZSIsInZhbGlkYXRvcjIiLCJwYXJzZUpTT04iLCJ0ZXh0IiwicGFyc2UiLCJpc0pTT05QYXJzZUVycm9yIiwiaXNUeXBlVmFsaWRhdGlvbkVycm9yIiwic2FmZVBhcnNlSlNPTiIsImlzUGFyc2FibGVKc29uIiwiaW5wdXQiLCJlIiwiaXNQYXJzZWFibGVKc29uIiwiQVBJQ2FsbEVycm9yIiwicmVtb3ZlVW5kZWZpbmVkRW50cmllcyIsInJlY29yZCIsIk9iamVjdCIsImZyb21FbnRyaWVzIiwiZW50cmllcyIsImZpbHRlciIsIl9rZXkiLCJnZXRPcmlnaW5hbEZldGNoIiwiZ2xvYmFsVGhpcyIsImZldGNoIiwicG9zdEpzb25Ub0FwaSIsInVybCIsImJvZHkiLCJmYWlsZWRSZXNwb25zZUhhbmRsZXIiLCJzdWNjZXNzZnVsUmVzcG9uc2VIYW5kbGVyIiwiYWJvcnRTaWduYWwiLCJwb3N0VG9BcGkiLCJjb250ZW50IiwidmFsdWVzIiwibWV0aG9kIiwic2lnbmFsIiwicmVzcG9uc2VIZWFkZXJzIiwib2siLCJlcnJvckluZm9ybWF0aW9uIiwicmVxdWVzdEJvZHlWYWx1ZXMiLCJpc0FQSUNhbGxFcnJvciIsInN0YXR1c0NvZGUiLCJzdGF0dXMiLCJUeXBlRXJyb3IiLCJpc1JldHJ5YWJsZSIsIkFQSUNhbGxFcnJvcjIiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiRXZlbnRTb3VyY2VQYXJzZXJTdHJlYW0iLCJjcmVhdGVKc29uRXJyb3JSZXNwb25zZUhhbmRsZXIiLCJlcnJvclNjaGVtYSIsImVycm9yVG9NZXNzYWdlIiwicmVzcG9uc2VCb2R5IiwidHJpbSIsInN0YXR1c1RleHQiLCJwYXJzZWRFcnJvciIsInBhcnNlRXJyb3IiLCJjcmVhdGVFdmVudFNvdXJjZVJlc3BvbnNlSGFuZGxlciIsImNodW5rU2NoZW1hIiwicGlwZVRocm91Z2giLCJUZXh0RGVjb2RlclN0cmVhbSIsIlRyYW5zZm9ybVN0cmVhbSIsInRyYW5zZm9ybSIsImNyZWF0ZUpzb25TdHJlYW1SZXNwb25zZUhhbmRsZXIiLCJidWZmZXIiLCJjaHVua1RleHQiLCJlbmRzV2l0aCIsImNyZWF0ZUpzb25SZXNwb25zZUhhbmRsZXIiLCJyZXNwb25zZVNjaGVtYSIsInBhcnNlZFJlc3VsdCIsImJ0b2EiLCJhdG9iIiwiY29udmVydEJhc2U2NFRvVWludDhBcnJheSIsImJhc2U2NFN0cmluZyIsImJhc2U2NFVybCIsInJlcGxhY2UiLCJsYXRpbjFzdHJpbmciLCJVaW50OEFycmF5IiwiZnJvbSIsImJ5dGUiLCJjb2RlUG9pbnRBdCIsImNvbnZlcnRVaW50OEFycmF5VG9CYXNlNjQiLCJhcnJheSIsImkiLCJsZW5ndGgiLCJTdHJpbmciLCJmcm9tQ29kZVBvaW50Iiwid2l0aG91dFRyYWlsaW5nU2xhc2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/provider/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AISDKError: () => (/* binding */ AISDKError),\n/* harmony export */   APICallError: () => (/* binding */ APICallError),\n/* harmony export */   EmptyResponseBodyError: () => (/* binding */ EmptyResponseBodyError),\n/* harmony export */   InvalidArgumentError: () => (/* binding */ InvalidArgumentError),\n/* harmony export */   InvalidPromptError: () => (/* binding */ InvalidPromptError),\n/* harmony export */   InvalidResponseDataError: () => (/* binding */ InvalidResponseDataError),\n/* harmony export */   JSONParseError: () => (/* binding */ JSONParseError),\n/* harmony export */   LoadAPIKeyError: () => (/* binding */ LoadAPIKeyError),\n/* harmony export */   LoadSettingError: () => (/* binding */ LoadSettingError),\n/* harmony export */   NoContentGeneratedError: () => (/* binding */ NoContentGeneratedError),\n/* harmony export */   NoSuchModelError: () => (/* binding */ NoSuchModelError),\n/* harmony export */   TooManyEmbeddingValuesForCallError: () => (/* binding */ TooManyEmbeddingValuesForCallError),\n/* harmony export */   TypeValidationError: () => (/* binding */ TypeValidationError),\n/* harmony export */   UnsupportedFunctionalityError: () => (/* binding */ UnsupportedFunctionalityError),\n/* harmony export */   getErrorMessage: () => (/* binding */ getErrorMessage),\n/* harmony export */   isJSONArray: () => (/* binding */ isJSONArray),\n/* harmony export */   isJSONObject: () => (/* binding */ isJSONObject),\n/* harmony export */   isJSONValue: () => (/* binding */ isJSONValue)\n/* harmony export */ });\n// src/errors/ai-sdk-error.ts\nvar marker = \"vercel.ai.error\";\nvar symbol = Symbol.for(marker);\nvar _a;\nvar _AISDKError = class _AISDKError extends Error {\n    /**\n   * Creates an AI SDK Error.\n   *\n   * @param {Object} params - The parameters for creating the error.\n   * @param {string} params.name - The name of the error.\n   * @param {string} params.message - The error message.\n   * @param {unknown} [params.cause] - The underlying cause of the error.\n   */ constructor({ name: name14, message, cause }){\n        super(message);\n        this[_a] = true;\n        this.name = name14;\n        this.cause = cause;\n    }\n    /**\n   * Checks if the given error is an AI SDK Error.\n   * @param {unknown} error - The error to check.\n   * @returns {boolean} True if the error is an AI SDK Error, false otherwise.\n   */ static isInstance(error) {\n        return _AISDKError.hasMarker(error, marker);\n    }\n    static hasMarker(error, marker15) {\n        const markerSymbol = Symbol.for(marker15);\n        return error != null && typeof error === \"object\" && markerSymbol in error && typeof error[markerSymbol] === \"boolean\" && error[markerSymbol] === true;\n    }\n    /**\n   * Returns a JSON representation of the error.\n   * @returns {Object} An object containing the error's name, message, and cause.\n   *\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message\n        };\n    }\n};\n_a = symbol;\nvar AISDKError = _AISDKError;\n// src/errors/api-call-error.ts\nvar name = \"AI_APICallError\";\nvar marker2 = `vercel.ai.error.${name}`;\nvar symbol2 = Symbol.for(marker2);\nvar _a2;\nvar APICallError = class extends AISDKError {\n    constructor({ message, url, requestBodyValues, statusCode, responseHeaders, responseBody, cause, isRetryable = statusCode != null && (statusCode === 408 || // request timeout\n    statusCode === 409 || // conflict\n    statusCode === 429 || // too many requests\n    statusCode >= 500), // server error\n    data }){\n        super({\n            name,\n            message,\n            cause\n        });\n        this[_a2] = true;\n        this.url = url;\n        this.requestBodyValues = requestBodyValues;\n        this.statusCode = statusCode;\n        this.responseHeaders = responseHeaders;\n        this.responseBody = responseBody;\n        this.isRetryable = isRetryable;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker2);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isAPICallError(error) {\n        return error instanceof Error && error.name === name && typeof error.url === \"string\" && typeof error.requestBodyValues === \"object\" && (error.statusCode == null || typeof error.statusCode === \"number\") && (error.responseHeaders == null || typeof error.responseHeaders === \"object\") && (error.responseBody == null || typeof error.responseBody === \"string\") && (error.cause == null || typeof error.cause === \"object\") && typeof error.isRetryable === \"boolean\" && (error.data == null || typeof error.data === \"object\");\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            url: this.url,\n            requestBodyValues: this.requestBodyValues,\n            statusCode: this.statusCode,\n            responseHeaders: this.responseHeaders,\n            responseBody: this.responseBody,\n            cause: this.cause,\n            isRetryable: this.isRetryable,\n            data: this.data\n        };\n    }\n};\n_a2 = symbol2;\n// src/errors/empty-response-body-error.ts\nvar name2 = \"AI_EmptyResponseBodyError\";\nvar marker3 = `vercel.ai.error.${name2}`;\nvar symbol3 = Symbol.for(marker3);\nvar _a3;\nvar EmptyResponseBodyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"Empty response body\" } = {}){\n        super({\n            name: name2,\n            message\n        });\n        this[_a3] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker3);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isEmptyResponseBodyError(error) {\n        return error instanceof Error && error.name === name2;\n    }\n};\n_a3 = symbol3;\n// src/errors/get-error-message.ts\nfunction getErrorMessage(error) {\n    if (error == null) {\n        return \"unknown error\";\n    }\n    if (typeof error === \"string\") {\n        return error;\n    }\n    if (error instanceof Error) {\n        return error.message;\n    }\n    return JSON.stringify(error);\n}\n// src/errors/invalid-argument-error.ts\nvar name3 = \"AI_InvalidArgumentError\";\nvar marker4 = `vercel.ai.error.${name3}`;\nvar symbol4 = Symbol.for(marker4);\nvar _a4;\nvar InvalidArgumentError = class extends AISDKError {\n    constructor({ message, cause, argument }){\n        super({\n            name: name3,\n            message,\n            cause\n        });\n        this[_a4] = true;\n        this.argument = argument;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker4);\n    }\n};\n_a4 = symbol4;\n// src/errors/invalid-prompt-error.ts\nvar name4 = \"AI_InvalidPromptError\";\nvar marker5 = `vercel.ai.error.${name4}`;\nvar symbol5 = Symbol.for(marker5);\nvar _a5;\nvar InvalidPromptError = class extends AISDKError {\n    constructor({ prompt: prompt2, message, cause }){\n        super({\n            name: name4,\n            message: `Invalid prompt: ${message}`,\n            cause\n        });\n        this[_a5] = true;\n        this.prompt = prompt2;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker5);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidPromptError(error) {\n        return error instanceof Error && error.name === name4 && prompt != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            prompt: this.prompt\n        };\n    }\n};\n_a5 = symbol5;\n// src/errors/invalid-response-data-error.ts\nvar name5 = \"AI_InvalidResponseDataError\";\nvar marker6 = `vercel.ai.error.${name5}`;\nvar symbol6 = Symbol.for(marker6);\nvar _a6;\nvar InvalidResponseDataError = class extends AISDKError {\n    constructor({ data, message = `Invalid response data: ${JSON.stringify(data)}.` }){\n        super({\n            name: name5,\n            message\n        });\n        this[_a6] = true;\n        this.data = data;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker6);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isInvalidResponseDataError(error) {\n        return error instanceof Error && error.name === name5 && error.data != null;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            data: this.data\n        };\n    }\n};\n_a6 = symbol6;\n// src/errors/json-parse-error.ts\nvar name6 = \"AI_JSONParseError\";\nvar marker7 = `vercel.ai.error.${name6}`;\nvar symbol7 = Symbol.for(marker7);\nvar _a7;\nvar JSONParseError = class extends AISDKError {\n    constructor({ text, cause }){\n        super({\n            name: name6,\n            message: `JSON parsing failed: Text: ${text}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a7] = true;\n        this.text = text;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker7);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isJSONParseError(error) {\n        return error instanceof Error && error.name === name6 && \"text\" in error && typeof error.text === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            valueText: this.text\n        };\n    }\n};\n_a7 = symbol7;\n// src/errors/load-api-key-error.ts\nvar name7 = \"AI_LoadAPIKeyError\";\nvar marker8 = `vercel.ai.error.${name7}`;\nvar symbol8 = Symbol.for(marker8);\nvar _a8;\nvar LoadAPIKeyError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name7,\n            message\n        });\n        this[_a8] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker8);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isLoadAPIKeyError(error) {\n        return error instanceof Error && error.name === name7;\n    }\n};\n_a8 = symbol8;\n// src/errors/load-setting-error.ts\nvar name8 = \"AI_LoadSettingError\";\nvar marker9 = `vercel.ai.error.${name8}`;\nvar symbol9 = Symbol.for(marker9);\nvar _a9;\nvar LoadSettingError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message }){\n        super({\n            name: name8,\n            message\n        });\n        this[_a9] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker9);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isLoadSettingError(error) {\n        return error instanceof Error && error.name === name8;\n    }\n};\n_a9 = symbol9;\n// src/errors/no-content-generated-error.ts\nvar name9 = \"AI_NoContentGeneratedError\";\nvar marker10 = `vercel.ai.error.${name9}`;\nvar symbol10 = Symbol.for(marker10);\nvar _a10;\nvar NoContentGeneratedError = class extends AISDKError {\n    // used in isInstance\n    constructor({ message = \"No content generated.\" } = {}){\n        super({\n            name: name9,\n            message\n        });\n        this[_a10] = true;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker10);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isNoContentGeneratedError(error) {\n        return error instanceof Error && error.name === name9;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            cause: this.cause,\n            message: this.message,\n            stack: this.stack\n        };\n    }\n};\n_a10 = symbol10;\n// src/errors/no-such-model-error.ts\nvar name10 = \"AI_NoSuchModelError\";\nvar marker11 = `vercel.ai.error.${name10}`;\nvar symbol11 = Symbol.for(marker11);\nvar _a11;\nvar NoSuchModelError = class extends AISDKError {\n    constructor({ errorName = name10, modelId, modelType, message = `No such ${modelType}: ${modelId}` }){\n        super({\n            name: errorName,\n            message\n        });\n        this[_a11] = true;\n        this.modelId = modelId;\n        this.modelType = modelType;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker11);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isNoSuchModelError(error) {\n        return error instanceof Error && error.name === name10 && typeof error.modelId === \"string\" && typeof error.modelType === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            modelId: this.modelId,\n            modelType: this.modelType\n        };\n    }\n};\n_a11 = symbol11;\n// src/errors/too-many-embedding-values-for-call-error.ts\nvar name11 = \"AI_TooManyEmbeddingValuesForCallError\";\nvar marker12 = `vercel.ai.error.${name11}`;\nvar symbol12 = Symbol.for(marker12);\nvar _a12;\nvar TooManyEmbeddingValuesForCallError = class extends AISDKError {\n    constructor(options){\n        super({\n            name: name11,\n            message: `Too many values for a single embedding call. The ${options.provider} model \"${options.modelId}\" can only embed up to ${options.maxEmbeddingsPerCall} values per call, but ${options.values.length} values were provided.`\n        });\n        this[_a12] = true;\n        this.provider = options.provider;\n        this.modelId = options.modelId;\n        this.maxEmbeddingsPerCall = options.maxEmbeddingsPerCall;\n        this.values = options.values;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker12);\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isTooManyEmbeddingValuesForCallError(error) {\n        return error instanceof Error && error.name === name11 && \"provider\" in error && typeof error.provider === \"string\" && \"modelId\" in error && typeof error.modelId === \"string\" && \"maxEmbeddingsPerCall\" in error && typeof error.maxEmbeddingsPerCall === \"number\" && \"values\" in error && Array.isArray(error.values);\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            provider: this.provider,\n            modelId: this.modelId,\n            maxEmbeddingsPerCall: this.maxEmbeddingsPerCall,\n            values: this.values\n        };\n    }\n};\n_a12 = symbol12;\n// src/errors/type-validation-error.ts\nvar name12 = \"AI_TypeValidationError\";\nvar marker13 = `vercel.ai.error.${name12}`;\nvar symbol13 = Symbol.for(marker13);\nvar _a13;\nvar _TypeValidationError = class _TypeValidationError extends AISDKError {\n    constructor({ value, cause }){\n        super({\n            name: name12,\n            message: `Type validation failed: Value: ${JSON.stringify(value)}.\nError message: ${getErrorMessage(cause)}`,\n            cause\n        });\n        this[_a13] = true;\n        this.value = value;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker13);\n    }\n    /**\n   * Wraps an error into a TypeValidationError.\n   * If the cause is already a TypeValidationError with the same value, it returns the cause.\n   * Otherwise, it creates a new TypeValidationError.\n   *\n   * @param {Object} params - The parameters for wrapping the error.\n   * @param {unknown} params.value - The value that failed validation.\n   * @param {unknown} params.cause - The original error or cause of the validation failure.\n   * @returns {TypeValidationError} A TypeValidationError instance.\n   */ static wrap({ value, cause }) {\n        return _TypeValidationError.isInstance(cause) && cause.value === value ? cause : new _TypeValidationError({\n            value,\n            cause\n        });\n    }\n    /**\n   * @deprecated use `isInstance` instead\n   */ static isTypeValidationError(error) {\n        return error instanceof Error && error.name === name12;\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            cause: this.cause,\n            stack: this.stack,\n            value: this.value\n        };\n    }\n};\n_a13 = symbol13;\nvar TypeValidationError = _TypeValidationError;\n// src/errors/unsupported-functionality-error.ts\nvar name13 = \"AI_UnsupportedFunctionalityError\";\nvar marker14 = `vercel.ai.error.${name13}`;\nvar symbol14 = Symbol.for(marker14);\nvar _a14;\nvar UnsupportedFunctionalityError = class extends AISDKError {\n    constructor({ functionality }){\n        super({\n            name: name13,\n            message: `'${functionality}' functionality not supported.`\n        });\n        this[_a14] = true;\n        this.functionality = functionality;\n    }\n    static isInstance(error) {\n        return AISDKError.hasMarker(error, marker14);\n    }\n    /**\n   * @deprecated Use isInstance instead.\n   */ static isUnsupportedFunctionalityError(error) {\n        return error instanceof Error && error.name === name13 && typeof error.functionality === \"string\";\n    }\n    /**\n   * @deprecated Do not use this method. It will be removed in the next major version.\n   */ toJSON() {\n        return {\n            name: this.name,\n            message: this.message,\n            stack: this.stack,\n            functionality: this.functionality\n        };\n    }\n};\n_a14 = symbol14;\n// src/json-value/is-json.ts\nfunction isJSONValue(value) {\n    if (value === null || typeof value === \"string\" || typeof value === \"number\" || typeof value === \"boolean\") {\n        return true;\n    }\n    if (Array.isArray(value)) {\n        return value.every(isJSONValue);\n    }\n    if (typeof value === \"object\") {\n        return Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n    }\n    return false;\n}\nfunction isJSONArray(value) {\n    return Array.isArray(value) && value.every(isJSONValue);\n}\nfunction isJSONObject(value) {\n    return value != null && typeof value === \"object\" && Object.entries(value).every(([key, val])=>typeof key === \"string\" && isJSONValue(val));\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSw2QkFBNkI7QUFDN0IsSUFBSUEsU0FBUztBQUNiLElBQUlDLFNBQVNDLE9BQU9DLEdBQUcsQ0FBQ0g7QUFDeEIsSUFBSUk7QUFDSixJQUFJQyxjQUFjLE1BQU1BLG9CQUFvQkM7SUFDMUM7Ozs7Ozs7R0FPQyxHQUNEQyxZQUFZLEVBQ1ZDLE1BQU1DLE1BQU0sRUFDWkMsT0FBTyxFQUNQQyxLQUFLLEVBQ04sQ0FBRTtRQUNELEtBQUssQ0FBQ0Q7UUFDTixJQUFJLENBQUNOLEdBQUcsR0FBRztRQUNYLElBQUksQ0FBQ0ksSUFBSSxHQUFHQztRQUNaLElBQUksQ0FBQ0UsS0FBSyxHQUFHQTtJQUNmO0lBQ0E7Ozs7R0FJQyxHQUNELE9BQU9DLFdBQVdDLEtBQUssRUFBRTtRQUN2QixPQUFPUixZQUFZUyxTQUFTLENBQUNELE9BQU9iO0lBQ3RDO0lBQ0EsT0FBT2MsVUFBVUQsS0FBSyxFQUFFRSxRQUFRLEVBQUU7UUFDaEMsTUFBTUMsZUFBZWQsT0FBT0MsR0FBRyxDQUFDWTtRQUNoQyxPQUFPRixTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZRyxnQkFBZ0JILFNBQVMsT0FBT0EsS0FBSyxDQUFDRyxhQUFhLEtBQUssYUFBYUgsS0FBSyxDQUFDRyxhQUFhLEtBQUs7SUFDcEo7SUFDQTs7Ozs7R0FLQyxHQUNEQyxTQUFTO1FBQ1AsT0FBTztZQUNMVCxNQUFNLElBQUksQ0FBQ0EsSUFBSTtZQUNmRSxTQUFTLElBQUksQ0FBQ0EsT0FBTztRQUN2QjtJQUNGO0FBQ0Y7QUFDQU4sS0FBS0g7QUFDTCxJQUFJaUIsYUFBYWI7QUFFakIsK0JBQStCO0FBQy9CLElBQUlHLE9BQU87QUFDWCxJQUFJVyxVQUFVLENBQUMsZ0JBQWdCLEVBQUVYLEtBQUssQ0FBQztBQUN2QyxJQUFJWSxVQUFVbEIsT0FBT0MsR0FBRyxDQUFD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SUFBSVAsTUFBTUMsT0FBTyxDQUFDTSxRQUFRO1FBQ3hCLE9BQU9BLE1BQU1ZLEtBQUssQ0FBQ0Q7SUFDckI7SUFDQSxJQUFJLE9BQU9YLFVBQVUsVUFBVTtRQUM3QixPQUFPYSxPQUFPQyxPQUFPLENBQUNkLE9BQU9ZLEtBQUssQ0FDaEMsQ0FBQyxDQUFDRyxLQUFLQyxJQUFJLEdBQUssT0FBT0QsUUFBUSxZQUFZSixZQUFZSztJQUUzRDtJQUNBLE9BQU87QUFDVDtBQUNBLFNBQVNDLFlBQVlqQixLQUFLO0lBQ3hCLE9BQU9QLE1BQU1DLE9BQU8sQ0FBQ00sVUFBVUEsTUFBTVksS0FBSyxDQUFDRDtBQUM3QztBQUNBLFNBQVNPLGFBQWFsQixLQUFLO0lBQ3pCLE9BQU9BLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVlhLE9BQU9DLE9BQU8sQ0FBQ2QsT0FBT1ksS0FBSyxDQUM5RSxDQUFDLENBQUNHLEtBQUtDLElBQUksR0FBSyxPQUFPRCxRQUFRLFlBQVlKLFlBQVlLO0FBRTNEO0FBb0JFLENBQ0Ysa0NBQWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vbmV4dGpzLWZpcnN0X2NoYXRib3QvLi9ub2RlX21vZHVsZXMvQGFpLXNkay9wcm92aWRlci9kaXN0L2luZGV4Lm1qcz81ZmIxIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIHNyYy9lcnJvcnMvYWktc2RrLWVycm9yLnRzXG52YXIgbWFya2VyID0gXCJ2ZXJjZWwuYWkuZXJyb3JcIjtcbnZhciBzeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcik7XG52YXIgX2E7XG52YXIgX0FJU0RLRXJyb3IgPSBjbGFzcyBfQUlTREtFcnJvciBleHRlbmRzIEVycm9yIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gcGFyYW1zIC0gVGhlIHBhcmFtZXRlcnMgZm9yIGNyZWF0aW5nIHRoZSBlcnJvci5cbiAgICogQHBhcmFtIHtzdHJpbmd9IHBhcmFtcy5uYW1lIC0gVGhlIG5hbWUgb2YgdGhlIGVycm9yLlxuICAgKiBAcGFyYW0ge3N0cmluZ30gcGFyYW1zLm1lc3NhZ2UgLSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAgICogQHBhcmFtIHt1bmtub3dufSBbcGFyYW1zLmNhdXNlXSAtIFRoZSB1bmRlcmx5aW5nIGNhdXNlIG9mIHRoZSBlcnJvci5cbiAgICovXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBuYW1lOiBuYW1lMTQsXG4gICAgbWVzc2FnZSxcbiAgICBjYXVzZVxuICB9KSB7XG4gICAgc3VwZXIobWVzc2FnZSk7XG4gICAgdGhpc1tfYV0gPSB0cnVlO1xuICAgIHRoaXMubmFtZSA9IG5hbWUxNDtcbiAgICB0aGlzLmNhdXNlID0gY2F1c2U7XG4gIH1cbiAgLyoqXG4gICAqIENoZWNrcyBpZiB0aGUgZ2l2ZW4gZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLlxuICAgKiBAcGFyYW0ge3Vua25vd259IGVycm9yIC0gVGhlIGVycm9yIHRvIGNoZWNrLlxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgZXJyb3IgaXMgYW4gQUkgU0RLIEVycm9yLCBmYWxzZSBvdGhlcndpc2UuXG4gICAqL1xuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBfQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcik7XG4gIH1cbiAgc3RhdGljIGhhc01hcmtlcihlcnJvciwgbWFya2VyMTUpIHtcbiAgICBjb25zdCBtYXJrZXJTeW1ib2wgPSBTeW1ib2wuZm9yKG1hcmtlcjE1KTtcbiAgICByZXR1cm4gZXJyb3IgIT0gbnVsbCAmJiB0eXBlb2YgZXJyb3IgPT09IFwib2JqZWN0XCIgJiYgbWFya2VyU3ltYm9sIGluIGVycm9yICYmIHR5cGVvZiBlcnJvclttYXJrZXJTeW1ib2xdID09PSBcImJvb2xlYW5cIiAmJiBlcnJvclttYXJrZXJTeW1ib2xdID09PSB0cnVlO1xuICB9XG4gIC8qKlxuICAgKiBSZXR1cm5zIGEgSlNPTiByZXByZXNlbnRhdGlvbiBvZiB0aGUgZXJyb3IuXG4gICAqIEByZXR1cm5zIHtPYmplY3R9IEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBlcnJvcidzIG5hbWUsIG1lc3NhZ2UsIGFuZCBjYXVzZS5cbiAgICpcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZVxuICAgIH07XG4gIH1cbn07XG5fYSA9IHN5bWJvbDtcbnZhciBBSVNES0Vycm9yID0gX0FJU0RLRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvYXBpLWNhbGwtZXJyb3IudHNcbnZhciBuYW1lID0gXCJBSV9BUElDYWxsRXJyb3JcIjtcbnZhciBtYXJrZXIyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWV9YDtcbnZhciBzeW1ib2wyID0gU3ltYm9sLmZvcihtYXJrZXIyKTtcbnZhciBfYTI7XG52YXIgQVBJQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIG1lc3NhZ2UsXG4gICAgdXJsLFxuICAgIHJlcXVlc3RCb2R5VmFsdWVzLFxuICAgIHN0YXR1c0NvZGUsXG4gICAgcmVzcG9uc2VIZWFkZXJzLFxuICAgIHJlc3BvbnNlQm9keSxcbiAgICBjYXVzZSxcbiAgICBpc1JldHJ5YWJsZSA9IHN0YXR1c0NvZGUgIT0gbnVsbCAmJiAoc3RhdHVzQ29kZSA9PT0gNDA4IHx8IC8vIHJlcXVlc3QgdGltZW91dFxuICAgIHN0YXR1c0NvZGUgPT09IDQwOSB8fCAvLyBjb25mbGljdFxuICAgIHN0YXR1c0NvZGUgPT09IDQyOSB8fCAvLyB0b28gbWFueSByZXF1ZXN0c1xuICAgIHN0YXR1c0NvZGUgPj0gNTAwKSxcbiAgICAvLyBzZXJ2ZXIgZXJyb3JcbiAgICBkYXRhXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWUsIG1lc3NhZ2UsIGNhdXNlIH0pO1xuICAgIHRoaXNbX2EyXSA9IHRydWU7XG4gICAgdGhpcy51cmwgPSB1cmw7XG4gICAgdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyA9IHJlcXVlc3RCb2R5VmFsdWVzO1xuICAgIHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgdGhpcy5yZXNwb25zZUhlYWRlcnMgPSByZXNwb25zZUhlYWRlcnM7XG4gICAgdGhpcy5yZXNwb25zZUJvZHkgPSByZXNwb25zZUJvZHk7XG4gICAgdGhpcy5pc1JldHJ5YWJsZSA9IGlzUmV0cnlhYmxlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzQVBJQ2FsbEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZSAmJiB0eXBlb2YgZXJyb3IudXJsID09PSBcInN0cmluZ1wiICYmIHR5cGVvZiBlcnJvci5yZXF1ZXN0Qm9keVZhbHVlcyA9PT0gXCJvYmplY3RcIiAmJiAoZXJyb3Iuc3RhdHVzQ29kZSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5zdGF0dXNDb2RlID09PSBcIm51bWJlclwiKSAmJiAoZXJyb3IucmVzcG9uc2VIZWFkZXJzID09IG51bGwgfHwgdHlwZW9mIGVycm9yLnJlc3BvbnNlSGVhZGVycyA9PT0gXCJvYmplY3RcIikgJiYgKGVycm9yLnJlc3BvbnNlQm9keSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5yZXNwb25zZUJvZHkgPT09IFwic3RyaW5nXCIpICYmIChlcnJvci5jYXVzZSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5jYXVzZSA9PT0gXCJvYmplY3RcIikgJiYgdHlwZW9mIGVycm9yLmlzUmV0cnlhYmxlID09PSBcImJvb2xlYW5cIiAmJiAoZXJyb3IuZGF0YSA9PSBudWxsIHx8IHR5cGVvZiBlcnJvci5kYXRhID09PSBcIm9iamVjdFwiKTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHVybDogdGhpcy51cmwsXG4gICAgICByZXF1ZXN0Qm9keVZhbHVlczogdGhpcy5yZXF1ZXN0Qm9keVZhbHVlcyxcbiAgICAgIHN0YXR1c0NvZGU6IHRoaXMuc3RhdHVzQ29kZSxcbiAgICAgIHJlc3BvbnNlSGVhZGVyczogdGhpcy5yZXNwb25zZUhlYWRlcnMsXG4gICAgICByZXNwb25zZUJvZHk6IHRoaXMucmVzcG9uc2VCb2R5LFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBpc1JldHJ5YWJsZTogdGhpcy5pc1JldHJ5YWJsZSxcbiAgICAgIGRhdGE6IHRoaXMuZGF0YVxuICAgIH07XG4gIH1cbn07XG5fYTIgPSBzeW1ib2wyO1xuXG4vLyBzcmMvZXJyb3JzL2VtcHR5LXJlc3BvbnNlLWJvZHktZXJyb3IudHNcbnZhciBuYW1lMiA9IFwiQUlfRW1wdHlSZXNwb25zZUJvZHlFcnJvclwiO1xudmFyIG1hcmtlcjMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTJ9YDtcbnZhciBzeW1ib2wzID0gU3ltYm9sLmZvcihtYXJrZXIzKTtcbnZhciBfYTM7XG52YXIgRW1wdHlSZXNwb25zZUJvZHlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgPSBcIkVtcHR5IHJlc3BvbnNlIGJvZHlcIiB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUyLCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2EzXSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0VtcHR5UmVzcG9uc2VCb2R5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMjtcbiAgfVxufTtcbl9hMyA9IHN5bWJvbDM7XG5cbi8vIHNyYy9lcnJvcnMvZ2V0LWVycm9yLW1lc3NhZ2UudHNcbmZ1bmN0aW9uIGdldEVycm9yTWVzc2FnZShlcnJvcikge1xuICBpZiAoZXJyb3IgPT0gbnVsbCkge1xuICAgIHJldHVybiBcInVua25vd24gZXJyb3JcIjtcbiAgfVxuICBpZiAodHlwZW9mIGVycm9yID09PSBcInN0cmluZ1wiKSB7XG4gICAgcmV0dXJuIGVycm9yO1xuICB9XG4gIGlmIChlcnJvciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yLm1lc3NhZ2U7XG4gIH1cbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGVycm9yKTtcbn1cblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLWFyZ3VtZW50LWVycm9yLnRzXG52YXIgbmFtZTMgPSBcIkFJX0ludmFsaWRBcmd1bWVudEVycm9yXCI7XG52YXIgbWFya2VyNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lM31gO1xudmFyIHN5bWJvbDQgPSBTeW1ib2wuZm9yKG1hcmtlcjQpO1xudmFyIF9hNDtcbnZhciBJbnZhbGlkQXJndW1lbnRFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlLFxuICAgIGFyZ3VtZW50XG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWUzLCBtZXNzYWdlLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNF0gPSB0cnVlO1xuICAgIHRoaXMuYXJndW1lbnQgPSBhcmd1bWVudDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNCk7XG4gIH1cbn07XG5fYTQgPSBzeW1ib2w0O1xuXG4vLyBzcmMvZXJyb3JzL2ludmFsaWQtcHJvbXB0LWVycm9yLnRzXG52YXIgbmFtZTQgPSBcIkFJX0ludmFsaWRQcm9tcHRFcnJvclwiO1xudmFyIG1hcmtlcjUgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTR9YDtcbnZhciBzeW1ib2w1ID0gU3ltYm9sLmZvcihtYXJrZXI1KTtcbnZhciBfYTU7XG52YXIgSW52YWxpZFByb21wdEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIHByb21wdDogcHJvbXB0MixcbiAgICBtZXNzYWdlLFxuICAgIGNhdXNlXG4gIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU0LCBtZXNzYWdlOiBgSW52YWxpZCBwcm9tcHQ6ICR7bWVzc2FnZX1gLCBjYXVzZSB9KTtcbiAgICB0aGlzW19hNV0gPSB0cnVlO1xuICAgIHRoaXMucHJvbXB0ID0gcHJvbXB0MjtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNSk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSW52YWxpZFByb21wdEVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTQgJiYgcHJvbXB0ICE9IG51bGw7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIERvIG5vdCB1c2UgdGhpcyBtZXRob2QuIEl0IHdpbGwgYmUgcmVtb3ZlZCBpbiB0aGUgbmV4dCBtYWpvciB2ZXJzaW9uLlxuICAgKi9cbiAgdG9KU09OKCkge1xuICAgIHJldHVybiB7XG4gICAgICBuYW1lOiB0aGlzLm5hbWUsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHByb21wdDogdGhpcy5wcm9tcHRcbiAgICB9O1xuICB9XG59O1xuX2E1ID0gc3ltYm9sNTtcblxuLy8gc3JjL2Vycm9ycy9pbnZhbGlkLXJlc3BvbnNlLWRhdGEtZXJyb3IudHNcbnZhciBuYW1lNSA9IFwiQUlfSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yXCI7XG52YXIgbWFya2VyNiA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lNX1gO1xudmFyIHN5bWJvbDYgPSBTeW1ib2wuZm9yKG1hcmtlcjYpO1xudmFyIF9hNjtcbnZhciBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgZGF0YSxcbiAgICBtZXNzYWdlID0gYEludmFsaWQgcmVzcG9uc2UgZGF0YTogJHtKU09OLnN0cmluZ2lmeShkYXRhKX0uYFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBuYW1lNSwgbWVzc2FnZSB9KTtcbiAgICB0aGlzW19hNl0gPSB0cnVlO1xuICAgIHRoaXMuZGF0YSA9IGRhdGE7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjYpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc0ludmFsaWRSZXNwb25zZURhdGFFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU1ICYmIGVycm9yLmRhdGEgIT0gbnVsbDtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZGF0YTogdGhpcy5kYXRhXG4gICAgfTtcbiAgfVxufTtcbl9hNiA9IHN5bWJvbDY7XG5cbi8vIHNyYy9lcnJvcnMvanNvbi1wYXJzZS1lcnJvci50c1xudmFyIG5hbWU2ID0gXCJBSV9KU09OUGFyc2VFcnJvclwiO1xudmFyIG1hcmtlcjcgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTZ9YDtcbnZhciBzeW1ib2w3ID0gU3ltYm9sLmZvcihtYXJrZXI3KTtcbnZhciBfYTc7XG52YXIgSlNPTlBhcnNlRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IHRleHQsIGNhdXNlIH0pIHtcbiAgICBzdXBlcih7XG4gICAgICBuYW1lOiBuYW1lNixcbiAgICAgIG1lc3NhZ2U6IGBKU09OIHBhcnNpbmcgZmFpbGVkOiBUZXh0OiAke3RleHR9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2E3XSA9IHRydWU7XG4gICAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyNyk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIHVzZSBgaXNJbnN0YW5jZWAgaW5zdGVhZFxuICAgKi9cbiAgc3RhdGljIGlzSlNPTlBhcnNlRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNiAmJiBcInRleHRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IudGV4dCA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIGNhdXNlOiB0aGlzLmNhdXNlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICB2YWx1ZVRleHQ6IHRoaXMudGV4dFxuICAgIH07XG4gIH1cbn07XG5fYTcgPSBzeW1ib2w3O1xuXG4vLyBzcmMvZXJyb3JzL2xvYWQtYXBpLWtleS1lcnJvci50c1xudmFyIG5hbWU3ID0gXCJBSV9Mb2FkQVBJS2V5RXJyb3JcIjtcbnZhciBtYXJrZXI4ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU3fWA7XG52YXIgc3ltYm9sOCA9IFN5bWJvbC5mb3IobWFya2VyOCk7XG52YXIgX2E4O1xudmFyIExvYWRBUElLZXlFcnJvciA9IGNsYXNzIGV4dGVuZHMgQUlTREtFcnJvciB7XG4gIC8vIHVzZWQgaW4gaXNJbnN0YW5jZVxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfSkge1xuICAgIHN1cGVyKHsgbmFtZTogbmFtZTcsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYThdID0gdHJ1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyOCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNMb2FkQVBJS2V5RXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lNztcbiAgfVxufTtcbl9hOCA9IHN5bWJvbDg7XG5cbi8vIHNyYy9lcnJvcnMvbG9hZC1zZXR0aW5nLWVycm9yLnRzXG52YXIgbmFtZTggPSBcIkFJX0xvYWRTZXR0aW5nRXJyb3JcIjtcbnZhciBtYXJrZXI5ID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU4fWA7XG52YXIgc3ltYm9sOSA9IFN5bWJvbC5mb3IobWFya2VyOSk7XG52YXIgX2E5O1xudmFyIExvYWRTZXR0aW5nRXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICAvLyB1c2VkIGluIGlzSW5zdGFuY2VcbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlIH0pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU4LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2E5XSA9IHRydWU7XG4gIH1cbiAgc3RhdGljIGlzSW5zdGFuY2UoZXJyb3IpIHtcbiAgICByZXR1cm4gQUlTREtFcnJvci5oYXNNYXJrZXIoZXJyb3IsIG1hcmtlcjkpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBVc2UgaXNJbnN0YW5jZSBpbnN0ZWFkLlxuICAgKi9cbiAgc3RhdGljIGlzTG9hZFNldHRpbmdFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU4O1xuICB9XG59O1xuX2E5ID0gc3ltYm9sOTtcblxuLy8gc3JjL2Vycm9ycy9uby1jb250ZW50LWdlbmVyYXRlZC1lcnJvci50c1xudmFyIG5hbWU5ID0gXCJBSV9Ob0NvbnRlbnRHZW5lcmF0ZWRFcnJvclwiO1xudmFyIG1hcmtlcjEwID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWU5fWA7XG52YXIgc3ltYm9sMTAgPSBTeW1ib2wuZm9yKG1hcmtlcjEwKTtcbnZhciBfYTEwO1xudmFyIE5vQ29udGVudEdlbmVyYXRlZEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgLy8gdXNlZCBpbiBpc0luc3RhbmNlXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBtZXNzYWdlID0gXCJObyBjb250ZW50IGdlbmVyYXRlZC5cIlxuICB9ID0ge30pIHtcbiAgICBzdXBlcih7IG5hbWU6IG5hbWU5LCBtZXNzYWdlIH0pO1xuICAgIHRoaXNbX2ExMF0gPSB0cnVlO1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxMCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWU5O1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFja1xuICAgIH07XG4gIH1cbn07XG5fYTEwID0gc3ltYm9sMTA7XG5cbi8vIHNyYy9lcnJvcnMvbm8tc3VjaC1tb2RlbC1lcnJvci50c1xudmFyIG5hbWUxMCA9IFwiQUlfTm9TdWNoTW9kZWxFcnJvclwiO1xudmFyIG1hcmtlcjExID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMH1gO1xudmFyIHN5bWJvbDExID0gU3ltYm9sLmZvcihtYXJrZXIxMSk7XG52YXIgX2ExMTtcbnZhciBOb1N1Y2hNb2RlbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Ioe1xuICAgIGVycm9yTmFtZSA9IG5hbWUxMCxcbiAgICBtb2RlbElkLFxuICAgIG1vZGVsVHlwZSxcbiAgICBtZXNzYWdlID0gYE5vIHN1Y2ggJHttb2RlbFR5cGV9OiAke21vZGVsSWR9YFxuICB9KSB7XG4gICAgc3VwZXIoeyBuYW1lOiBlcnJvck5hbWUsIG1lc3NhZ2UgfSk7XG4gICAgdGhpc1tfYTExXSA9IHRydWU7XG4gICAgdGhpcy5tb2RlbElkID0gbW9kZWxJZDtcbiAgICB0aGlzLm1vZGVsVHlwZSA9IG1vZGVsVHlwZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTEpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc05vU3VjaE1vZGVsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTAgJiYgdHlwZW9mIGVycm9yLm1vZGVsSWQgPT09IFwic3RyaW5nXCIgJiYgdHlwZW9mIGVycm9yLm1vZGVsVHlwZSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgbW9kZWxJZDogdGhpcy5tb2RlbElkLFxuICAgICAgbW9kZWxUeXBlOiB0aGlzLm1vZGVsVHlwZVxuICAgIH07XG4gIH1cbn07XG5fYTExID0gc3ltYm9sMTE7XG5cbi8vIHNyYy9lcnJvcnMvdG9vLW1hbnktZW1iZWRkaW5nLXZhbHVlcy1mb3ItY2FsbC1lcnJvci50c1xudmFyIG5hbWUxMSA9IFwiQUlfVG9vTWFueUVtYmVkZGluZ1ZhbHVlc0ZvckNhbGxFcnJvclwiO1xudmFyIG1hcmtlcjEyID0gYHZlcmNlbC5haS5lcnJvci4ke25hbWUxMX1gO1xudmFyIHN5bWJvbDEyID0gU3ltYm9sLmZvcihtYXJrZXIxMik7XG52YXIgX2ExMjtcbnZhciBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yID0gY2xhc3MgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMSxcbiAgICAgIG1lc3NhZ2U6IGBUb28gbWFueSB2YWx1ZXMgZm9yIGEgc2luZ2xlIGVtYmVkZGluZyBjYWxsLiBUaGUgJHtvcHRpb25zLnByb3ZpZGVyfSBtb2RlbCBcIiR7b3B0aW9ucy5tb2RlbElkfVwiIGNhbiBvbmx5IGVtYmVkIHVwIHRvICR7b3B0aW9ucy5tYXhFbWJlZGRpbmdzUGVyQ2FsbH0gdmFsdWVzIHBlciBjYWxsLCBidXQgJHtvcHRpb25zLnZhbHVlcy5sZW5ndGh9IHZhbHVlcyB3ZXJlIHByb3ZpZGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTJdID0gdHJ1ZTtcbiAgICB0aGlzLnByb3ZpZGVyID0gb3B0aW9ucy5wcm92aWRlcjtcbiAgICB0aGlzLm1vZGVsSWQgPSBvcHRpb25zLm1vZGVsSWQ7XG4gICAgdGhpcy5tYXhFbWJlZGRpbmdzUGVyQ2FsbCA9IG9wdGlvbnMubWF4RW1iZWRkaW5nc1BlckNhbGw7XG4gICAgdGhpcy52YWx1ZXMgPSBvcHRpb25zLnZhbHVlcztcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTIpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCB1c2UgYGlzSW5zdGFuY2VgIGluc3RlYWRcbiAgICovXG4gIHN0YXRpYyBpc1Rvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IoZXJyb3IpIHtcbiAgICByZXR1cm4gZXJyb3IgaW5zdGFuY2VvZiBFcnJvciAmJiBlcnJvci5uYW1lID09PSBuYW1lMTEgJiYgXCJwcm92aWRlclwiIGluIGVycm9yICYmIHR5cGVvZiBlcnJvci5wcm92aWRlciA9PT0gXCJzdHJpbmdcIiAmJiBcIm1vZGVsSWRcIiBpbiBlcnJvciAmJiB0eXBlb2YgZXJyb3IubW9kZWxJZCA9PT0gXCJzdHJpbmdcIiAmJiBcIm1heEVtYmVkZGluZ3NQZXJDYWxsXCIgaW4gZXJyb3IgJiYgdHlwZW9mIGVycm9yLm1heEVtYmVkZGluZ3NQZXJDYWxsID09PSBcIm51bWJlclwiICYmIFwidmFsdWVzXCIgaW4gZXJyb3IgJiYgQXJyYXkuaXNBcnJheShlcnJvci52YWx1ZXMpO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgc3RhY2s6IHRoaXMuc3RhY2ssXG4gICAgICBwcm92aWRlcjogdGhpcy5wcm92aWRlcixcbiAgICAgIG1vZGVsSWQ6IHRoaXMubW9kZWxJZCxcbiAgICAgIG1heEVtYmVkZGluZ3NQZXJDYWxsOiB0aGlzLm1heEVtYmVkZGluZ3NQZXJDYWxsLFxuICAgICAgdmFsdWVzOiB0aGlzLnZhbHVlc1xuICAgIH07XG4gIH1cbn07XG5fYTEyID0gc3ltYm9sMTI7XG5cbi8vIHNyYy9lcnJvcnMvdHlwZS12YWxpZGF0aW9uLWVycm9yLnRzXG52YXIgbmFtZTEyID0gXCJBSV9UeXBlVmFsaWRhdGlvbkVycm9yXCI7XG52YXIgbWFya2VyMTMgPSBgdmVyY2VsLmFpLmVycm9yLiR7bmFtZTEyfWA7XG52YXIgc3ltYm9sMTMgPSBTeW1ib2wuZm9yKG1hcmtlcjEzKTtcbnZhciBfYTEzO1xudmFyIF9UeXBlVmFsaWRhdGlvbkVycm9yID0gY2xhc3MgX1R5cGVWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBBSVNES0Vycm9yIHtcbiAgY29uc3RydWN0b3IoeyB2YWx1ZSwgY2F1c2UgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMixcbiAgICAgIG1lc3NhZ2U6IGBUeXBlIHZhbGlkYXRpb24gZmFpbGVkOiBWYWx1ZTogJHtKU09OLnN0cmluZ2lmeSh2YWx1ZSl9LlxuRXJyb3IgbWVzc2FnZTogJHtnZXRFcnJvck1lc3NhZ2UoY2F1c2UpfWAsXG4gICAgICBjYXVzZVxuICAgIH0pO1xuICAgIHRoaXNbX2ExM10gPSB0cnVlO1xuICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgfVxuICBzdGF0aWMgaXNJbnN0YW5jZShlcnJvcikge1xuICAgIHJldHVybiBBSVNES0Vycm9yLmhhc01hcmtlcihlcnJvciwgbWFya2VyMTMpO1xuICB9XG4gIC8qKlxuICAgKiBXcmFwcyBhbiBlcnJvciBpbnRvIGEgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICogSWYgdGhlIGNhdXNlIGlzIGFscmVhZHkgYSBUeXBlVmFsaWRhdGlvbkVycm9yIHdpdGggdGhlIHNhbWUgdmFsdWUsIGl0IHJldHVybnMgdGhlIGNhdXNlLlxuICAgKiBPdGhlcndpc2UsIGl0IGNyZWF0ZXMgYSBuZXcgVHlwZVZhbGlkYXRpb25FcnJvci5cbiAgICpcbiAgICogQHBhcmFtIHtPYmplY3R9IHBhcmFtcyAtIFRoZSBwYXJhbWV0ZXJzIGZvciB3cmFwcGluZyB0aGUgZXJyb3IuXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLnZhbHVlIC0gVGhlIHZhbHVlIHRoYXQgZmFpbGVkIHZhbGlkYXRpb24uXG4gICAqIEBwYXJhbSB7dW5rbm93bn0gcGFyYW1zLmNhdXNlIC0gVGhlIG9yaWdpbmFsIGVycm9yIG9yIGNhdXNlIG9mIHRoZSB2YWxpZGF0aW9uIGZhaWx1cmUuXG4gICAqIEByZXR1cm5zIHtUeXBlVmFsaWRhdGlvbkVycm9yfSBBIFR5cGVWYWxpZGF0aW9uRXJyb3IgaW5zdGFuY2UuXG4gICAqL1xuICBzdGF0aWMgd3JhcCh7XG4gICAgdmFsdWUsXG4gICAgY2F1c2VcbiAgfSkge1xuICAgIHJldHVybiBfVHlwZVZhbGlkYXRpb25FcnJvci5pc0luc3RhbmNlKGNhdXNlKSAmJiBjYXVzZS52YWx1ZSA9PT0gdmFsdWUgPyBjYXVzZSA6IG5ldyBfVHlwZVZhbGlkYXRpb25FcnJvcih7IHZhbHVlLCBjYXVzZSB9KTtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgdXNlIGBpc0luc3RhbmNlYCBpbnN0ZWFkXG4gICAqL1xuICBzdGF0aWMgaXNUeXBlVmFsaWRhdGlvbkVycm9yKGVycm9yKSB7XG4gICAgcmV0dXJuIGVycm9yIGluc3RhbmNlb2YgRXJyb3IgJiYgZXJyb3IubmFtZSA9PT0gbmFtZTEyO1xuICB9XG4gIC8qKlxuICAgKiBAZGVwcmVjYXRlZCBEbyBub3QgdXNlIHRoaXMgbWV0aG9kLiBJdCB3aWxsIGJlIHJlbW92ZWQgaW4gdGhlIG5leHQgbWFqb3IgdmVyc2lvbi5cbiAgICovXG4gIHRvSlNPTigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgbWVzc2FnZTogdGhpcy5tZXNzYWdlLFxuICAgICAgY2F1c2U6IHRoaXMuY2F1c2UsXG4gICAgICBzdGFjazogdGhpcy5zdGFjayxcbiAgICAgIHZhbHVlOiB0aGlzLnZhbHVlXG4gICAgfTtcbiAgfVxufTtcbl9hMTMgPSBzeW1ib2wxMztcbnZhciBUeXBlVmFsaWRhdGlvbkVycm9yID0gX1R5cGVWYWxpZGF0aW9uRXJyb3I7XG5cbi8vIHNyYy9lcnJvcnMvdW5zdXBwb3J0ZWQtZnVuY3Rpb25hbGl0eS1lcnJvci50c1xudmFyIG5hbWUxMyA9IFwiQUlfVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3JcIjtcbnZhciBtYXJrZXIxNCA9IGB2ZXJjZWwuYWkuZXJyb3IuJHtuYW1lMTN9YDtcbnZhciBzeW1ib2wxNCA9IFN5bWJvbC5mb3IobWFya2VyMTQpO1xudmFyIF9hMTQ7XG52YXIgVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IgPSBjbGFzcyBleHRlbmRzIEFJU0RLRXJyb3Ige1xuICBjb25zdHJ1Y3Rvcih7IGZ1bmN0aW9uYWxpdHkgfSkge1xuICAgIHN1cGVyKHtcbiAgICAgIG5hbWU6IG5hbWUxMyxcbiAgICAgIG1lc3NhZ2U6IGAnJHtmdW5jdGlvbmFsaXR5fScgZnVuY3Rpb25hbGl0eSBub3Qgc3VwcG9ydGVkLmBcbiAgICB9KTtcbiAgICB0aGlzW19hMTRdID0gdHJ1ZTtcbiAgICB0aGlzLmZ1bmN0aW9uYWxpdHkgPSBmdW5jdGlvbmFsaXR5O1xuICB9XG4gIHN0YXRpYyBpc0luc3RhbmNlKGVycm9yKSB7XG4gICAgcmV0dXJuIEFJU0RLRXJyb3IuaGFzTWFya2VyKGVycm9yLCBtYXJrZXIxNCk7XG4gIH1cbiAgLyoqXG4gICAqIEBkZXByZWNhdGVkIFVzZSBpc0luc3RhbmNlIGluc3RlYWQuXG4gICAqL1xuICBzdGF0aWMgaXNVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcihlcnJvcikge1xuICAgIHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEVycm9yICYmIGVycm9yLm5hbWUgPT09IG5hbWUxMyAmJiB0eXBlb2YgZXJyb3IuZnVuY3Rpb25hbGl0eSA9PT0gXCJzdHJpbmdcIjtcbiAgfVxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgRG8gbm90IHVzZSB0aGlzIG1ldGhvZC4gSXQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZXh0IG1ham9yIHZlcnNpb24uXG4gICAqL1xuICB0b0pTT04oKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5hbWU6IHRoaXMubmFtZSxcbiAgICAgIG1lc3NhZ2U6IHRoaXMubWVzc2FnZSxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxuICAgICAgZnVuY3Rpb25hbGl0eTogdGhpcy5mdW5jdGlvbmFsaXR5XG4gICAgfTtcbiAgfVxufTtcbl9hMTQgPSBzeW1ib2wxNDtcblxuLy8gc3JjL2pzb24tdmFsdWUvaXMtanNvbi50c1xuZnVuY3Rpb24gaXNKU09OVmFsdWUodmFsdWUpIHtcbiAgaWYgKHZhbHVlID09PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSA9PT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUgPT09IFwibnVtYmVyXCIgfHwgdHlwZW9mIHZhbHVlID09PSBcImJvb2xlYW5cIikge1xuICAgIHJldHVybiB0cnVlO1xuICB9XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHJldHVybiB2YWx1ZS5ldmVyeShpc0pTT05WYWx1ZSk7XG4gIH1cbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIikge1xuICAgIHJldHVybiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgICAoW2tleSwgdmFsXSkgPT4gdHlwZW9mIGtleSA9PT0gXCJzdHJpbmdcIiAmJiBpc0pTT05WYWx1ZSh2YWwpXG4gICAgKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBpc0pTT05BcnJheSh2YWx1ZSkge1xuICByZXR1cm4gQXJyYXkuaXNBcnJheSh2YWx1ZSkgJiYgdmFsdWUuZXZlcnkoaXNKU09OVmFsdWUpO1xufVxuZnVuY3Rpb24gaXNKU09OT2JqZWN0KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gXCJvYmplY3RcIiAmJiBPYmplY3QuZW50cmllcyh2YWx1ZSkuZXZlcnkoXG4gICAgKFtrZXksIHZhbF0pID0+IHR5cGVvZiBrZXkgPT09IFwic3RyaW5nXCIgJiYgaXNKU09OVmFsdWUodmFsKVxuICApO1xufVxuZXhwb3J0IHtcbiAgQUlTREtFcnJvcixcbiAgQVBJQ2FsbEVycm9yLFxuICBFbXB0eVJlc3BvbnNlQm9keUVycm9yLFxuICBJbnZhbGlkQXJndW1lbnRFcnJvcixcbiAgSW52YWxpZFByb21wdEVycm9yLFxuICBJbnZhbGlkUmVzcG9uc2VEYXRhRXJyb3IsXG4gIEpTT05QYXJzZUVycm9yLFxuICBMb2FkQVBJS2V5RXJyb3IsXG4gIExvYWRTZXR0aW5nRXJyb3IsXG4gIE5vQ29udGVudEdlbmVyYXRlZEVycm9yLFxuICBOb1N1Y2hNb2RlbEVycm9yLFxuICBUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yLFxuICBUeXBlVmFsaWRhdGlvbkVycm9yLFxuICBVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvcixcbiAgZ2V0RXJyb3JNZXNzYWdlLFxuICBpc0pTT05BcnJheSxcbiAgaXNKU09OT2JqZWN0LFxuICBpc0pTT05WYWx1ZVxufTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4Lm1qcy5tYXAiXSwibmFtZXMiOlsibWFya2VyIiwic3ltYm9sIiwiU3ltYm9sIiwiZm9yIiwiX2EiLCJfQUlTREtFcnJvciIsIkVycm9yIiwiY29uc3RydWN0b3IiLCJuYW1lIiwibmFtZTE0IiwibWVzc2FnZSIsImNhdXNlIiwiaXNJbnN0YW5jZSIsImVycm9yIiwiaGFzTWFya2VyIiwibWFya2VyMTUiLCJtYXJrZXJTeW1ib2wiLCJ0b0pTT04iLCJBSVNES0Vycm9yIiwibWFya2VyMiIsInN5bWJvbDIiLCJfYTIiLCJBUElDYWxsRXJyb3IiLCJ1cmwiLCJyZXF1ZXN0Qm9keVZhbHVlcyIsInN0YXR1c0NvZGUiLCJyZXNwb25zZUhlYWRlcnMiLCJyZXNwb25zZUJvZHkiLCJpc1JldHJ5YWJsZSIsImRhdGEiLCJpc0FQSUNhbGxFcnJvciIsIm5hbWUyIiwibWFya2VyMyIsInN5bWJvbDMiLCJfYTMiLCJFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiaXNFbXB0eVJlc3BvbnNlQm9keUVycm9yIiwiZ2V0RXJyb3JNZXNzYWdlIiwiSlNPTiIsInN0cmluZ2lmeSIsIm5hbWUzIiwibWFya2VyNCIsInN5bWJvbDQiLCJfYTQiLCJJbnZhbGlkQXJndW1lbnRFcnJvciIsImFyZ3VtZW50IiwibmFtZTQiLCJtYXJrZXI1Iiwic3ltYm9sNSIsIl9hNSIsIkludmFsaWRQcm9tcHRFcnJvciIsInByb21wdCIsInByb21wdDIiLCJpc0ludmFsaWRQcm9tcHRFcnJvciIsInN0YWNrIiwibmFtZTUiLCJtYXJrZXI2Iiwic3ltYm9sNiIsIl9hNiIsIkludmFsaWRSZXNwb25zZURhdGFFcnJvciIsImlzSW52YWxpZFJlc3BvbnNlRGF0YUVycm9yIiwibmFtZTYiLCJtYXJrZXI3Iiwic3ltYm9sNyIsIl9hNyIsIkpTT05QYXJzZUVycm9yIiwidGV4dCIsImlzSlNPTlBhcnNlRXJyb3IiLCJ2YWx1ZVRleHQiLCJuYW1lNyIsIm1hcmtlcjgiLCJzeW1ib2w4IiwiX2E4IiwiTG9hZEFQSUtleUVycm9yIiwiaXNMb2FkQVBJS2V5RXJyb3IiLCJuYW1lOCIsIm1hcmtlcjkiLCJzeW1ib2w5IiwiX2E5IiwiTG9hZFNldHRpbmdFcnJvciIsImlzTG9hZFNldHRpbmdFcnJvciIsIm5hbWU5IiwibWFya2VyMTAiLCJzeW1ib2wxMCIsIl9hMTAiLCJOb0NvbnRlbnRHZW5lcmF0ZWRFcnJvciIsImlzTm9Db250ZW50R2VuZXJhdGVkRXJyb3IiLCJuYW1lMTAiLCJtYXJrZXIxMSIsInN5bWJvbDExIiwiX2ExMSIsIk5vU3VjaE1vZGVsRXJyb3IiLCJlcnJvck5hbWUiLCJtb2RlbElkIiwibW9kZWxUeXBlIiwiaXNOb1N1Y2hNb2RlbEVycm9yIiwibmFtZTExIiwibWFya2VyMTIiLCJzeW1ib2wxMiIsIl9hMTIiLCJUb29NYW55RW1iZWRkaW5nVmFsdWVzRm9yQ2FsbEVycm9yIiwib3B0aW9ucyIsInByb3ZpZGVyIiwibWF4RW1iZWRkaW5nc1BlckNhbGwiLCJ2YWx1ZXMiLCJsZW5ndGgiLCJpc1Rvb01hbnlFbWJlZGRpbmdWYWx1ZXNGb3JDYWxsRXJyb3IiLCJBcnJheSIsImlzQXJyYXkiLCJuYW1lMTIiLCJtYXJrZXIxMyIsInN5bWJvbDEzIiwiX2ExMyIsIl9UeXBlVmFsaWRhdGlvbkVycm9yIiwidmFsdWUiLCJ3cmFwIiwiaXNUeXBlVmFsaWRhdGlvbkVycm9yIiwiVHlwZVZhbGlkYXRpb25FcnJvciIsIm5hbWUxMyIsIm1hcmtlcjE0Iiwic3ltYm9sMTQiLCJfYTE0IiwiVW5zdXBwb3J0ZWRGdW5jdGlvbmFsaXR5RXJyb3IiLCJmdW5jdGlvbmFsaXR5IiwiaXNVbnN1cHBvcnRlZEZ1bmN0aW9uYWxpdHlFcnJvciIsImlzSlNPTlZhbHVlIiwiZXZlcnkiLCJPYmplY3QiLCJlbnRyaWVzIiwia2V5IiwidmFsIiwiaXNKU09OQXJyYXkiLCJpc0pTT05PYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/provider/dist/index.mjs\n");

/***/ }),

/***/ "(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs":
/*!******************************************************!*\
  !*** ./node_modules/@ai-sdk/ui-utils/dist/index.mjs ***!
  \******************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   asSchema: () => (/* binding */ asSchema),\n/* harmony export */   callChatApi: () => (/* binding */ callChatApi),\n/* harmony export */   callCompletionApi: () => (/* binding */ callCompletionApi),\n/* harmony export */   createChunkDecoder: () => (/* binding */ createChunkDecoder),\n/* harmony export */   formatStreamPart: () => (/* binding */ formatStreamPart),\n/* harmony export */   generateId: () => (/* reexport safe */ _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId),\n/* harmony export */   getTextFromDataUrl: () => (/* binding */ getTextFromDataUrl),\n/* harmony export */   isDeepEqualData: () => (/* binding */ isDeepEqualData),\n/* harmony export */   jsonSchema: () => (/* binding */ jsonSchema),\n/* harmony export */   parsePartialJson: () => (/* binding */ parsePartialJson),\n/* harmony export */   parseStreamPart: () => (/* binding */ parseStreamPart),\n/* harmony export */   processChatStream: () => (/* binding */ processChatStream),\n/* harmony export */   processDataProtocolResponse: () => (/* binding */ processDataProtocolResponse),\n/* harmony export */   readDataStream: () => (/* binding */ readDataStream),\n/* harmony export */   zodSchema: () => (/* binding */ zodSchema)\n/* harmony export */ });\n/* harmony import */ var _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @ai-sdk/provider-utils */ \"(rsc)/./node_modules/@ai-sdk/provider-utils/dist/index.mjs\");\n/* harmony import */ var secure_json_parse__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! secure-json-parse */ \"(rsc)/./node_modules/secure-json-parse/index.js\");\n/* harmony import */ var zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! zod-to-json-schema */ \"(rsc)/./node_modules/zod-to-json-schema/dist/esm/index.js\");\n// src/index.ts\n\n// src/process-data-protocol-response.ts\n\n// src/parse-partial-json.ts\n\n// src/fix-json.ts\nfunction fixJson(input) {\n    const stack = [\n        \"ROOT\"\n    ];\n    let lastValidIndex = -1;\n    let literalStart = null;\n    function processValueStart(char, i, swapState) {\n        {\n            switch(char){\n                case '\"':\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_STRING\");\n                        break;\n                    }\n                case \"f\":\n                case \"t\":\n                case \"n\":\n                    {\n                        lastValidIndex = i;\n                        literalStart = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_LITERAL\");\n                        break;\n                    }\n                case \"-\":\n                    {\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"0\":\n                case \"1\":\n                case \"2\":\n                case \"3\":\n                case \"4\":\n                case \"5\":\n                case \"6\":\n                case \"7\":\n                case \"8\":\n                case \"9\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_NUMBER\");\n                        break;\n                    }\n                case \"{\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_OBJECT_START\");\n                        break;\n                    }\n                case \"[\":\n                    {\n                        lastValidIndex = i;\n                        stack.pop();\n                        stack.push(swapState);\n                        stack.push(\"INSIDE_ARRAY_START\");\n                        break;\n                    }\n            }\n        }\n    }\n    function processAfterObjectValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_OBJECT_AFTER_COMMA\");\n                    break;\n                }\n            case \"}\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    function processAfterArrayValue(char, i) {\n        switch(char){\n            case \",\":\n                {\n                    stack.pop();\n                    stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                    break;\n                }\n            case \"]\":\n                {\n                    lastValidIndex = i;\n                    stack.pop();\n                    break;\n                }\n        }\n    }\n    for(let i = 0; i < input.length; i++){\n        const char = input[i];\n        const currentState = stack[stack.length - 1];\n        switch(currentState){\n            case \"ROOT\":\n                processValueStart(char, i, \"FINISH\");\n                break;\n            case \"INSIDE_OBJECT_START\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_AFTER_KEY\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n                {\n                    switch(char){\n                        case \":\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_OBJECT_BEFORE_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n                {\n                    processValueStart(char, i, \"INSIDE_OBJECT_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    processAfterObjectValue(char, i);\n                    break;\n                }\n            case \"INSIDE_STRING\":\n                {\n                    switch(char){\n                        case '\"':\n                            {\n                                stack.pop();\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"\\\\\":\n                            {\n                                stack.push(\"INSIDE_STRING_ESCAPE\");\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n                {\n                    switch(char){\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    switch(char){\n                        case \",\":\n                            {\n                                stack.pop();\n                                stack.push(\"INSIDE_ARRAY_AFTER_COMMA\");\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                lastValidIndex = i;\n                                stack.pop();\n                                break;\n                            }\n                        default:\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n                {\n                    processValueStart(char, i, \"INSIDE_ARRAY_AFTER_VALUE\");\n                    break;\n                }\n            case \"INSIDE_STRING_ESCAPE\":\n                {\n                    stack.pop();\n                    lastValidIndex = i;\n                    break;\n                }\n            case \"INSIDE_NUMBER\":\n                {\n                    switch(char){\n                        case \"0\":\n                        case \"1\":\n                        case \"2\":\n                        case \"3\":\n                        case \"4\":\n                        case \"5\":\n                        case \"6\":\n                        case \"7\":\n                        case \"8\":\n                        case \"9\":\n                            {\n                                lastValidIndex = i;\n                                break;\n                            }\n                        case \"e\":\n                        case \"E\":\n                        case \"-\":\n                        case \".\":\n                            {\n                                break;\n                            }\n                        case \",\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"}\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                                    processAfterObjectValue(char, i);\n                                }\n                                break;\n                            }\n                        case \"]\":\n                            {\n                                stack.pop();\n                                if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                                    processAfterArrayValue(char, i);\n                                }\n                                break;\n                            }\n                        default:\n                            {\n                                stack.pop();\n                                break;\n                            }\n                    }\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, i + 1);\n                    if (!\"false\".startsWith(partialLiteral) && !\"true\".startsWith(partialLiteral) && !\"null\".startsWith(partialLiteral)) {\n                        stack.pop();\n                        if (stack[stack.length - 1] === \"INSIDE_OBJECT_AFTER_VALUE\") {\n                            processAfterObjectValue(char, i);\n                        } else if (stack[stack.length - 1] === \"INSIDE_ARRAY_AFTER_VALUE\") {\n                            processAfterArrayValue(char, i);\n                        }\n                    } else {\n                        lastValidIndex = i;\n                    }\n                    break;\n                }\n        }\n    }\n    let result = input.slice(0, lastValidIndex + 1);\n    for(let i = stack.length - 1; i >= 0; i--){\n        const state = stack[i];\n        switch(state){\n            case \"INSIDE_STRING\":\n                {\n                    result += '\"';\n                    break;\n                }\n            case \"INSIDE_OBJECT_KEY\":\n            case \"INSIDE_OBJECT_AFTER_KEY\":\n            case \"INSIDE_OBJECT_AFTER_COMMA\":\n            case \"INSIDE_OBJECT_START\":\n            case \"INSIDE_OBJECT_BEFORE_VALUE\":\n            case \"INSIDE_OBJECT_AFTER_VALUE\":\n                {\n                    result += \"}\";\n                    break;\n                }\n            case \"INSIDE_ARRAY_START\":\n            case \"INSIDE_ARRAY_AFTER_COMMA\":\n            case \"INSIDE_ARRAY_AFTER_VALUE\":\n                {\n                    result += \"]\";\n                    break;\n                }\n            case \"INSIDE_LITERAL\":\n                {\n                    const partialLiteral = input.substring(literalStart, input.length);\n                    if (\"true\".startsWith(partialLiteral)) {\n                        result += \"true\".slice(partialLiteral.length);\n                    } else if (\"false\".startsWith(partialLiteral)) {\n                        result += \"false\".slice(partialLiteral.length);\n                    } else if (\"null\".startsWith(partialLiteral)) {\n                        result += \"null\".slice(partialLiteral.length);\n                    }\n                }\n        }\n    }\n    return result;\n}\n// src/parse-partial-json.ts\nfunction parsePartialJson(jsonText) {\n    if (jsonText === void 0) {\n        return {\n            value: void 0,\n            state: \"undefined-input\"\n        };\n    }\n    try {\n        return {\n            value: secure_json_parse__WEBPACK_IMPORTED_MODULE_0__.parse(jsonText),\n            state: \"successful-parse\"\n        };\n    } catch (ignored) {\n        try {\n            return {\n                value: secure_json_parse__WEBPACK_IMPORTED_MODULE_0__.parse(fixJson(jsonText)),\n                state: \"repaired-parse\"\n            };\n        } catch (ignored2) {}\n    }\n    return {\n        value: void 0,\n        state: \"failed-parse\"\n    };\n}\n// src/stream-parts.ts\nvar textStreamPart = {\n    code: \"0\",\n    name: \"text\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"text\" parts expect a string value.');\n        }\n        return {\n            type: \"text\",\n            value\n        };\n    }\n};\nvar functionCallStreamPart = {\n    code: \"1\",\n    name: \"function_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"function_call\" in value) || typeof value.function_call !== \"object\" || value.function_call == null || !(\"name\" in value.function_call) || !(\"arguments\" in value.function_call) || typeof value.function_call.name !== \"string\" || typeof value.function_call.arguments !== \"string\") {\n            throw new Error('\"function_call\" parts expect an object with a \"function_call\" property.');\n        }\n        return {\n            type: \"function_call\",\n            value\n        };\n    }\n};\nvar dataStreamPart = {\n    code: \"2\",\n    name: \"data\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"data\" parts expect an array value.');\n        }\n        return {\n            type: \"data\",\n            value\n        };\n    }\n};\nvar errorStreamPart = {\n    code: \"3\",\n    name: \"error\",\n    parse: (value)=>{\n        if (typeof value !== \"string\") {\n            throw new Error('\"error\" parts expect a string value.');\n        }\n        return {\n            type: \"error\",\n            value\n        };\n    }\n};\nvar assistantMessageStreamPart = {\n    code: \"4\",\n    name: \"assistant_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"id\" in value) || !(\"role\" in value) || !(\"content\" in value) || typeof value.id !== \"string\" || typeof value.role !== \"string\" || value.role !== \"assistant\" || !Array.isArray(value.content) || !value.content.every((item)=>item != null && typeof item === \"object\" && \"type\" in item && item.type === \"text\" && \"text\" in item && item.text != null && typeof item.text === \"object\" && \"value\" in item.text && typeof item.text.value === \"string\")) {\n            throw new Error('\"assistant_message\" parts expect an object with an \"id\", \"role\", and \"content\" property.');\n        }\n        return {\n            type: \"assistant_message\",\n            value\n        };\n    }\n};\nvar assistantControlDataStreamPart = {\n    code: \"5\",\n    name: \"assistant_control_data\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"threadId\" in value) || !(\"messageId\" in value) || typeof value.threadId !== \"string\" || typeof value.messageId !== \"string\") {\n            throw new Error('\"assistant_control_data\" parts expect an object with a \"threadId\" and \"messageId\" property.');\n        }\n        return {\n            type: \"assistant_control_data\",\n            value: {\n                threadId: value.threadId,\n                messageId: value.messageId\n            }\n        };\n    }\n};\nvar dataMessageStreamPart = {\n    code: \"6\",\n    name: \"data_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"role\" in value) || !(\"data\" in value) || typeof value.role !== \"string\" || value.role !== \"data\") {\n            throw new Error('\"data_message\" parts expect an object with a \"role\" and \"data\" property.');\n        }\n        return {\n            type: \"data_message\",\n            value\n        };\n    }\n};\nvar toolCallsStreamPart = {\n    code: \"7\",\n    name: \"tool_calls\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"tool_calls\" in value) || typeof value.tool_calls !== \"object\" || value.tool_calls == null || !Array.isArray(value.tool_calls) || value.tool_calls.some((tc)=>tc == null || typeof tc !== \"object\" || !(\"id\" in tc) || typeof tc.id !== \"string\" || !(\"type\" in tc) || typeof tc.type !== \"string\" || !(\"function\" in tc) || tc.function == null || typeof tc.function !== \"object\" || !(\"arguments\" in tc.function) || typeof tc.function.name !== \"string\" || typeof tc.function.arguments !== \"string\")) {\n            throw new Error('\"tool_calls\" parts expect an object with a ToolCallPayload.');\n        }\n        return {\n            type: \"tool_calls\",\n            value\n        };\n    }\n};\nvar messageAnnotationsStreamPart = {\n    code: \"8\",\n    name: \"message_annotations\",\n    parse: (value)=>{\n        if (!Array.isArray(value)) {\n            throw new Error('\"message_annotations\" parts expect an array value.');\n        }\n        return {\n            type: \"message_annotations\",\n            value\n        };\n    }\n};\nvar toolCallStreamPart = {\n    code: \"9\",\n    name: \"tool_call\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\" || !(\"args\" in value) || typeof value.args !== \"object\") {\n            throw new Error('\"tool_call\" parts expect an object with a \"toolCallId\", \"toolName\", and \"args\" property.');\n        }\n        return {\n            type: \"tool_call\",\n            value\n        };\n    }\n};\nvar toolResultStreamPart = {\n    code: \"a\",\n    name: \"tool_result\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"result\" in value)) {\n            throw new Error('\"tool_result\" parts expect an object with a \"toolCallId\" and a \"result\" property.');\n        }\n        return {\n            type: \"tool_result\",\n            value\n        };\n    }\n};\nvar toolCallStreamingStartStreamPart = {\n    code: \"b\",\n    name: \"tool_call_streaming_start\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"toolName\" in value) || typeof value.toolName !== \"string\") {\n            throw new Error('\"tool_call_streaming_start\" parts expect an object with a \"toolCallId\" and \"toolName\" property.');\n        }\n        return {\n            type: \"tool_call_streaming_start\",\n            value\n        };\n    }\n};\nvar toolCallDeltaStreamPart = {\n    code: \"c\",\n    name: \"tool_call_delta\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"toolCallId\" in value) || typeof value.toolCallId !== \"string\" || !(\"argsTextDelta\" in value) || typeof value.argsTextDelta !== \"string\") {\n            throw new Error('\"tool_call_delta\" parts expect an object with a \"toolCallId\" and \"argsTextDelta\" property.');\n        }\n        return {\n            type: \"tool_call_delta\",\n            value\n        };\n    }\n};\nvar finishMessageStreamPart = {\n    code: \"d\",\n    name: \"finish_message\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n            throw new Error('\"finish_message\" parts expect an object with a \"finishReason\" property.');\n        }\n        const result = {\n            finishReason: value.finishReason\n        };\n        if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n            result.usage = {\n                promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n                completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n            };\n        }\n        return {\n            type: \"finish_message\",\n            value: result\n        };\n    }\n};\nvar finishStepStreamPart = {\n    code: \"e\",\n    name: \"finish_step\",\n    parse: (value)=>{\n        if (value == null || typeof value !== \"object\" || !(\"finishReason\" in value) || typeof value.finishReason !== \"string\") {\n            throw new Error('\"finish_step\" parts expect an object with a \"finishReason\" property.');\n        }\n        const result = {\n            finishReason: value.finishReason,\n            isContinued: false\n        };\n        if (\"usage\" in value && value.usage != null && typeof value.usage === \"object\" && \"promptTokens\" in value.usage && \"completionTokens\" in value.usage) {\n            result.usage = {\n                promptTokens: typeof value.usage.promptTokens === \"number\" ? value.usage.promptTokens : Number.NaN,\n                completionTokens: typeof value.usage.completionTokens === \"number\" ? value.usage.completionTokens : Number.NaN\n            };\n        }\n        if (\"isContinued\" in value && typeof value.isContinued === \"boolean\") {\n            result.isContinued = value.isContinued;\n        }\n        return {\n            type: \"finish_step\",\n            value: result\n        };\n    }\n};\nvar streamParts = [\n    textStreamPart,\n    functionCallStreamPart,\n    dataStreamPart,\n    errorStreamPart,\n    assistantMessageStreamPart,\n    assistantControlDataStreamPart,\n    dataMessageStreamPart,\n    toolCallsStreamPart,\n    messageAnnotationsStreamPart,\n    toolCallStreamPart,\n    toolResultStreamPart,\n    toolCallStreamingStartStreamPart,\n    toolCallDeltaStreamPart,\n    finishMessageStreamPart,\n    finishStepStreamPart\n];\nvar streamPartsByCode = {\n    [textStreamPart.code]: textStreamPart,\n    [functionCallStreamPart.code]: functionCallStreamPart,\n    [dataStreamPart.code]: dataStreamPart,\n    [errorStreamPart.code]: errorStreamPart,\n    [assistantMessageStreamPart.code]: assistantMessageStreamPart,\n    [assistantControlDataStreamPart.code]: assistantControlDataStreamPart,\n    [dataMessageStreamPart.code]: dataMessageStreamPart,\n    [toolCallsStreamPart.code]: toolCallsStreamPart,\n    [messageAnnotationsStreamPart.code]: messageAnnotationsStreamPart,\n    [toolCallStreamPart.code]: toolCallStreamPart,\n    [toolResultStreamPart.code]: toolResultStreamPart,\n    [toolCallStreamingStartStreamPart.code]: toolCallStreamingStartStreamPart,\n    [toolCallDeltaStreamPart.code]: toolCallDeltaStreamPart,\n    [finishMessageStreamPart.code]: finishMessageStreamPart,\n    [finishStepStreamPart.code]: finishStepStreamPart\n};\nvar StreamStringPrefixes = {\n    [textStreamPart.name]: textStreamPart.code,\n    [functionCallStreamPart.name]: functionCallStreamPart.code,\n    [dataStreamPart.name]: dataStreamPart.code,\n    [errorStreamPart.name]: errorStreamPart.code,\n    [assistantMessageStreamPart.name]: assistantMessageStreamPart.code,\n    [assistantControlDataStreamPart.name]: assistantControlDataStreamPart.code,\n    [dataMessageStreamPart.name]: dataMessageStreamPart.code,\n    [toolCallsStreamPart.name]: toolCallsStreamPart.code,\n    [messageAnnotationsStreamPart.name]: messageAnnotationsStreamPart.code,\n    [toolCallStreamPart.name]: toolCallStreamPart.code,\n    [toolResultStreamPart.name]: toolResultStreamPart.code,\n    [toolCallStreamingStartStreamPart.name]: toolCallStreamingStartStreamPart.code,\n    [toolCallDeltaStreamPart.name]: toolCallDeltaStreamPart.code,\n    [finishMessageStreamPart.name]: finishMessageStreamPart.code,\n    [finishStepStreamPart.name]: finishStepStreamPart.code\n};\nvar validCodes = streamParts.map((part)=>part.code);\nvar parseStreamPart = (line)=>{\n    const firstSeparatorIndex = line.indexOf(\":\");\n    if (firstSeparatorIndex === -1) {\n        throw new Error(\"Failed to parse stream string. No separator found.\");\n    }\n    const prefix = line.slice(0, firstSeparatorIndex);\n    if (!validCodes.includes(prefix)) {\n        throw new Error(`Failed to parse stream string. Invalid code ${prefix}.`);\n    }\n    const code = prefix;\n    const textValue = line.slice(firstSeparatorIndex + 1);\n    const jsonValue = JSON.parse(textValue);\n    return streamPartsByCode[code].parse(jsonValue);\n};\nfunction formatStreamPart(type, value) {\n    const streamPart = streamParts.find((part)=>part.name === type);\n    if (!streamPart) {\n        throw new Error(`Invalid stream part type: ${type}`);\n    }\n    return `${streamPart.code}:${JSON.stringify(value)}\n`;\n}\n// src/read-data-stream.ts\nvar NEWLINE = \"\\n\".charCodeAt(0);\nfunction concatChunks(chunks, totalLength) {\n    const concatenatedChunks = new Uint8Array(totalLength);\n    let offset = 0;\n    for (const chunk of chunks){\n        concatenatedChunks.set(chunk, offset);\n        offset += chunk.length;\n    }\n    chunks.length = 0;\n    return concatenatedChunks;\n}\nasync function* readDataStream(reader, { isAborted } = {}) {\n    const decoder = new TextDecoder();\n    const chunks = [];\n    let totalLength = 0;\n    while(true){\n        const { value } = await reader.read();\n        if (value) {\n            chunks.push(value);\n            totalLength += value.length;\n            if (value[value.length - 1] !== NEWLINE) {\n                continue;\n            }\n        }\n        if (chunks.length === 0) {\n            break;\n        }\n        const concatenatedChunks = concatChunks(chunks, totalLength);\n        totalLength = 0;\n        const streamParts2 = decoder.decode(concatenatedChunks, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\").map(parseStreamPart);\n        for (const streamPart of streamParts2){\n            yield streamPart;\n        }\n        if (isAborted == null ? void 0 : isAborted()) {\n            reader.cancel();\n            break;\n        }\n    }\n}\n// src/process-data-protocol-response.ts\nfunction assignAnnotationsToMessage(message, annotations) {\n    if (!message || !annotations || !annotations.length) return message;\n    return {\n        ...message,\n        annotations: [\n            ...annotations\n        ]\n    };\n}\nasync function processDataProtocolResponse({ reader, abortControllerRef, update, onToolCall, onFinish, generateId: generateId2 = _ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.generateId, getCurrentDate = ()=>/* @__PURE__ */ new Date() }) {\n    var _a;\n    const createdAt = getCurrentDate();\n    let prefixMap = {};\n    let nextPrefixMap = void 0;\n    const previousMessages = [];\n    const data = [];\n    let messageAnnotations = void 0;\n    const partialToolCalls = {};\n    let usage = {\n        completionTokens: NaN,\n        promptTokens: NaN,\n        totalTokens: NaN\n    };\n    let finishReason = \"unknown\";\n    for await (const { type, value } of readDataStream(reader, {\n        isAborted: ()=>(abortControllerRef == null ? void 0 : abortControllerRef.current) === null\n    })){\n        if (type === \"error\") {\n            throw new Error(value);\n        }\n        if (type === \"finish_step\") {\n            if (!value.isContinued) {\n                nextPrefixMap = {};\n            }\n            continue;\n        }\n        if (type === \"finish_message\") {\n            finishReason = value.finishReason;\n            if (value.usage != null) {\n                const { completionTokens, promptTokens } = value.usage;\n                usage = {\n                    completionTokens,\n                    promptTokens,\n                    totalTokens: completionTokens + promptTokens\n                };\n            }\n            continue;\n        }\n        if (nextPrefixMap != null && (type === \"text\" || type === \"tool_call\" || type === \"tool_call_streaming_start\" || type === \"tool_call_delta\" || type === \"tool_result\")) {\n            if (prefixMap.text) {\n                previousMessages.push(prefixMap.text);\n            }\n            if (prefixMap.function_call) {\n                previousMessages.push(prefixMap.function_call);\n            }\n            if (prefixMap.tool_calls) {\n                previousMessages.push(prefixMap.tool_calls);\n            }\n            prefixMap = nextPrefixMap;\n            nextPrefixMap = void 0;\n        }\n        if (type === \"text\") {\n            if (prefixMap[\"text\"]) {\n                prefixMap[\"text\"] = {\n                    ...prefixMap[\"text\"],\n                    content: (prefixMap[\"text\"].content || \"\") + value\n                };\n            } else {\n                prefixMap[\"text\"] = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: value,\n                    createdAt\n                };\n            }\n        }\n        if (type === \"tool_call_streaming_start\") {\n            if (prefixMap.text == null) {\n                prefixMap.text = {\n                    id: generateId2(),\n                    role: \"assistant\",\n                    content: \"\",\n                    createdAt\n                };\n            }\n            if (prefixMap.text.toolInvocations == null) {\n                prefixMap.text.toolInvocations = [];\n            }\n            partialToolCalls[value.toolCallId] = {\n                text: \"\",\n                toolName: value.toolName,\n                prefixMapIndex: prefixMap.text.toolInvocations.length\n            };\n            prefixMap.text.toolInvocations.push({\n                state: \"partial-call\",\n                toolCallId: value.toolCallId,\n                toolName: value.toolName,\n                args: void 0\n            });\n        } else if (type === \"tool_call_delta\") {\n            const partialToolCall = partialToolCalls[value.toolCallId];\n            partialToolCall.text += value.argsTextDelta;\n            const { value: partialArgs } = parsePartialJson(partialToolCall.text);\n            prefixMap.text.toolInvocations[partialToolCall.prefixMapIndex] = {\n                state: \"partial-call\",\n                toolCallId: value.toolCallId,\n                toolName: partialToolCall.toolName,\n                args: partialArgs\n            };\n            prefixMap.text.internalUpdateId = generateId2();\n        } else if (type === \"tool_call\") {\n            if (partialToolCalls[value.toolCallId] != null) {\n                prefixMap.text.toolInvocations[partialToolCalls[value.toolCallId].prefixMapIndex] = {\n                    state: \"call\",\n                    ...value\n                };\n            } else {\n                if (prefixMap.text == null) {\n                    prefixMap.text = {\n                        id: generateId2(),\n                        role: \"assistant\",\n                        content: \"\",\n                        createdAt\n                    };\n                }\n                if (prefixMap.text.toolInvocations == null) {\n                    prefixMap.text.toolInvocations = [];\n                }\n                prefixMap.text.toolInvocations.push({\n                    state: \"call\",\n                    ...value\n                });\n            }\n            prefixMap.text.internalUpdateId = generateId2();\n            if (onToolCall) {\n                const result = await onToolCall({\n                    toolCall: value\n                });\n                if (result != null) {\n                    prefixMap.text.toolInvocations[prefixMap.text.toolInvocations.length - 1] = {\n                        state: \"result\",\n                        ...value,\n                        result\n                    };\n                }\n            }\n        } else if (type === \"tool_result\") {\n            const toolInvocations = (_a = prefixMap.text) == null ? void 0 : _a.toolInvocations;\n            if (toolInvocations == null) {\n                throw new Error(\"tool_result must be preceded by a tool_call\");\n            }\n            const toolInvocationIndex = toolInvocations.findIndex((invocation)=>invocation.toolCallId === value.toolCallId);\n            if (toolInvocationIndex === -1) {\n                throw new Error(\"tool_result must be preceded by a tool_call with the same toolCallId\");\n            }\n            toolInvocations[toolInvocationIndex] = {\n                ...toolInvocations[toolInvocationIndex],\n                state: \"result\",\n                ...value\n            };\n        }\n        let functionCallMessage = null;\n        if (type === \"function_call\") {\n            prefixMap[\"function_call\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                function_call: value.function_call,\n                name: value.function_call.name,\n                createdAt\n            };\n            functionCallMessage = prefixMap[\"function_call\"];\n        }\n        let toolCallMessage = null;\n        if (type === \"tool_calls\") {\n            prefixMap[\"tool_calls\"] = {\n                id: generateId2(),\n                role: \"assistant\",\n                content: \"\",\n                tool_calls: value.tool_calls,\n                createdAt\n            };\n            toolCallMessage = prefixMap[\"tool_calls\"];\n        }\n        if (type === \"data\") {\n            data.push(...value);\n        }\n        let responseMessage = prefixMap[\"text\"];\n        if (type === \"message_annotations\") {\n            if (!messageAnnotations) {\n                messageAnnotations = [\n                    ...value\n                ];\n            } else {\n                messageAnnotations.push(...value);\n            }\n            functionCallMessage = assignAnnotationsToMessage(prefixMap[\"function_call\"], messageAnnotations);\n            toolCallMessage = assignAnnotationsToMessage(prefixMap[\"tool_calls\"], messageAnnotations);\n            responseMessage = assignAnnotationsToMessage(prefixMap[\"text\"], messageAnnotations);\n            if (prefixMap.text != null) {\n                prefixMap.text.internalUpdateId = generateId2();\n            }\n        }\n        if (messageAnnotations == null ? void 0 : messageAnnotations.length) {\n            if (prefixMap.text) {\n                prefixMap.text.annotations = [\n                    ...messageAnnotations\n                ];\n            }\n            if (prefixMap.function_call) {\n                prefixMap.function_call.annotations = [\n                    ...messageAnnotations\n                ];\n            }\n            if (prefixMap.tool_calls) {\n                prefixMap.tool_calls.annotations = [\n                    ...messageAnnotations\n                ];\n            }\n        }\n        const merged = [\n            functionCallMessage,\n            toolCallMessage,\n            responseMessage\n        ].filter(Boolean).map((message)=>({\n                ...assignAnnotationsToMessage(message, messageAnnotations)\n            }));\n        update([\n            ...previousMessages,\n            ...merged\n        ], [\n            ...data\n        ]);\n    }\n    onFinish == null ? void 0 : onFinish({\n        message: prefixMap.text,\n        finishReason,\n        usage\n    });\n    return {\n        messages: [\n            prefixMap.text,\n            prefixMap.function_call,\n            prefixMap.tool_calls\n        ].filter(Boolean),\n        data\n    };\n}\n// src/call-chat-api.ts\nvar getOriginalFetch = ()=>fetch;\nasync function callChatApi({ api, body, streamProtocol = \"data\", credentials, headers, abortController, restoreMessagesOnFailure, onResponse, onUpdate, onFinish, onToolCall, generateId: generateId2, fetch: fetch2 = getOriginalFetch() }) {\n    var _a, _b;\n    const response = await fetch2(api, {\n        method: \"POST\",\n        body: JSON.stringify(body),\n        headers: {\n            \"Content-Type\": \"application/json\",\n            ...headers\n        },\n        signal: (_a = abortController == null ? void 0 : abortController()) == null ? void 0 : _a.signal,\n        credentials\n    }).catch((err)=>{\n        restoreMessagesOnFailure();\n        throw err;\n    });\n    if (onResponse) {\n        try {\n            await onResponse(response);\n        } catch (err) {\n            throw err;\n        }\n    }\n    if (!response.ok) {\n        restoreMessagesOnFailure();\n        throw new Error((_b = await response.text()) != null ? _b : \"Failed to fetch the chat response.\");\n    }\n    if (!response.body) {\n        throw new Error(\"The response body is empty.\");\n    }\n    const reader = response.body.getReader();\n    switch(streamProtocol){\n        case \"text\":\n            {\n                const decoder = createChunkDecoder();\n                const resultMessage = {\n                    id: generateId2(),\n                    createdAt: /* @__PURE__ */ new Date(),\n                    role: \"assistant\",\n                    content: \"\"\n                };\n                while(true){\n                    const { done, value } = await reader.read();\n                    if (done) {\n                        break;\n                    }\n                    resultMessage.content += decoder(value);\n                    onUpdate([\n                        {\n                            ...resultMessage\n                        }\n                    ], []);\n                    if ((abortController == null ? void 0 : abortController()) === null) {\n                        reader.cancel();\n                        break;\n                    }\n                }\n                onFinish == null ? void 0 : onFinish(resultMessage, {\n                    usage: {\n                        completionTokens: NaN,\n                        promptTokens: NaN,\n                        totalTokens: NaN\n                    },\n                    finishReason: \"unknown\"\n                });\n                return {\n                    messages: [\n                        resultMessage\n                    ],\n                    data: []\n                };\n            }\n        case \"data\":\n            {\n                return await processDataProtocolResponse({\n                    reader,\n                    abortControllerRef: abortController != null ? {\n                        current: abortController()\n                    } : void 0,\n                    update: onUpdate,\n                    onToolCall,\n                    onFinish ({ message, finishReason, usage }) {\n                        if (onFinish && message != null) {\n                            onFinish(message, {\n                                usage,\n                                finishReason\n                            });\n                        }\n                    },\n                    generateId: generateId2\n                });\n            }\n        default:\n            {\n                const exhaustiveCheck = streamProtocol;\n                throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n            }\n    }\n}\n// src/call-completion-api.ts\nvar getOriginalFetch2 = ()=>fetch;\nasync function callCompletionApi({ api, prompt, credentials, headers, body, streamProtocol = \"data\", setCompletion, setLoading, setError, setAbortController, onResponse, onFinish, onError, onData, fetch: fetch2 = getOriginalFetch2() }) {\n    try {\n        setLoading(true);\n        setError(void 0);\n        const abortController = new AbortController();\n        setAbortController(abortController);\n        setCompletion(\"\");\n        const res = await fetch2(api, {\n            method: \"POST\",\n            body: JSON.stringify({\n                prompt,\n                ...body\n            }),\n            credentials,\n            headers: {\n                \"Content-Type\": \"application/json\",\n                ...headers\n            },\n            signal: abortController.signal\n        }).catch((err)=>{\n            throw err;\n        });\n        if (onResponse) {\n            try {\n                await onResponse(res);\n            } catch (err) {\n                throw err;\n            }\n        }\n        if (!res.ok) {\n            throw new Error(await res.text() || \"Failed to fetch the chat response.\");\n        }\n        if (!res.body) {\n            throw new Error(\"The response body is empty.\");\n        }\n        let result = \"\";\n        const reader = res.body.getReader();\n        switch(streamProtocol){\n            case \"text\":\n                {\n                    const decoder = createChunkDecoder();\n                    while(true){\n                        const { done, value } = await reader.read();\n                        if (done) {\n                            break;\n                        }\n                        result += decoder(value);\n                        setCompletion(result);\n                        if (abortController === null) {\n                            reader.cancel();\n                            break;\n                        }\n                    }\n                    break;\n                }\n            case \"data\":\n                {\n                    for await (const { type, value } of readDataStream(reader, {\n                        isAborted: ()=>abortController === null\n                    })){\n                        switch(type){\n                            case \"text\":\n                                {\n                                    result += value;\n                                    setCompletion(result);\n                                    break;\n                                }\n                            case \"data\":\n                                {\n                                    onData == null ? void 0 : onData(value);\n                                    break;\n                                }\n                        }\n                    }\n                    break;\n                }\n            default:\n                {\n                    const exhaustiveCheck = streamProtocol;\n                    throw new Error(`Unknown stream protocol: ${exhaustiveCheck}`);\n                }\n        }\n        if (onFinish) {\n            onFinish(prompt, result);\n        }\n        setAbortController(null);\n        return result;\n    } catch (err) {\n        if (err.name === \"AbortError\") {\n            setAbortController(null);\n            return null;\n        }\n        if (err instanceof Error) {\n            if (onError) {\n                onError(err);\n            }\n        }\n        setError(err);\n    } finally{\n        setLoading(false);\n    }\n}\n// src/create-chunk-decoder.ts\nfunction createChunkDecoder(complex) {\n    const decoder = new TextDecoder();\n    if (!complex) {\n        return function(chunk) {\n            if (!chunk) return \"\";\n            return decoder.decode(chunk, {\n                stream: true\n            });\n        };\n    }\n    return function(chunk) {\n        const decoded = decoder.decode(chunk, {\n            stream: true\n        }).split(\"\\n\").filter((line)=>line !== \"\");\n        return decoded.map(parseStreamPart).filter(Boolean);\n    };\n}\n// src/data-url.ts\nfunction getTextFromDataUrl(dataUrl) {\n    const [header, base64Content] = dataUrl.split(\",\");\n    const mimeType = header.split(\";\")[0].split(\":\")[1];\n    if (mimeType == null || base64Content == null) {\n        throw new Error(\"Invalid data URL format\");\n    }\n    try {\n        return window.atob(base64Content);\n    } catch (error) {\n        throw new Error(`Error decoding data URL`);\n    }\n}\n// src/is-deep-equal-data.ts\nfunction isDeepEqualData(obj1, obj2) {\n    if (obj1 === obj2) return true;\n    if (obj1 == null || obj2 == null) return false;\n    if (typeof obj1 !== \"object\" && typeof obj2 !== \"object\") return obj1 === obj2;\n    if (obj1.constructor !== obj2.constructor) return false;\n    if (obj1 instanceof Date && obj2 instanceof Date) {\n        return obj1.getTime() === obj2.getTime();\n    }\n    if (Array.isArray(obj1)) {\n        if (obj1.length !== obj2.length) return false;\n        for(let i = 0; i < obj1.length; i++){\n            if (!isDeepEqualData(obj1[i], obj2[i])) return false;\n        }\n        return true;\n    }\n    const keys1 = Object.keys(obj1);\n    const keys2 = Object.keys(obj2);\n    if (keys1.length !== keys2.length) return false;\n    for (const key of keys1){\n        if (!keys2.includes(key)) return false;\n        if (!isDeepEqualData(obj1[key], obj2[key])) return false;\n    }\n    return true;\n}\n// src/process-chat-stream.ts\nasync function processChatStream({ getStreamedResponse, experimental_onFunctionCall, experimental_onToolCall, updateChatRequest, getCurrentMessages }) {\n    while(true){\n        const messagesAndDataOrJustMessage = await getStreamedResponse();\n        if (\"messages\" in messagesAndDataOrJustMessage) {\n            let hasFollowingResponse = false;\n            for (const message of messagesAndDataOrJustMessage.messages){\n                if ((message.function_call === void 0 || typeof message.function_call === \"string\") && (message.tool_calls === void 0 || typeof message.tool_calls === \"string\")) {\n                    continue;\n                }\n                hasFollowingResponse = true;\n                if (experimental_onFunctionCall) {\n                    const functionCall = message.function_call;\n                    if (typeof functionCall !== \"object\") {\n                        console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                    if (functionCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(functionCallResponse);\n                }\n                if (experimental_onToolCall) {\n                    const toolCalls = message.tool_calls;\n                    if (!Array.isArray(toolCalls) || toolCalls.some((toolCall)=>typeof toolCall !== \"object\")) {\n                        console.warn(\"experimental_onToolCall should not be defined when using tools\");\n                        continue;\n                    }\n                    const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                    if (toolCallResponse === void 0) {\n                        hasFollowingResponse = false;\n                        break;\n                    }\n                    updateChatRequest(toolCallResponse);\n                }\n            }\n            if (!hasFollowingResponse) {\n                break;\n            }\n        } else {\n            let fixFunctionCallArguments2 = function(response) {\n                for (const message of response.messages){\n                    if (message.tool_calls !== void 0) {\n                        for (const toolCall of message.tool_calls){\n                            if (typeof toolCall === \"object\") {\n                                if (toolCall.function.arguments && typeof toolCall.function.arguments !== \"string\") {\n                                    toolCall.function.arguments = JSON.stringify(toolCall.function.arguments);\n                                }\n                            }\n                        }\n                    }\n                    if (message.function_call !== void 0) {\n                        if (typeof message.function_call === \"object\") {\n                            if (message.function_call.arguments && typeof message.function_call.arguments !== \"string\") {\n                                message.function_call.arguments = JSON.stringify(message.function_call.arguments);\n                            }\n                        }\n                    }\n                }\n            };\n            var fixFunctionCallArguments = fixFunctionCallArguments2;\n            const streamedResponseMessage = messagesAndDataOrJustMessage;\n            if ((streamedResponseMessage.function_call === void 0 || typeof streamedResponseMessage.function_call === \"string\") && (streamedResponseMessage.tool_calls === void 0 || typeof streamedResponseMessage.tool_calls === \"string\")) {\n                break;\n            }\n            if (experimental_onFunctionCall) {\n                const functionCall = streamedResponseMessage.function_call;\n                if (!(typeof functionCall === \"object\")) {\n                    console.warn(\"experimental_onFunctionCall should not be defined when using tools\");\n                    continue;\n                }\n                const functionCallResponse = await experimental_onFunctionCall(getCurrentMessages(), functionCall);\n                if (functionCallResponse === void 0) break;\n                fixFunctionCallArguments2(functionCallResponse);\n                updateChatRequest(functionCallResponse);\n            }\n            if (experimental_onToolCall) {\n                const toolCalls = streamedResponseMessage.tool_calls;\n                if (!(typeof toolCalls === \"object\")) {\n                    console.warn(\"experimental_onToolCall should not be defined when using functions\");\n                    continue;\n                }\n                const toolCallResponse = await experimental_onToolCall(getCurrentMessages(), toolCalls);\n                if (toolCallResponse === void 0) break;\n                fixFunctionCallArguments2(toolCallResponse);\n                updateChatRequest(toolCallResponse);\n            }\n        }\n    }\n}\n// src/schema.ts\n\n\nvar schemaSymbol = Symbol.for(\"vercel.ai.schema\");\nfunction jsonSchema(jsonSchema2, { validate } = {}) {\n    return {\n        [schemaSymbol]: true,\n        _type: void 0,\n        // should never be used directly\n        [_ai_sdk_provider_utils__WEBPACK_IMPORTED_MODULE_1__.validatorSymbol]: true,\n        jsonSchema: jsonSchema2,\n        validate\n    };\n}\nfunction isSchema(value) {\n    return typeof value === \"object\" && value !== null && schemaSymbol in value && value[schemaSymbol] === true && \"jsonSchema\" in value && \"validate\" in value;\n}\nfunction asSchema(schema) {\n    return isSchema(schema) ? schema : zodSchema(schema);\n}\nfunction zodSchema(zodSchema2) {\n    return jsonSchema(// we assume that zodToJsonSchema will return a valid JSONSchema7:\n    (0,zod_to_json_schema__WEBPACK_IMPORTED_MODULE_2__[\"default\"])(zodSchema2), {\n        validate: (value)=>{\n            const result = zodSchema2.safeParse(value);\n            return result.success ? {\n                success: true,\n                value: result.data\n            } : {\n                success: false,\n                error: result.error\n            };\n        }\n    });\n}\n //# sourceMappingURL=index.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFpLXNkay91aS11dGlscy9kaXN0L2luZGV4Lm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSxlQUFlO0FBQ3FDO0FBRXBELHdDQUF3QztBQUNrQztBQUUxRSw0QkFBNEI7QUFDZTtBQUUzQyxrQkFBa0I7QUFDbEIsU0FBU0csUUFBUUMsS0FBSztJQUNwQixNQUFNQyxRQUFRO1FBQUM7S0FBTztJQUN0QixJQUFJQyxpQkFBaUIsQ0FBQztJQUN0QixJQUFJQyxlQUFlO0lBQ25CLFNBQVNDLGtCQUFrQkMsSUFBSSxFQUFFQyxDQUFDLEVBQUVDLFNBQVM7UUFDM0M7WUFDRSxPQUFRRjtnQkFDTixLQUFLO29CQUFLO3dCQUNSSCxpQkFBaUJJO3dCQUNqQkwsTUFBTU8sR0FBRzt3QkFDVFAsTUFBTVEsSUFBSSxDQUFDRjt3QkFDWE4sTUFBTVEsSUFBSSxDQUFDO3dCQUNYO29CQUNGO2dCQUNBLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO29CQUFLO3dCQUNSUCxpQkFBaUJJO3dCQUNqQkgsZUFBZUc7d0JBQ2ZMLE1BQU1PLEdBQUc7d0JBQ1RQLE1BQU1RLElBQUksQ0FBQ0Y7d0JBQ1hOLE1BQU1RLElBQUksQ0FBQzt3QkFDWDtvQkFDRjtnQkFDQSxLQUFLO29CQUFLO3dCQUNSUixNQUFNTyxHQUFHO3dCQUNUUCxNQUFNUSxJQUFJLENBQUNGO3dCQUNYTixNQUFNUSxJQUFJLENBQUM7d0JBQ1g7b0JBQ0Y7Z0JBQ0EsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztnQkFDTCxLQUFLO2dCQUNMLEtBQUs7Z0JBQ0wsS0FBSztvQkFBSzt3QkFDUlAsaUJBQWlCSTt3QkFDakJMLE1BQU1PLEdBQUc7d0JBQ1RQLE1BQU1RLElBQUksQ0FBQ0Y7d0JBQ1hOLE1BQU1RLElBQUksQ0FBQzt3QkFDWDtvQkFDRjtnQkFDQSxLQUFLO29CQUFLO3dCQUNSUCxpQkFBaUJJO3dCQUNqQkwsTUFBTU8sR0FBRzt3QkFDVFAsTUFBTVEsSUFBSSxDQUFDRjt3QkFDWE4sTUFBTVEsSUFBSSxDQUFDO3dCQUNYO29CQUNGO2dCQUNBLEtBQUs7b0JBQUs7d0JBQ1JQLGlCQUFpQkk7d0JBQ2pCTCxNQUFNTyxHQUFHO3dCQUNUUCxNQUFNUSxJQUFJLENBQUNGO3dCQUNYTixNQUFNUSxJQUFJLENBQUM7d0JBQ1g7b0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxTQUFTQyx3QkFBd0JMLElBQUksRUFBRUMsQ0FBQztRQUN0QyxPQUFRRDtZQUNOLEtBQUs7Z0JBQUs7b0JBQ1JKLE1BQU1PLEdBQUc7b0JBQ1RQLE1BQU1RLElBQUksQ0FBQztvQkFDWDtnQkFDRjtZQUNBLEtBQUs7Z0JBQUs7b0JBQ1JQLGlCQUFpQkk7b0JBQ2pCTCxNQUFNTyxHQUFHO29CQUNUO2dCQUNGO1FBQ0Y7SUFDRjtJQUNBLFNBQVNHLHVCQUF1Qk4sSUFBSSxFQUFFQyxDQUFDO1FBQ3JDLE9BQVFEO1lBQ04sS0FBSztnQkFBSztvQkFDUkosTUFBTU8sR0FBRztvQkFDVFAsTUFBTVEsSUFBSSxDQUFDO29CQUNYO2dCQUNGO1lBQ0EsS0FBSztnQkFBSztvQkFDUlAsaUJBQWlCSTtvQkFDakJMLE1BQU1PLEdBQUc7b0JBQ1Q7Z0JBQ0Y7UUFDRjtJQUNGO0lBQ0EsSUFBSyxJQUFJRixJQUFJLEdBQUdBLElBQUlOLE1BQU1ZLE1BQU0sRUFBRU4sSUFBSztRQUNyQyxNQUFNRCxPQUFPTCxLQUFLLENBQUNNLEVBQUU7UUFDckIsTUFBTU8sZUFBZVosS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRTtRQUM1QyxPQUFRQztZQUNOLEtBQUs7Z0JBQ0hULGtCQUFrQkMsTUFBTUMsR0FBRztnQkFDM0I7WUFDRixLQUFLO2dCQUF1QjtvQkFDMUIsT0FBUUQ7d0JBQ04sS0FBSzs0QkFBSztnQ0FDUkosTUFBTU8sR0FBRztnQ0FDVFAsTUFBTVEsSUFBSSxDQUFDO2dDQUNYOzRCQUNGO3dCQUNBLEtBQUs7NEJBQUs7Z0NBQ1JQLGlCQUFpQkk7Z0NBQ2pCTCxNQUFNTyxHQUFHO2dDQUNUOzRCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBNkI7b0JBQ2hDLE9BQVFIO3dCQUNOLEtBQUs7NEJBQUs7Z0NBQ1JKLE1BQU1PLEdBQUc7Z0NBQ1RQLE1BQU1RLElBQUksQ0FBQztnQ0FDWDs0QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNBLEtBQUs7Z0JBQXFCO29CQUN4QixPQUFRSjt3QkFDTixLQUFLOzRCQUFLO2dDQUNSSixNQUFNTyxHQUFHO2dDQUNUUCxNQUFNUSxJQUFJLENBQUM7Z0NBQ1g7NEJBQ0Y7b0JBQ0Y7b0JBQ0E7Z0JBQ0Y7WUFDQSxLQUFLO2dCQUEyQjtvQkFDOUIsT0FBUUo7d0JBQ04sS0FBSzs0QkFBSztnQ0FDUkosTUFBTU8sR0FBRztnQ0FDVFAsTUFBTVEsSUFBSSxDQUFDO2dDQUNYOzRCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBOEI7b0JBQ2pDTCxrQkFBa0JDLE1BQU1DLEdBQUc7b0JBQzNCO2dCQUNGO1lBQ0EsS0FBSztnQkFBNkI7b0JBQ2hDSSx3QkFBd0JMLE1BQU1DO29CQUM5QjtnQkFDRjtZQUNBLEtBQUs7Z0JBQWlCO29CQUNwQixPQUFRRDt3QkFDTixLQUFLOzRCQUFLO2dDQUNSSixNQUFNTyxHQUFHO2dDQUNUTixpQkFBaUJJO2dDQUNqQjs0QkFDRjt3QkFDQSxLQUFLOzRCQUFNO2dDQUNUTCxNQUFNUSxJQUFJLENBQUM7Z0NBQ1g7NEJBQ0Y7d0JBQ0E7NEJBQVM7Z0NBQ1BQLGlCQUFpQkk7NEJBQ25CO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBc0I7b0JBQ3pCLE9BQVFEO3dCQUNOLEtBQUs7NEJBQUs7Z0NBQ1JILGlCQUFpQkk7Z0NBQ2pCTCxNQUFNTyxHQUFHO2dDQUNUOzRCQUNGO3dCQUNBOzRCQUFTO2dDQUNQTixpQkFBaUJJO2dDQUNqQkYsa0JBQWtCQyxNQUFNQyxHQUFHO2dDQUMzQjs0QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNBLEtBQUs7Z0JBQTRCO29CQUMvQixPQUFRRDt3QkFDTixLQUFLOzRCQUFLO2dDQUNSSixNQUFNTyxHQUFHO2dDQUNUUCxNQUFNUSxJQUFJLENBQUM7Z0NBQ1g7NEJBQ0Y7d0JBQ0EsS0FBSzs0QkFBSztnQ0FDUlAsaUJBQWlCSTtnQ0FDakJMLE1BQU1PLEdBQUc7Z0NBQ1Q7NEJBQ0Y7d0JBQ0E7NEJBQVM7Z0NBQ1BOLGlCQUFpQkk7Z0NBQ2pCOzRCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBNEI7b0JBQy9CRixrQkFBa0JDLE1BQU1DLEdBQUc7b0JBQzNCO2dCQUNGO1lBQ0EsS0FBSztnQkFBd0I7b0JBQzNCTCxNQUFNTyxHQUFHO29CQUNUTixpQkFBaUJJO29CQUNqQjtnQkFDRjtZQUNBLEtBQUs7Z0JBQWlCO29CQUNwQixPQUFRRDt3QkFDTixLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLOzRCQUFLO2dDQUNSSCxpQkFBaUJJO2dDQUNqQjs0QkFDRjt3QkFDQSxLQUFLO3dCQUNMLEtBQUs7d0JBQ0wsS0FBSzt3QkFDTCxLQUFLOzRCQUFLO2dDQUNSOzRCQUNGO3dCQUNBLEtBQUs7NEJBQUs7Z0NBQ1JMLE1BQU1PLEdBQUc7Z0NBQ1QsSUFBSVAsS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRSxLQUFLLDRCQUE0QjtvQ0FDMURELHVCQUF1Qk4sTUFBTUM7Z0NBQy9CO2dDQUNBLElBQUlMLEtBQUssQ0FBQ0EsTUFBTVcsTUFBTSxHQUFHLEVBQUUsS0FBSyw2QkFBNkI7b0NBQzNERix3QkFBd0JMLE1BQU1DO2dDQUNoQztnQ0FDQTs0QkFDRjt3QkFDQSxLQUFLOzRCQUFLO2dDQUNSTCxNQUFNTyxHQUFHO2dDQUNULElBQUlQLEtBQUssQ0FBQ0EsTUFBTVcsTUFBTSxHQUFHLEVBQUUsS0FBSyw2QkFBNkI7b0NBQzNERix3QkFBd0JMLE1BQU1DO2dDQUNoQztnQ0FDQTs0QkFDRjt3QkFDQSxLQUFLOzRCQUFLO2dDQUNSTCxNQUFNTyxHQUFHO2dDQUNULElBQUlQLEtBQUssQ0FBQ0EsTUFBTVcsTUFBTSxHQUFHLEVBQUUsS0FBSyw0QkFBNEI7b0NBQzFERCx1QkFBdUJOLE1BQU1DO2dDQUMvQjtnQ0FDQTs0QkFDRjt3QkFDQTs0QkFBUztnQ0FDUEwsTUFBTU8sR0FBRztnQ0FDVDs0QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNBLEtBQUs7Z0JBQWtCO29CQUNyQixNQUFNTSxpQkFBaUJkLE1BQU1lLFNBQVMsQ0FBQ1osY0FBY0csSUFBSTtvQkFDekQsSUFBSSxDQUFDLFFBQVFVLFVBQVUsQ0FBQ0YsbUJBQW1CLENBQUMsT0FBT0UsVUFBVSxDQUFDRixtQkFBbUIsQ0FBQyxPQUFPRSxVQUFVLENBQUNGLGlCQUFpQjt3QkFDbkhiLE1BQU1PLEdBQUc7d0JBQ1QsSUFBSVAsS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRSxLQUFLLDZCQUE2Qjs0QkFDM0RGLHdCQUF3QkwsTUFBTUM7d0JBQ2hDLE9BQU8sSUFBSUwsS0FBSyxDQUFDQSxNQUFNVyxNQUFNLEdBQUcsRUFBRSxLQUFLLDRCQUE0Qjs0QkFDakVELHVCQUF1Qk4sTUFBTUM7d0JBQy9CO29CQUNGLE9BQU87d0JBQ0xKLGlCQUFpQkk7b0JBQ25CO29CQUNBO2dCQUNGO1FBQ0Y7SUFDRjtJQUNBLElBQUlXLFNBQVNqQixNQUFNa0IsS0FBSyxDQUFDLEdBQUdoQixpQkFBaUI7SUFDN0MsSUFBSyxJQUFJSSxJQUFJTCxNQUFNVyxNQUFNLEdBQUcsR0FBR04sS0FBSyxHQUFHQSxJQUFLO1FBQzFDLE1BQU1hLFFBQVFsQixLQUFLLENBQUNLLEVBQUU7UUFDdEIsT0FBUWE7WUFDTixLQUFLO2dCQUFpQjtvQkFDcEJGLFVBQVU7b0JBQ1Y7Z0JBQ0Y7WUFDQSxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztZQUNMLEtBQUs7Z0JBQTZCO29CQUNoQ0EsVUFBVTtvQkFDVjtnQkFDRjtZQUNBLEtBQUs7WUFDTCxLQUFLO1lBQ0wsS0FBSztnQkFBNEI7b0JBQy9CQSxVQUFVO29CQUNWO2dCQUNGO1lBQ0EsS0FBSztnQkFBa0I7b0JBQ3JCLE1BQU1ILGlCQUFpQmQsTUFBTWUsU0FBUyxDQUFDWixjQUFjSCxNQUFNWSxNQUFNO29CQUNqRSxJQUFJLE9BQU9JLFVBQVUsQ0FBQ0YsaUJBQWlCO3dCQUNyQ0csVUFBVSxPQUFPQyxLQUFLLENBQUNKLGVBQWVGLE1BQU07b0JBQzlDLE9BQU8sSUFBSSxRQUFRSSxVQUFVLENBQUNGLGlCQUFpQjt3QkFDN0NHLFVBQVUsUUFBUUMsS0FBSyxDQUFDSixlQUFlRixNQUFNO29CQUMvQyxPQUFPLElBQUksT0FBT0ksVUFBVSxDQUFDRixpQkFBaUI7d0JBQzVDRyxVQUFVLE9BQU9DLEtBQUssQ0FBQ0osZUFBZUYsTUFBTTtvQkFDOUM7Z0JBQ0Y7UUFDRjtJQUNGO0lBQ0EsT0FBT0s7QUFDVDtBQUVBLDRCQUE0QjtBQUM1QixTQUFTRyxpQkFBaUJDLFFBQVE7SUFDaEMsSUFBSUEsYUFBYSxLQUFLLEdBQUc7UUFDdkIsT0FBTztZQUFFQyxPQUFPLEtBQUs7WUFBR0gsT0FBTztRQUFrQjtJQUNuRDtJQUNBLElBQUk7UUFDRixPQUFPO1lBQ0xHLE9BQU94QixvREFBZ0IsQ0FBQ3VCO1lBQ3hCRixPQUFPO1FBQ1Q7SUFDRixFQUFFLE9BQU9LLFNBQVM7UUFDaEIsSUFBSTtZQUNGLE9BQU87Z0JBQ0xGLE9BQU94QixvREFBZ0IsQ0FBQ0MsUUFBUXNCO2dCQUNoQ0YsT0FBTztZQUNUO1FBQ0YsRUFBRSxPQUFPTSxVQUFVLENBQ25CO0lBQ0Y7SUFDQSxPQUFPO1FBQUVILE9BQU8sS0FBSztRQUFHSCxPQUFPO0lBQWU7QUFDaEQ7QUFFQSxzQkFBc0I7QUFDdEIsSUFBSU8saUJBQWlCO0lBQ25CQyxNQUFNO0lBQ05DLE1BQU07SUFDTkwsT0FBTyxDQUFDRDtRQUNOLElBQUksT0FBT0EsVUFBVSxVQUFVO1lBQzdCLE1BQU0sSUFBSU8sTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRUjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJUyx5QkFBeUI7SUFDM0JKLE1BQU07SUFDTkMsTUFBTTtJQUNOTCxPQUFPLENBQUNEO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLG9CQUFtQkEsS0FBSSxLQUFNLE9BQU9BLE1BQU1VLGFBQWEsS0FBSyxZQUFZVixNQUFNVSxhQUFhLElBQUksUUFBUSxDQUFFLFdBQVVWLE1BQU1VLGFBQWEsS0FBSyxDQUFFLGdCQUFlVixNQUFNVSxhQUFhLEtBQUssT0FBT1YsTUFBTVUsYUFBYSxDQUFDSixJQUFJLEtBQUssWUFBWSxPQUFPTixNQUFNVSxhQUFhLENBQUNDLFNBQVMsS0FBSyxVQUFVO1lBQ3pVLE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05SO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSVksaUJBQWlCO0lBQ25CUCxNQUFNO0lBQ05DLE1BQU07SUFDTkwsT0FBTyxDQUFDRDtRQUNOLElBQUksQ0FBQ2EsTUFBTUMsT0FBTyxDQUFDZCxRQUFRO1lBQ3pCLE1BQU0sSUFBSU8sTUFBTTtRQUNsQjtRQUNBLE9BQU87WUFBRUMsTUFBTTtZQUFRUjtRQUFNO0lBQy9CO0FBQ0Y7QUFDQSxJQUFJZSxrQkFBa0I7SUFDcEJWLE1BQU07SUFDTkMsTUFBTTtJQUNOTCxPQUFPLENBQUNEO1FBQ04sSUFBSSxPQUFPQSxVQUFVLFVBQVU7WUFDN0IsTUFBTSxJQUFJTyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQVNSO1FBQU07SUFDaEM7QUFDRjtBQUNBLElBQUlnQiw2QkFBNkI7SUFDL0JYLE1BQU07SUFDTkMsTUFBTTtJQUNOTCxPQUFPLENBQUNEO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLFNBQVFBLEtBQUksS0FBTSxDQUFFLFdBQVVBLEtBQUksS0FBTSxDQUFFLGNBQWFBLEtBQUksS0FBTSxPQUFPQSxNQUFNaUIsRUFBRSxLQUFLLFlBQVksT0FBT2pCLE1BQU1rQixJQUFJLEtBQUssWUFBWWxCLE1BQU1rQixJQUFJLEtBQUssZUFBZSxDQUFDTCxNQUFNQyxPQUFPLENBQUNkLE1BQU1tQixPQUFPLEtBQUssQ0FBQ25CLE1BQU1tQixPQUFPLENBQUNDLEtBQUssQ0FDeFEsQ0FBQ0MsT0FBU0EsUUFBUSxRQUFRLE9BQU9BLFNBQVMsWUFBWSxVQUFVQSxRQUFRQSxLQUFLYixJQUFJLEtBQUssVUFBVSxVQUFVYSxRQUFRQSxLQUFLQyxJQUFJLElBQUksUUFBUSxPQUFPRCxLQUFLQyxJQUFJLEtBQUssWUFBWSxXQUFXRCxLQUFLQyxJQUFJLElBQUksT0FBT0QsS0FBS0MsSUFBSSxDQUFDdEIsS0FBSyxLQUFLLFdBQzFOO1lBQ0QsTUFBTSxJQUFJTyxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTlI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJdUIsaUNBQWlDO0lBQ25DbEIsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsZUFBY0EsS0FBSSxLQUFNLENBQUUsZ0JBQWVBLEtBQUksS0FBTSxPQUFPQSxNQUFNd0IsUUFBUSxLQUFLLFlBQVksT0FBT3hCLE1BQU15QixTQUFTLEtBQUssVUFBVTtZQUNoTCxNQUFNLElBQUlsQixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTlIsT0FBTztnQkFDTHdCLFVBQVV4QixNQUFNd0IsUUFBUTtnQkFDeEJDLFdBQVd6QixNQUFNeUIsU0FBUztZQUM1QjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlDLHdCQUF3QjtJQUMxQnJCLE1BQU07SUFDTkMsTUFBTTtJQUNOTCxPQUFPLENBQUNEO1FBQ04sSUFBSUEsU0FBUyxRQUFRLE9BQU9BLFVBQVUsWUFBWSxDQUFFLFdBQVVBLEtBQUksS0FBTSxDQUFFLFdBQVVBLEtBQUksS0FBTSxPQUFPQSxNQUFNa0IsSUFBSSxLQUFLLFlBQVlsQixNQUFNa0IsSUFBSSxLQUFLLFFBQVE7WUFDckosTUFBTSxJQUFJWCxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTlI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJMkIsc0JBQXNCO0lBQ3hCdEIsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTTRCLFVBQVUsS0FBSyxZQUFZNUIsTUFBTTRCLFVBQVUsSUFBSSxRQUFRLENBQUNmLE1BQU1DLE9BQU8sQ0FBQ2QsTUFBTTRCLFVBQVUsS0FBSzVCLE1BQU00QixVQUFVLENBQUNDLElBQUksQ0FDek0sQ0FBQ0MsS0FBT0EsTUFBTSxRQUFRLE9BQU9BLE9BQU8sWUFBWSxDQUFFLFNBQVFBLEVBQUMsS0FBTSxPQUFPQSxHQUFHYixFQUFFLEtBQUssWUFBWSxDQUFFLFdBQVVhLEVBQUMsS0FBTSxPQUFPQSxHQUFHdEIsSUFBSSxLQUFLLFlBQVksQ0FBRSxlQUFjc0IsRUFBQyxLQUFNQSxHQUFHQyxRQUFRLElBQUksUUFBUSxPQUFPRCxHQUFHQyxRQUFRLEtBQUssWUFBWSxDQUFFLGdCQUFlRCxHQUFHQyxRQUFRLEtBQUssT0FBT0QsR0FBR0MsUUFBUSxDQUFDekIsSUFBSSxLQUFLLFlBQVksT0FBT3dCLEdBQUdDLFFBQVEsQ0FBQ3BCLFNBQVMsS0FBSyxXQUMxVTtZQUNELE1BQU0sSUFBSUosTUFDUjtRQUVKO1FBQ0EsT0FBTztZQUNMQyxNQUFNO1lBQ05SO1FBQ0Y7SUFDRjtBQUNGO0FBQ0EsSUFBSWdDLCtCQUErQjtJQUNqQzNCLE1BQU07SUFDTkMsTUFBTTtJQUNOTCxPQUFPLENBQUNEO1FBQ04sSUFBSSxDQUFDYSxNQUFNQyxPQUFPLENBQUNkLFFBQVE7WUFDekIsTUFBTSxJQUFJTyxNQUFNO1FBQ2xCO1FBQ0EsT0FBTztZQUFFQyxNQUFNO1lBQXVCUjtRQUFNO0lBQzlDO0FBQ0Y7QUFDQSxJQUFJaUMscUJBQXFCO0lBQ3ZCNUIsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTWtDLFVBQVUsS0FBSyxZQUFZLENBQUUsZUFBY2xDLEtBQUksS0FBTSxPQUFPQSxNQUFNbUMsUUFBUSxLQUFLLFlBQVksQ0FBRSxXQUFVbkMsS0FBSSxLQUFNLE9BQU9BLE1BQU1vQyxJQUFJLEtBQUssVUFBVTtZQUMxTyxNQUFNLElBQUk3QixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTlI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJcUMsdUJBQXVCO0lBQ3pCaEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTWtDLFVBQVUsS0FBSyxZQUFZLENBQUUsYUFBWWxDLEtBQUksR0FBSTtZQUMxSSxNQUFNLElBQUlPLE1BQ1I7UUFFSjtRQUNBLE9BQU87WUFDTEMsTUFBTTtZQUNOUjtRQUNGO0lBQ0Y7QUFDRjtBQUNBLElBQUlzQyxtQ0FBbUM7SUFDckNqQyxNQUFNO0lBQ05DLE1BQU07SUFDTkwsT0FBTyxDQUFDRDtRQUNOLElBQUlBLFNBQVMsUUFBUSxPQUFPQSxVQUFVLFlBQVksQ0FBRSxpQkFBZ0JBLEtBQUksS0FBTSxPQUFPQSxNQUFNa0MsVUFBVSxLQUFLLFlBQVksQ0FBRSxlQUFjbEMsS0FBSSxLQUFNLE9BQU9BLE1BQU1tQyxRQUFRLEtBQUssVUFBVTtZQUNsTCxNQUFNLElBQUk1QixNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTlI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJdUMsMEJBQTBCO0lBQzVCbEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsaUJBQWdCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTWtDLFVBQVUsS0FBSyxZQUFZLENBQUUsb0JBQW1CbEMsS0FBSSxLQUFNLE9BQU9BLE1BQU13QyxhQUFhLEtBQUssVUFBVTtZQUM1TCxNQUFNLElBQUlqQyxNQUNSO1FBRUo7UUFDQSxPQUFPO1lBQ0xDLE1BQU07WUFDTlI7UUFDRjtJQUNGO0FBQ0Y7QUFDQSxJQUFJeUMsMEJBQTBCO0lBQzVCcEMsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsbUJBQWtCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTTBDLFlBQVksS0FBSyxVQUFVO1lBQ3RILE1BQU0sSUFBSW5DLE1BQ1I7UUFFSjtRQUNBLE1BQU1aLFNBQVM7WUFDYitDLGNBQWMxQyxNQUFNMEMsWUFBWTtRQUNsQztRQUNBLElBQUksV0FBVzFDLFNBQVNBLE1BQU0yQyxLQUFLLElBQUksUUFBUSxPQUFPM0MsTUFBTTJDLEtBQUssS0FBSyxZQUFZLGtCQUFrQjNDLE1BQU0yQyxLQUFLLElBQUksc0JBQXNCM0MsTUFBTTJDLEtBQUssRUFBRTtZQUNwSmhELE9BQU9nRCxLQUFLLEdBQUc7Z0JBQ2JDLGNBQWMsT0FBTzVDLE1BQU0yQyxLQUFLLENBQUNDLFlBQVksS0FBSyxXQUFXNUMsTUFBTTJDLEtBQUssQ0FBQ0MsWUFBWSxHQUFHQyxPQUFPQyxHQUFHO2dCQUNsR0Msa0JBQWtCLE9BQU8vQyxNQUFNMkMsS0FBSyxDQUFDSSxnQkFBZ0IsS0FBSyxXQUFXL0MsTUFBTTJDLEtBQUssQ0FBQ0ksZ0JBQWdCLEdBQUdGLE9BQU9DLEdBQUc7WUFDaEg7UUFDRjtRQUNBLE9BQU87WUFDTHRDLE1BQU07WUFDTlIsT0FBT0w7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxJQUFJcUQsdUJBQXVCO0lBQ3pCM0MsTUFBTTtJQUNOQyxNQUFNO0lBQ05MLE9BQU8sQ0FBQ0Q7UUFDTixJQUFJQSxTQUFTLFFBQVEsT0FBT0EsVUFBVSxZQUFZLENBQUUsbUJBQWtCQSxLQUFJLEtBQU0sT0FBT0EsTUFBTTBDLFlBQVksS0FBSyxVQUFVO1lBQ3RILE1BQU0sSUFBSW5DLE1BQ1I7UUFFSjtRQUNBLE1BQU1aLFNBQVM7WUFDYitDLGNBQWMxQyxNQUFNMEMsWUFBWTtZQUNoQ08sYUFBYTtRQUNmO1FBQ0EsSUFBSSxXQUFXakQsU0FBU0EsTUFBTTJDLEtBQUssSUFBSSxRQUFRLE9BQU8zQyxNQUFNMkMsS0FBSyxLQUFLLFlBQVksa0JBQWtCM0MsTUFBTTJDLEtBQUssSUFBSSxzQkFBc0IzQyxNQUFNMkMsS0FBSyxFQUFFO1lBQ3BKaEQsT0FBT2dELEtBQUssR0FBRztnQkFDYkMsY0FBYyxPQUFPNUMsTUFBTTJDLEtBQUssQ0FBQ0MsWUFBWSxLQUFLLFdBQVc1QyxNQUFNMkMsS0FBSyxDQUFDQyxZQUFZLEdBQUdDLE9BQU9DLEdBQUc7Z0JBQ2xHQyxrQkFBa0IsT0FBTy9DLE1BQU0yQyxLQUFLLENBQUNJLGdCQUFnQixLQUFLLFdBQVcvQyxNQUFNMkMsS0FBSyxDQUFDSSxnQkFBZ0IsR0FBR0YsT0FBT0MsR0FBRztZQUNoSDtRQUNGO1FBQ0EsSUFBSSxpQkFBaUI5QyxTQUFTLE9BQU9BLE1BQU1pRCxXQUFXLEtBQUssV0FBVztZQUNwRXRELE9BQU9zRCxXQUFXLEdBQUdqRCxNQUFNaUQsV0FBVztRQUN4QztRQUNBLE9BQU87WUFDTHpDLE1BQU07WUFDTlIsT0FBT0w7UUFDVDtJQUNGO0FBQ0Y7QUFDQSxJQUFJdUQsY0FBYztJQUNoQjlDO0lBQ0FLO0lBQ0FHO0lBQ0FHO0lBQ0FDO0lBQ0FPO0lBQ0FHO0lBQ0FDO0lBQ0FLO0lBQ0FDO0lBQ0FJO0lBQ0FDO0lBQ0FDO0lBQ0FFO0lBQ0FPO0NBQ0Q7QUFDRCxJQUFJRyxvQkFBb0I7SUFDdEIsQ0FBQy9DLGVBQWVDLElBQUksQ0FBQyxFQUFFRDtJQUN2QixDQUFDSyx1QkFBdUJKLElBQUksQ0FBQyxFQUFFSTtJQUMvQixDQUFDRyxlQUFlUCxJQUFJLENBQUMsRUFBRU87SUFDdkIsQ0FBQ0csZ0JBQWdCVixJQUFJLENBQUMsRUFBRVU7SUFDeEIsQ0FBQ0MsMkJBQTJCWCxJQUFJLENBQUMsRUFBRVc7SUFDbkMsQ0FBQ08sK0JBQStCbEIsSUFBSSxDQUFDLEVBQUVrQjtJQUN2QyxDQUFDRyxzQkFBc0JyQixJQUFJLENBQUMsRUFBRXFCO0lBQzlCLENBQUNDLG9CQUFvQnRCLElBQUksQ0FBQyxFQUFFc0I7SUFDNUIsQ0FBQ0ssNkJBQTZCM0IsSUFBSSxDQUFDLEVBQUUyQjtJQUNyQyxDQUFDQyxtQkFBbUI1QixJQUFJLENBQUMsRUFBRTRCO0lBQzNCLENBQUNJLHFCQUFxQmhDLElBQUksQ0FBQyxFQUFFZ0M7SUFDN0IsQ0FBQ0MsaUNBQWlDakMsSUFBSSxDQUFDLEVBQUVpQztJQUN6QyxDQUFDQyx3QkFBd0JsQyxJQUFJLENBQUMsRUFBRWtDO0lBQ2hDLENBQUNFLHdCQUF3QnBDLElBQUksQ0FBQyxFQUFFb0M7SUFDaEMsQ0FBQ08scUJBQXFCM0MsSUFBSSxDQUFDLEVBQUUyQztBQUMvQjtBQUNBLElBQUlJLHVCQUF1QjtJQUN6QixDQUFDaEQsZUFBZUUsSUFBSSxDQUFDLEVBQUVGLGVBQWVDLElBQUk7SUFDMUMsQ0FBQ0ksdUJBQXVCSCxJQUFJLENBQUMsRUFBRUcsdUJBQXVCSixJQUFJO0lBQzFELENBQUNPLGVBQWVOLElBQUksQ0FBQyxFQUFFTSxlQUFlUCxJQUFJO0lBQzFDLENBQUNVLGdCQUFnQlQsSUFBSSxDQUFDLEVBQUVTLGdCQUFnQlYsSUFBSTtJQUM1QyxDQUFDVywyQkFBMkJWLElBQUksQ0FBQyxFQUFFVSwyQkFBMkJYLElBQUk7SUFDbEUsQ0FBQ2tCLCtCQUErQmpCLElBQUksQ0FBQyxFQUFFaUIsK0JBQStCbEIsSUFBSTtJQUMxRSxDQUFDcUIsc0JBQXNCcEIsSUFBSSxDQUFDLEVBQUVvQixzQkFBc0JyQixJQUFJO0lBQ3hELENBQUNzQixvQkFBb0JyQixJQUFJLENBQUMsRUFBRXFCLG9CQUFvQnRCLElBQUk7SUFDcEQsQ0FBQzJCLDZCQUE2QjFCLElBQUksQ0FBQyxFQUFFMEIsNkJBQTZCM0IsSUFBSTtJQUN0RSxDQUFDNEIsbUJBQW1CM0IsSUFBSSxDQUFDLEVBQUUyQixtQkFBbUI1QixJQUFJO0lBQ2xELENBQUNnQyxxQkFBcUIvQixJQUFJLENBQUMsRUFBRStCLHFCQUFxQmhDLElBQUk7SUFDdEQsQ0FBQ2lDLGlDQUFpQ2hDLElBQUksQ0FBQyxFQUFFZ0MsaUNBQWlDakMsSUFBSTtJQUM5RSxDQUFDa0Msd0JBQXdCakMsSUFBSSxDQUFDLEVBQUVpQyx3QkFBd0JsQyxJQUFJO0lBQzVELENBQUNvQyx3QkFBd0JuQyxJQUFJLENBQUMsRUFBRW1DLHdCQUF3QnBDLElBQUk7SUFDNUQsQ0FBQzJDLHFCQUFxQjFDLElBQUksQ0FBQyxFQUFFMEMscUJBQXFCM0MsSUFBSTtBQUN4RDtBQUNBLElBQUlnRCxhQUFhSCxZQUFZSSxHQUFHLENBQUMsQ0FBQ0MsT0FBU0EsS0FBS2xELElBQUk7QUFDcEQsSUFBSW1ELGtCQUFrQixDQUFDQztJQUNyQixNQUFNQyxzQkFBc0JELEtBQUtFLE9BQU8sQ0FBQztJQUN6QyxJQUFJRCx3QkFBd0IsQ0FBQyxHQUFHO1FBQzlCLE1BQU0sSUFBSW5ELE1BQU07SUFDbEI7SUFDQSxNQUFNcUQsU0FBU0gsS0FBSzdELEtBQUssQ0FBQyxHQUFHOEQ7SUFDN0IsSUFBSSxDQUFDTCxXQUFXUSxRQUFRLENBQUNELFNBQVM7UUFDaEMsTUFBTSxJQUFJckQsTUFBTSxDQUFDLDRDQUE0QyxFQUFFcUQsT0FBTyxDQUFDLENBQUM7SUFDMUU7SUFDQSxNQUFNdkQsT0FBT3VEO0lBQ2IsTUFBTUUsWUFBWUwsS0FBSzdELEtBQUssQ0FBQzhELHNCQUFzQjtJQUNuRCxNQUFNSyxZQUFZQyxLQUFLL0QsS0FBSyxDQUFDNkQ7SUFDN0IsT0FBT1gsaUJBQWlCLENBQUM5QyxLQUFLLENBQUNKLEtBQUssQ0FBQzhEO0FBQ3ZDO0FBQ0EsU0FBU0UsaUJBQWlCekQsSUFBSSxFQUFFUixLQUFLO0lBQ25DLE1BQU1rRSxhQUFhaEIsWUFBWWlCLElBQUksQ0FBQyxDQUFDWixPQUFTQSxLQUFLakQsSUFBSSxLQUFLRTtJQUM1RCxJQUFJLENBQUMwRCxZQUFZO1FBQ2YsTUFBTSxJQUFJM0QsTUFBTSxDQUFDLDBCQUEwQixFQUFFQyxLQUFLLENBQUM7SUFDckQ7SUFDQSxPQUFPLENBQUMsRUFBRTBELFdBQVc3RCxJQUFJLENBQUMsQ0FBQyxFQUFFMkQsS0FBS0ksU0FBUyxDQUFDcEUsT0FBTztBQUNyRCxDQUFDO0FBQ0Q7QUFFQSwwQkFBMEI7QUFDMUIsSUFBSXFFLFVBQVUsS0FBS0MsVUFBVSxDQUFDO0FBQzlCLFNBQVNDLGFBQWFDLE1BQU0sRUFBRUMsV0FBVztJQUN2QyxNQUFNQyxxQkFBcUIsSUFBSUMsV0FBV0Y7SUFDMUMsSUFBSUcsU0FBUztJQUNiLEtBQUssTUFBTUMsU0FBU0wsT0FBUTtRQUMxQkUsbUJBQW1CSSxHQUFHLENBQUNELE9BQU9EO1FBQzlCQSxVQUFVQyxNQUFNdkYsTUFBTTtJQUN4QjtJQUNBa0YsT0FBT2xGLE1BQU0sR0FBRztJQUNoQixPQUFPb0Y7QUFDVDtBQUNBLGdCQUFnQkssZUFBZUMsTUFBTSxFQUFFLEVBQ3JDQyxTQUFTLEVBQ1YsR0FBRyxDQUFDLENBQUM7SUFDSixNQUFNQyxVQUFVLElBQUlDO0lBQ3BCLE1BQU1YLFNBQVMsRUFBRTtJQUNqQixJQUFJQyxjQUFjO0lBQ2xCLE1BQU8sS0FBTTtRQUNYLE1BQU0sRUFBRXpFLEtBQUssRUFBRSxHQUFHLE1BQU1nRixPQUFPSSxJQUFJO1FBQ25DLElBQUlwRixPQUFPO1lBQ1R3RSxPQUFPckYsSUFBSSxDQUFDYTtZQUNaeUUsZUFBZXpFLE1BQU1WLE1BQU07WUFDM0IsSUFBSVUsS0FBSyxDQUFDQSxNQUFNVixNQUFNLEdBQUcsRUFBRSxLQUFLK0UsU0FBUztnQkFDdkM7WUFDRjtRQUNGO1FBQ0EsSUFBSUcsT0FBT2xGLE1BQU0sS0FBSyxHQUFHO1lBQ3ZCO1FBQ0Y7UUFDQSxNQUFNb0YscUJBQXFCSCxhQUFhQyxRQUFRQztRQUNoREEsY0FBYztRQUNkLE1BQU1ZLGVBQWVILFFBQVFJLE1BQU0sQ0FBQ1osb0JBQW9CO1lBQUVhLFFBQVE7UUFBSyxHQUFHQyxLQUFLLENBQUMsTUFBTUMsTUFBTSxDQUFDLENBQUNoQyxPQUFTQSxTQUFTLElBQUlILEdBQUcsQ0FBQ0U7UUFDeEgsS0FBSyxNQUFNVSxjQUFjbUIsYUFBYztZQUNyQyxNQUFNbkI7UUFDUjtRQUNBLElBQUllLGFBQWEsT0FBTyxLQUFLLElBQUlBLGFBQWE7WUFDNUNELE9BQU9VLE1BQU07WUFDYjtRQUNGO0lBQ0Y7QUFDRjtBQUVBLHdDQUF3QztBQUN4QyxTQUFTQywyQkFBMkJDLE9BQU8sRUFBRUMsV0FBVztJQUN0RCxJQUFJLENBQUNELFdBQVcsQ0FBQ0MsZUFBZSxDQUFDQSxZQUFZdkcsTUFBTSxFQUNqRCxPQUFPc0c7SUFDVCxPQUFPO1FBQUUsR0FBR0EsT0FBTztRQUFFQyxhQUFhO2VBQUlBO1NBQVk7SUFBQztBQUNyRDtBQUNBLGVBQWVDLDRCQUE0QixFQUN6Q2QsTUFBTSxFQUNOZSxrQkFBa0IsRUFDbEJDLE1BQU0sRUFDTkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1I1SCxZQUFZNkgsY0FBYzVILDhEQUFrQixFQUM1QzZILGlCQUFpQixJQUFNLGFBQWEsR0FBRyxJQUFJQyxNQUFNLEVBQ2xEO0lBQ0MsSUFBSUM7SUFDSixNQUFNQyxZQUFZSDtJQUNsQixJQUFJSSxZQUFZLENBQUM7SUFDakIsSUFBSUMsZ0JBQWdCLEtBQUs7SUFDekIsTUFBTUMsbUJBQW1CLEVBQUU7SUFDM0IsTUFBTUMsT0FBTyxFQUFFO0lBQ2YsSUFBSUMscUJBQXFCLEtBQUs7SUFDOUIsTUFBTUMsbUJBQW1CLENBQUM7SUFDMUIsSUFBSWxFLFFBQVE7UUFDVkksa0JBQWtCRDtRQUNsQkYsY0FBY0U7UUFDZGdFLGFBQWFoRTtJQUNmO0lBQ0EsSUFBSUosZUFBZTtJQUNuQixXQUFXLE1BQU0sRUFBRWxDLElBQUksRUFBRVIsS0FBSyxFQUFFLElBQUkrRSxlQUFlQyxRQUFRO1FBQ3pEQyxXQUFXLElBQU0sQ0FBQ2Msc0JBQXNCLE9BQU8sS0FBSyxJQUFJQSxtQkFBbUJnQixPQUFPLE1BQU07SUFDMUYsR0FBSTtRQUNGLElBQUl2RyxTQUFTLFNBQVM7WUFDcEIsTUFBTSxJQUFJRCxNQUFNUDtRQUNsQjtRQUNBLElBQUlRLFNBQVMsZUFBZTtZQUMxQixJQUFJLENBQUNSLE1BQU1pRCxXQUFXLEVBQUU7Z0JBQ3RCd0QsZ0JBQWdCLENBQUM7WUFDbkI7WUFDQTtRQUNGO1FBQ0EsSUFBSWpHLFNBQVMsa0JBQWtCO1lBQzdCa0MsZUFBZTFDLE1BQU0wQyxZQUFZO1lBQ2pDLElBQUkxQyxNQUFNMkMsS0FBSyxJQUFJLE1BQU07Z0JBQ3ZCLE1BQU0sRUFBRUksZ0JBQWdCLEVBQUVILFlBQVksRUFBRSxHQUFHNUMsTUFBTTJDLEtBQUs7Z0JBQ3REQSxRQUFRO29CQUNOSTtvQkFDQUg7b0JBQ0FrRSxhQUFhL0QsbUJBQW1CSDtnQkFDbEM7WUFDRjtZQUNBO1FBQ0Y7UUFDQSxJQUFJNkQsaUJBQWlCLFFBQVNqRyxDQUFBQSxTQUFTLFVBQVVBLFNBQVMsZUFBZUEsU0FBUywrQkFBK0JBLFNBQVMscUJBQXFCQSxTQUFTLGFBQVksR0FBSTtZQUN0SyxJQUFJZ0csVUFBVWxGLElBQUksRUFBRTtnQkFDbEJvRixpQkFBaUJ2SCxJQUFJLENBQUNxSCxVQUFVbEYsSUFBSTtZQUN0QztZQUNBLElBQUlrRixVQUFVOUYsYUFBYSxFQUFFO2dCQUMzQmdHLGlCQUFpQnZILElBQUksQ0FBQ3FILFVBQVU5RixhQUFhO1lBQy9DO1lBQ0EsSUFBSThGLFVBQVU1RSxVQUFVLEVBQUU7Z0JBQ3hCOEUsaUJBQWlCdkgsSUFBSSxDQUFDcUgsVUFBVTVFLFVBQVU7WUFDNUM7WUFDQTRFLFlBQVlDO1lBQ1pBLGdCQUFnQixLQUFLO1FBQ3ZCO1FBQ0EsSUFBSWpHLFNBQVMsUUFBUTtZQUNuQixJQUFJZ0csU0FBUyxDQUFDLE9BQU8sRUFBRTtnQkFDckJBLFNBQVMsQ0FBQyxPQUFPLEdBQUc7b0JBQ2xCLEdBQUdBLFNBQVMsQ0FBQyxPQUFPO29CQUNwQnJGLFNBQVMsQ0FBQ3FGLFNBQVMsQ0FBQyxPQUFPLENBQUNyRixPQUFPLElBQUksRUFBQyxJQUFLbkI7Z0JBQy9DO1lBQ0YsT0FBTztnQkFDTHdHLFNBQVMsQ0FBQyxPQUFPLEdBQUc7b0JBQ2xCdkYsSUFBSWtGO29CQUNKakYsTUFBTTtvQkFDTkMsU0FBU25CO29CQUNUdUc7Z0JBQ0Y7WUFDRjtRQUNGO1FBQ0EsSUFBSS9GLFNBQVMsNkJBQTZCO1lBQ3hDLElBQUlnRyxVQUFVbEYsSUFBSSxJQUFJLE1BQU07Z0JBQzFCa0YsVUFBVWxGLElBQUksR0FBRztvQkFDZkwsSUFBSWtGO29CQUNKakYsTUFBTTtvQkFDTkMsU0FBUztvQkFDVG9GO2dCQUNGO1lBQ0Y7WUFDQSxJQUFJQyxVQUFVbEYsSUFBSSxDQUFDMEYsZUFBZSxJQUFJLE1BQU07Z0JBQzFDUixVQUFVbEYsSUFBSSxDQUFDMEYsZUFBZSxHQUFHLEVBQUU7WUFDckM7WUFDQUgsZ0JBQWdCLENBQUM3RyxNQUFNa0MsVUFBVSxDQUFDLEdBQUc7Z0JBQ25DWixNQUFNO2dCQUNOYSxVQUFVbkMsTUFBTW1DLFFBQVE7Z0JBQ3hCOEUsZ0JBQWdCVCxVQUFVbEYsSUFBSSxDQUFDMEYsZUFBZSxDQUFDMUgsTUFBTTtZQUN2RDtZQUNBa0gsVUFBVWxGLElBQUksQ0FBQzBGLGVBQWUsQ0FBQzdILElBQUksQ0FBQztnQkFDbENVLE9BQU87Z0JBQ1BxQyxZQUFZbEMsTUFBTWtDLFVBQVU7Z0JBQzVCQyxVQUFVbkMsTUFBTW1DLFFBQVE7Z0JBQ3hCQyxNQUFNLEtBQUs7WUFDYjtRQUNGLE9BQU8sSUFBSTVCLFNBQVMsbUJBQW1CO1lBQ3JDLE1BQU0wRyxrQkFBa0JMLGdCQUFnQixDQUFDN0csTUFBTWtDLFVBQVUsQ0FBQztZQUMxRGdGLGdCQUFnQjVGLElBQUksSUFBSXRCLE1BQU13QyxhQUFhO1lBQzNDLE1BQU0sRUFBRXhDLE9BQU9tSCxXQUFXLEVBQUUsR0FBR3JILGlCQUFpQm9ILGdCQUFnQjVGLElBQUk7WUFDcEVrRixVQUFVbEYsSUFBSSxDQUFDMEYsZUFBZSxDQUFDRSxnQkFBZ0JELGNBQWMsQ0FBQyxHQUFHO2dCQUMvRHBILE9BQU87Z0JBQ1BxQyxZQUFZbEMsTUFBTWtDLFVBQVU7Z0JBQzVCQyxVQUFVK0UsZ0JBQWdCL0UsUUFBUTtnQkFDbENDLE1BQU0rRTtZQUNSO1lBQ0FYLFVBQVVsRixJQUFJLENBQUM4RixnQkFBZ0IsR0FBR2pCO1FBQ3BDLE9BQU8sSUFBSTNGLFNBQVMsYUFBYTtZQUMvQixJQUFJcUcsZ0JBQWdCLENBQUM3RyxNQUFNa0MsVUFBVSxDQUFDLElBQUksTUFBTTtnQkFDOUNzRSxVQUFVbEYsSUFBSSxDQUFDMEYsZUFBZSxDQUFDSCxnQkFBZ0IsQ0FBQzdHLE1BQU1rQyxVQUFVLENBQUMsQ0FBQytFLGNBQWMsQ0FBQyxHQUFHO29CQUFFcEgsT0FBTztvQkFBUSxHQUFHRyxLQUFLO2dCQUFDO1lBQ2hILE9BQU87Z0JBQ0wsSUFBSXdHLFVBQVVsRixJQUFJLElBQUksTUFBTTtvQkFDMUJrRixVQUFVbEYsSUFBSSxHQUFHO3dCQUNmTCxJQUFJa0Y7d0JBQ0pqRixNQUFNO3dCQUNOQyxTQUFTO3dCQUNUb0Y7b0JBQ0Y7Z0JBQ0Y7Z0JBQ0EsSUFBSUMsVUFBVWxGLElBQUksQ0FBQzBGLGVBQWUsSUFBSSxNQUFNO29CQUMxQ1IsVUFBVWxGLElBQUksQ0FBQzBGLGVBQWUsR0FBRyxFQUFFO2dCQUNyQztnQkFDQVIsVUFBVWxGLElBQUksQ0FBQzBGLGVBQWUsQ0FBQzdILElBQUksQ0FBQztvQkFDbENVLE9BQU87b0JBQ1AsR0FBR0csS0FBSztnQkFDVjtZQUNGO1lBQ0F3RyxVQUFVbEYsSUFBSSxDQUFDOEYsZ0JBQWdCLEdBQUdqQjtZQUNsQyxJQUFJRixZQUFZO2dCQUNkLE1BQU10RyxTQUFTLE1BQU1zRyxXQUFXO29CQUFFb0IsVUFBVXJIO2dCQUFNO2dCQUNsRCxJQUFJTCxVQUFVLE1BQU07b0JBQ2xCNkcsVUFBVWxGLElBQUksQ0FBQzBGLGVBQWUsQ0FBQ1IsVUFBVWxGLElBQUksQ0FBQzBGLGVBQWUsQ0FBQzFILE1BQU0sR0FBRyxFQUFFLEdBQUc7d0JBQUVPLE9BQU87d0JBQVUsR0FBR0csS0FBSzt3QkFBRUw7b0JBQU87Z0JBQ2xIO1lBQ0Y7UUFDRixPQUFPLElBQUlhLFNBQVMsZUFBZTtZQUNqQyxNQUFNd0csa0JBQWtCLENBQUNWLEtBQUtFLFVBQVVsRixJQUFJLEtBQUssT0FBTyxLQUFLLElBQUlnRixHQUFHVSxlQUFlO1lBQ25GLElBQUlBLG1CQUFtQixNQUFNO2dCQUMzQixNQUFNLElBQUl6RyxNQUFNO1lBQ2xCO1lBQ0EsTUFBTStHLHNCQUFzQk4sZ0JBQWdCTyxTQUFTLENBQ25ELENBQUNDLGFBQWVBLFdBQVd0RixVQUFVLEtBQUtsQyxNQUFNa0MsVUFBVTtZQUU1RCxJQUFJb0Ysd0JBQXdCLENBQUMsR0FBRztnQkFDOUIsTUFBTSxJQUFJL0csTUFDUjtZQUVKO1lBQ0F5RyxlQUFlLENBQUNNLG9CQUFvQixHQUFHO2dCQUNyQyxHQUFHTixlQUFlLENBQUNNLG9CQUFvQjtnQkFDdkN6SCxPQUFPO2dCQUNQLEdBQUdHLEtBQUs7WUFDVjtRQUNGO1FBQ0EsSUFBSXlILHNCQUFzQjtRQUMxQixJQUFJakgsU0FBUyxpQkFBaUI7WUFDNUJnRyxTQUFTLENBQUMsZ0JBQWdCLEdBQUc7Z0JBQzNCdkYsSUFBSWtGO2dCQUNKakYsTUFBTTtnQkFDTkMsU0FBUztnQkFDVFQsZUFBZVYsTUFBTVUsYUFBYTtnQkFDbENKLE1BQU1OLE1BQU1VLGFBQWEsQ0FBQ0osSUFBSTtnQkFDOUJpRztZQUNGO1lBQ0FrQixzQkFBc0JqQixTQUFTLENBQUMsZ0JBQWdCO1FBQ2xEO1FBQ0EsSUFBSWtCLGtCQUFrQjtRQUN0QixJQUFJbEgsU0FBUyxjQUFjO1lBQ3pCZ0csU0FBUyxDQUFDLGFBQWEsR0FBRztnQkFDeEJ2RixJQUFJa0Y7Z0JBQ0pqRixNQUFNO2dCQUNOQyxTQUFTO2dCQUNUUyxZQUFZNUIsTUFBTTRCLFVBQVU7Z0JBQzVCMkU7WUFDRjtZQUNBbUIsa0JBQWtCbEIsU0FBUyxDQUFDLGFBQWE7UUFDM0M7UUFDQSxJQUFJaEcsU0FBUyxRQUFRO1lBQ25CbUcsS0FBS3hILElBQUksSUFBSWE7UUFDZjtRQUNBLElBQUkySCxrQkFBa0JuQixTQUFTLENBQUMsT0FBTztRQUN2QyxJQUFJaEcsU0FBUyx1QkFBdUI7WUFDbEMsSUFBSSxDQUFDb0csb0JBQW9CO2dCQUN2QkEscUJBQXFCO3VCQUFJNUc7aUJBQU07WUFDakMsT0FBTztnQkFDTDRHLG1CQUFtQnpILElBQUksSUFBSWE7WUFDN0I7WUFDQXlILHNCQUFzQjlCLDJCQUNwQmEsU0FBUyxDQUFDLGdCQUFnQixFQUMxQkk7WUFFRmMsa0JBQWtCL0IsMkJBQ2hCYSxTQUFTLENBQUMsYUFBYSxFQUN2Qkk7WUFFRmUsa0JBQWtCaEMsMkJBQ2hCYSxTQUFTLENBQUMsT0FBTyxFQUNqQkk7WUFFRixJQUFJSixVQUFVbEYsSUFBSSxJQUFJLE1BQU07Z0JBQzFCa0YsVUFBVWxGLElBQUksQ0FBQzhGLGdCQUFnQixHQUFHakI7WUFDcEM7UUFDRjtRQUNBLElBQUlTLHNCQUFzQixPQUFPLEtBQUssSUFBSUEsbUJBQW1CdEgsTUFBTSxFQUFFO1lBQ25FLElBQUlrSCxVQUFVbEYsSUFBSSxFQUFFO2dCQUNsQmtGLFVBQVVsRixJQUFJLENBQUN1RSxXQUFXLEdBQUc7dUJBQUllO2lCQUFtQjtZQUN0RDtZQUNBLElBQUlKLFVBQVU5RixhQUFhLEVBQUU7Z0JBQzNCOEYsVUFBVTlGLGFBQWEsQ0FBQ21GLFdBQVcsR0FBRzt1QkFBSWU7aUJBQW1CO1lBQy9EO1lBQ0EsSUFBSUosVUFBVTVFLFVBQVUsRUFBRTtnQkFDeEI0RSxVQUFVNUUsVUFBVSxDQUFDaUUsV0FBVyxHQUFHO3VCQUFJZTtpQkFBbUI7WUFDNUQ7UUFDRjtRQUNBLE1BQU1nQixTQUFTO1lBQUNIO1lBQXFCQztZQUFpQkM7U0FBZ0IsQ0FBQ2xDLE1BQU0sQ0FBQ29DLFNBQVN2RSxHQUFHLENBQUMsQ0FBQ3NDLFVBQWE7Z0JBQ3ZHLEdBQUdELDJCQUEyQkMsU0FBU2dCLG1CQUFtQjtZQUM1RDtRQUNBWixPQUFPO2VBQUlVO2VBQXFCa0I7U0FBTyxFQUFFO2VBQUlqQjtTQUFLO0lBQ3BEO0lBQ0FULFlBQVksT0FBTyxLQUFLLElBQUlBLFNBQVM7UUFBRU4sU0FBU1ksVUFBVWxGLElBQUk7UUFBRW9CO1FBQWNDO0lBQU07SUFDcEYsT0FBTztRQUNMbUYsVUFBVTtZQUNSdEIsVUFBVWxGLElBQUk7WUFDZGtGLFVBQVU5RixhQUFhO1lBQ3ZCOEYsVUFBVTVFLFVBQVU7U0FDckIsQ0FBQzZELE1BQU0sQ0FBQ29DO1FBQ1RsQjtJQUNGO0FBQ0Y7QUFFQSx1QkFBdUI7QUFDdkIsSUFBSW9CLG1CQUFtQixJQUFNQztBQUM3QixlQUFlQyxZQUFZLEVBQ3pCQyxHQUFHLEVBQ0hDLElBQUksRUFDSkMsaUJBQWlCLE1BQU0sRUFDdkJDLFdBQVcsRUFDWEMsT0FBTyxFQUNQQyxlQUFlLEVBQ2ZDLHdCQUF3QixFQUN4QkMsVUFBVSxFQUNWQyxRQUFRLEVBQ1J4QyxRQUFRLEVBQ1JELFVBQVUsRUFDVjNILFlBQVk2SCxXQUFXLEVBQ3ZCNkIsT0FBT1csU0FBU1osa0JBQWtCLEVBQ25DO0lBQ0MsSUFBSXpCLElBQUlzQztJQUNSLE1BQU1DLFdBQVcsTUFBTUYsT0FBT1QsS0FBSztRQUNqQ1ksUUFBUTtRQUNSWCxNQUFNbkUsS0FBS0ksU0FBUyxDQUFDK0Q7UUFDckJHLFNBQVM7WUFDUCxnQkFBZ0I7WUFDaEIsR0FBR0EsT0FBTztRQUNaO1FBQ0FTLFFBQVEsQ0FBQ3pDLEtBQUtpQyxtQkFBbUIsT0FBTyxLQUFLLElBQUlBLGlCQUFnQixLQUFNLE9BQU8sS0FBSyxJQUFJakMsR0FBR3lDLE1BQU07UUFDaEdWO0lBQ0YsR0FBR1csS0FBSyxDQUFDLENBQUNDO1FBQ1JUO1FBQ0EsTUFBTVM7SUFDUjtJQUNBLElBQUlSLFlBQVk7UUFDZCxJQUFJO1lBQ0YsTUFBTUEsV0FBV0k7UUFDbkIsRUFBRSxPQUFPSSxLQUFLO1lBQ1osTUFBTUE7UUFDUjtJQUNGO0lBQ0EsSUFBSSxDQUFDSixTQUFTSyxFQUFFLEVBQUU7UUFDaEJWO1FBQ0EsTUFBTSxJQUFJakksTUFDUixDQUFDcUksS0FBSyxNQUFNQyxTQUFTdkgsSUFBSSxFQUFDLEtBQU0sT0FBT3NILEtBQUs7SUFFaEQ7SUFDQSxJQUFJLENBQUNDLFNBQVNWLElBQUksRUFBRTtRQUNsQixNQUFNLElBQUk1SCxNQUFNO0lBQ2xCO0lBQ0EsTUFBTXlFLFNBQVM2RCxTQUFTVixJQUFJLENBQUNnQixTQUFTO0lBQ3RDLE9BQVFmO1FBQ04sS0FBSztZQUFRO2dCQUNYLE1BQU1sRCxVQUFVa0U7Z0JBQ2hCLE1BQU1DLGdCQUFnQjtvQkFDcEJwSSxJQUFJa0Y7b0JBQ0pJLFdBQVcsYUFBYSxHQUFHLElBQUlGO29CQUMvQm5GLE1BQU07b0JBQ05DLFNBQVM7Z0JBQ1g7Z0JBQ0EsTUFBTyxLQUFNO29CQUNYLE1BQU0sRUFBRW1JLElBQUksRUFBRXRKLEtBQUssRUFBRSxHQUFHLE1BQU1nRixPQUFPSSxJQUFJO29CQUN6QyxJQUFJa0UsTUFBTTt3QkFDUjtvQkFDRjtvQkFDQUQsY0FBY2xJLE9BQU8sSUFBSStELFFBQVFsRjtvQkFDakMwSSxTQUFTO3dCQUFDOzRCQUFFLEdBQUdXLGFBQWE7d0JBQUM7cUJBQUUsRUFBRSxFQUFFO29CQUNuQyxJQUFJLENBQUNkLG1CQUFtQixPQUFPLEtBQUssSUFBSUEsaUJBQWdCLE1BQU8sTUFBTTt3QkFDbkV2RCxPQUFPVSxNQUFNO3dCQUNiO29CQUNGO2dCQUNGO2dCQUNBUSxZQUFZLE9BQU8sS0FBSyxJQUFJQSxTQUFTbUQsZUFBZTtvQkFDbEQxRyxPQUFPO3dCQUFFSSxrQkFBa0JEO3dCQUFLRixjQUFjRTt3QkFBS2dFLGFBQWFoRTtvQkFBSTtvQkFDcEVKLGNBQWM7Z0JBQ2hCO2dCQUNBLE9BQU87b0JBQ0xvRixVQUFVO3dCQUFDdUI7cUJBQWM7b0JBQ3pCMUMsTUFBTSxFQUFFO2dCQUNWO1lBQ0Y7UUFDQSxLQUFLO1lBQVE7Z0JBQ1gsT0FBTyxNQUFNYiw0QkFBNEI7b0JBQ3ZDZDtvQkFDQWUsb0JBQW9Cd0MsbUJBQW1CLE9BQU87d0JBQUV4QixTQUFTd0I7b0JBQWtCLElBQUksS0FBSztvQkFDcEZ2QyxRQUFRMEM7b0JBQ1J6QztvQkFDQUMsVUFBUyxFQUFFTixPQUFPLEVBQUVsRCxZQUFZLEVBQUVDLEtBQUssRUFBRTt3QkFDdkMsSUFBSXVELFlBQVlOLFdBQVcsTUFBTTs0QkFDL0JNLFNBQVNOLFNBQVM7Z0NBQUVqRDtnQ0FBT0Q7NEJBQWE7d0JBQzFDO29CQUNGO29CQUNBcEUsWUFBWTZIO2dCQUNkO1lBQ0Y7UUFDQTtZQUFTO2dCQUNQLE1BQU1vRCxrQkFBa0JuQjtnQkFDeEIsTUFBTSxJQUFJN0gsTUFBTSxDQUFDLHlCQUF5QixFQUFFZ0osZ0JBQWdCLENBQUM7WUFDL0Q7SUFDRjtBQUNGO0FBRUEsNkJBQTZCO0FBQzdCLElBQUlDLG9CQUFvQixJQUFNeEI7QUFDOUIsZUFBZXlCLGtCQUFrQixFQUMvQnZCLEdBQUcsRUFDSHdCLE1BQU0sRUFDTnJCLFdBQVcsRUFDWEMsT0FBTyxFQUNQSCxJQUFJLEVBQ0pDLGlCQUFpQixNQUFNLEVBQ3ZCdUIsYUFBYSxFQUNiQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsa0JBQWtCLEVBQ2xCckIsVUFBVSxFQUNWdkMsUUFBUSxFQUNSNkQsT0FBTyxFQUNQQyxNQUFNLEVBQ05oQyxPQUFPVyxTQUFTYSxtQkFBbUIsRUFDcEM7SUFDQyxJQUFJO1FBQ0ZJLFdBQVc7UUFDWEMsU0FBUyxLQUFLO1FBQ2QsTUFBTXRCLGtCQUFrQixJQUFJMEI7UUFDNUJILG1CQUFtQnZCO1FBQ25Cb0IsY0FBYztRQUNkLE1BQU1PLE1BQU0sTUFBTXZCLE9BQU9ULEtBQUs7WUFDNUJZLFFBQVE7WUFDUlgsTUFBTW5FLEtBQUtJLFNBQVMsQ0FBQztnQkFDbkJzRjtnQkFDQSxHQUFHdkIsSUFBSTtZQUNUO1lBQ0FFO1lBQ0FDLFNBQVM7Z0JBQ1AsZ0JBQWdCO2dCQUNoQixHQUFHQSxPQUFPO1lBQ1o7WUFDQVMsUUFBUVIsZ0JBQWdCUSxNQUFNO1FBQ2hDLEdBQUdDLEtBQUssQ0FBQyxDQUFDQztZQUNSLE1BQU1BO1FBQ1I7UUFDQSxJQUFJUixZQUFZO1lBQ2QsSUFBSTtnQkFDRixNQUFNQSxXQUFXeUI7WUFDbkIsRUFBRSxPQUFPakIsS0FBSztnQkFDWixNQUFNQTtZQUNSO1FBQ0Y7UUFDQSxJQUFJLENBQUNpQixJQUFJaEIsRUFBRSxFQUFFO1lBQ1gsTUFBTSxJQUFJM0ksTUFDUixNQUFNMkosSUFBSTVJLElBQUksTUFBTTtRQUV4QjtRQUNBLElBQUksQ0FBQzRJLElBQUkvQixJQUFJLEVBQUU7WUFDYixNQUFNLElBQUk1SCxNQUFNO1FBQ2xCO1FBQ0EsSUFBSVosU0FBUztRQUNiLE1BQU1xRixTQUFTa0YsSUFBSS9CLElBQUksQ0FBQ2dCLFNBQVM7UUFDakMsT0FBUWY7WUFDTixLQUFLO2dCQUFRO29CQUNYLE1BQU1sRCxVQUFVa0U7b0JBQ2hCLE1BQU8sS0FBTTt3QkFDWCxNQUFNLEVBQUVFLElBQUksRUFBRXRKLEtBQUssRUFBRSxHQUFHLE1BQU1nRixPQUFPSSxJQUFJO3dCQUN6QyxJQUFJa0UsTUFBTTs0QkFDUjt3QkFDRjt3QkFDQTNKLFVBQVV1RixRQUFRbEY7d0JBQ2xCMkosY0FBY2hLO3dCQUNkLElBQUk0SSxvQkFBb0IsTUFBTTs0QkFDNUJ2RCxPQUFPVSxNQUFNOzRCQUNiO3dCQUNGO29CQUNGO29CQUNBO2dCQUNGO1lBQ0EsS0FBSztnQkFBUTtvQkFDWCxXQUFXLE1BQU0sRUFBRWxGLElBQUksRUFBRVIsS0FBSyxFQUFFLElBQUkrRSxlQUFlQyxRQUFRO3dCQUN6REMsV0FBVyxJQUFNc0Qsb0JBQW9CO29CQUN2QyxHQUFJO3dCQUNGLE9BQVEvSDs0QkFDTixLQUFLO2dDQUFRO29DQUNYYixVQUFVSztvQ0FDVjJKLGNBQWNoSztvQ0FDZDtnQ0FDRjs0QkFDQSxLQUFLO2dDQUFRO29DQUNYcUssVUFBVSxPQUFPLEtBQUssSUFBSUEsT0FBT2hLO29DQUNqQztnQ0FDRjt3QkFDRjtvQkFDRjtvQkFDQTtnQkFDRjtZQUNBO2dCQUFTO29CQUNQLE1BQU11SixrQkFBa0JuQjtvQkFDeEIsTUFBTSxJQUFJN0gsTUFBTSxDQUFDLHlCQUF5QixFQUFFZ0osZ0JBQWdCLENBQUM7Z0JBQy9EO1FBQ0Y7UUFDQSxJQUFJckQsVUFBVTtZQUNaQSxTQUFTd0QsUUFBUS9KO1FBQ25CO1FBQ0FtSyxtQkFBbUI7UUFDbkIsT0FBT25LO0lBQ1QsRUFBRSxPQUFPc0osS0FBSztRQUNaLElBQUlBLElBQUkzSSxJQUFJLEtBQUssY0FBYztZQUM3QndKLG1CQUFtQjtZQUNuQixPQUFPO1FBQ1Q7UUFDQSxJQUFJYixlQUFlMUksT0FBTztZQUN4QixJQUFJd0osU0FBUztnQkFDWEEsUUFBUWQ7WUFDVjtRQUNGO1FBQ0FZLFNBQVNaO0lBQ1gsU0FBVTtRQUNSVyxXQUFXO0lBQ2I7QUFDRjtBQUVBLDhCQUE4QjtBQUM5QixTQUFTUixtQkFBbUJlLE9BQU87SUFDakMsTUFBTWpGLFVBQVUsSUFBSUM7SUFDcEIsSUFBSSxDQUFDZ0YsU0FBUztRQUNaLE9BQU8sU0FBU3RGLEtBQUs7WUFDbkIsSUFBSSxDQUFDQSxPQUNILE9BQU87WUFDVCxPQUFPSyxRQUFRSSxNQUFNLENBQUNULE9BQU87Z0JBQUVVLFFBQVE7WUFBSztRQUM5QztJQUNGO0lBQ0EsT0FBTyxTQUFTVixLQUFLO1FBQ25CLE1BQU11RixVQUFVbEYsUUFBUUksTUFBTSxDQUFDVCxPQUFPO1lBQUVVLFFBQVE7UUFBSyxHQUFHQyxLQUFLLENBQUMsTUFBTUMsTUFBTSxDQUFDLENBQUNoQyxPQUFTQSxTQUFTO1FBQzlGLE9BQU8yRyxRQUFROUcsR0FBRyxDQUFDRSxpQkFBaUJpQyxNQUFNLENBQUNvQztJQUM3QztBQUNGO0FBRUEsa0JBQWtCO0FBQ2xCLFNBQVN3QyxtQkFBbUJDLE9BQU87SUFDakMsTUFBTSxDQUFDQyxRQUFRQyxjQUFjLEdBQUdGLFFBQVE5RSxLQUFLLENBQUM7SUFDOUMsTUFBTWlGLFdBQVdGLE9BQU8vRSxLQUFLLENBQUMsSUFBSSxDQUFDLEVBQUUsQ0FBQ0EsS0FBSyxDQUFDLElBQUksQ0FBQyxFQUFFO0lBQ25ELElBQUlpRixZQUFZLFFBQVFELGlCQUFpQixNQUFNO1FBQzdDLE1BQU0sSUFBSWpLLE1BQU07SUFDbEI7SUFDQSxJQUFJO1FBQ0YsT0FBT21LLE9BQU9DLElBQUksQ0FBQ0g7SUFDckIsRUFBRSxPQUFPSSxPQUFPO1FBQ2QsTUFBTSxJQUFJckssTUFBTSxDQUFDLHVCQUF1QixDQUFDO0lBQzNDO0FBQ0Y7QUFFQSw0QkFBNEI7QUFDNUIsU0FBU3NLLGdCQUFnQkMsSUFBSSxFQUFFQyxJQUFJO0lBQ2pDLElBQUlELFNBQVNDLE1BQ1gsT0FBTztJQUNULElBQUlELFFBQVEsUUFBUUMsUUFBUSxNQUMxQixPQUFPO0lBQ1QsSUFBSSxPQUFPRCxTQUFTLFlBQVksT0FBT0MsU0FBUyxVQUM5QyxPQUFPRCxTQUFTQztJQUNsQixJQUFJRCxLQUFLRSxXQUFXLEtBQUtELEtBQUtDLFdBQVcsRUFDdkMsT0FBTztJQUNULElBQUlGLGdCQUFnQnpFLFFBQVEwRSxnQkFBZ0IxRSxNQUFNO1FBQ2hELE9BQU95RSxLQUFLRyxPQUFPLE9BQU9GLEtBQUtFLE9BQU87SUFDeEM7SUFDQSxJQUFJcEssTUFBTUMsT0FBTyxDQUFDZ0ssT0FBTztRQUN2QixJQUFJQSxLQUFLeEwsTUFBTSxLQUFLeUwsS0FBS3pMLE1BQU0sRUFDN0IsT0FBTztRQUNULElBQUssSUFBSU4sSUFBSSxHQUFHQSxJQUFJOEwsS0FBS3hMLE1BQU0sRUFBRU4sSUFBSztZQUNwQyxJQUFJLENBQUM2TCxnQkFBZ0JDLElBQUksQ0FBQzlMLEVBQUUsRUFBRStMLElBQUksQ0FBQy9MLEVBQUUsR0FDbkMsT0FBTztRQUNYO1FBQ0EsT0FBTztJQUNUO0lBQ0EsTUFBTWtNLFFBQVFDLE9BQU9DLElBQUksQ0FBQ047SUFDMUIsTUFBTU8sUUFBUUYsT0FBT0MsSUFBSSxDQUFDTDtJQUMxQixJQUFJRyxNQUFNNUwsTUFBTSxLQUFLK0wsTUFBTS9MLE1BQU0sRUFDL0IsT0FBTztJQUNULEtBQUssTUFBTWdNLE9BQU9KLE1BQU87UUFDdkIsSUFBSSxDQUFDRyxNQUFNeEgsUUFBUSxDQUFDeUgsTUFDbEIsT0FBTztRQUNULElBQUksQ0FBQ1QsZ0JBQWdCQyxJQUFJLENBQUNRLElBQUksRUFBRVAsSUFBSSxDQUFDTyxJQUFJLEdBQ3ZDLE9BQU87SUFDWDtJQUNBLE9BQU87QUFDVDtBQUVBLDZCQUE2QjtBQUM3QixlQUFlQyxrQkFBa0IsRUFDL0JDLG1CQUFtQixFQUNuQkMsMkJBQTJCLEVBQzNCQyx1QkFBdUIsRUFDdkJDLGlCQUFpQixFQUNqQkMsa0JBQWtCLEVBQ25CO0lBQ0MsTUFBTyxLQUFNO1FBQ1gsTUFBTUMsK0JBQStCLE1BQU1MO1FBQzNDLElBQUksY0FBY0ssOEJBQThCO1lBQzlDLElBQUlDLHVCQUF1QjtZQUMzQixLQUFLLE1BQU1sRyxXQUFXaUcsNkJBQTZCL0QsUUFBUSxDQUFFO2dCQUMzRCxJQUFJLENBQUNsQyxRQUFRbEYsYUFBYSxLQUFLLEtBQUssS0FBSyxPQUFPa0YsUUFBUWxGLGFBQWEsS0FBSyxRQUFPLEtBQU9rRixDQUFBQSxRQUFRaEUsVUFBVSxLQUFLLEtBQUssS0FBSyxPQUFPZ0UsUUFBUWhFLFVBQVUsS0FBSyxRQUFPLEdBQUk7b0JBQ2hLO2dCQUNGO2dCQUNBa0ssdUJBQXVCO2dCQUN2QixJQUFJTCw2QkFBNkI7b0JBQy9CLE1BQU1NLGVBQWVuRyxRQUFRbEYsYUFBYTtvQkFDMUMsSUFBSSxPQUFPcUwsaUJBQWlCLFVBQVU7d0JBQ3BDQyxRQUFRQyxJQUFJLENBQ1Y7d0JBRUY7b0JBQ0Y7b0JBQ0EsTUFBTUMsdUJBQXVCLE1BQU1ULDRCQUNqQ0csc0JBQ0FHO29CQUVGLElBQUlHLHlCQUF5QixLQUFLLEdBQUc7d0JBQ25DSix1QkFBdUI7d0JBQ3ZCO29CQUNGO29CQUNBSCxrQkFBa0JPO2dCQUNwQjtnQkFDQSxJQUFJUix5QkFBeUI7b0JBQzNCLE1BQU1TLFlBQVl2RyxRQUFRaEUsVUFBVTtvQkFDcEMsSUFBSSxDQUFDZixNQUFNQyxPQUFPLENBQUNxTCxjQUFjQSxVQUFVdEssSUFBSSxDQUFDLENBQUN3RixXQUFhLE9BQU9BLGFBQWEsV0FBVzt3QkFDM0YyRSxRQUFRQyxJQUFJLENBQ1Y7d0JBRUY7b0JBQ0Y7b0JBQ0EsTUFBTUcsbUJBQW1CLE1BQU1WLHdCQUF3QkUsc0JBQXNCTztvQkFDN0UsSUFBSUMscUJBQXFCLEtBQUssR0FBRzt3QkFDL0JOLHVCQUF1Qjt3QkFDdkI7b0JBQ0Y7b0JBQ0FILGtCQUFrQlM7Z0JBQ3BCO1lBQ0Y7WUFDQSxJQUFJLENBQUNOLHNCQUFzQjtnQkFDekI7WUFDRjtRQUNGLE9BQU87WUFDTCxJQUFJTyw0QkFBNEIsU0FBU3hELFFBQVE7Z0JBQy9DLEtBQUssTUFBTWpELFdBQVdpRCxTQUFTZixRQUFRLENBQUU7b0JBQ3ZDLElBQUlsQyxRQUFRaEUsVUFBVSxLQUFLLEtBQUssR0FBRzt3QkFDakMsS0FBSyxNQUFNeUYsWUFBWXpCLFFBQVFoRSxVQUFVLENBQUU7NEJBQ3pDLElBQUksT0FBT3lGLGFBQWEsVUFBVTtnQ0FDaEMsSUFBSUEsU0FBU3RGLFFBQVEsQ0FBQ3BCLFNBQVMsSUFBSSxPQUFPMEcsU0FBU3RGLFFBQVEsQ0FBQ3BCLFNBQVMsS0FBSyxVQUFVO29DQUNsRjBHLFNBQVN0RixRQUFRLENBQUNwQixTQUFTLEdBQUdxRCxLQUFLSSxTQUFTLENBQzFDaUQsU0FBU3RGLFFBQVEsQ0FBQ3BCLFNBQVM7Z0NBRS9COzRCQUNGO3dCQUNGO29CQUNGO29CQUNBLElBQUlpRixRQUFRbEYsYUFBYSxLQUFLLEtBQUssR0FBRzt3QkFDcEMsSUFBSSxPQUFPa0YsUUFBUWxGLGFBQWEsS0FBSyxVQUFVOzRCQUM3QyxJQUFJa0YsUUFBUWxGLGFBQWEsQ0FBQ0MsU0FBUyxJQUFJLE9BQU9pRixRQUFRbEYsYUFBYSxDQUFDQyxTQUFTLEtBQUssVUFBVTtnQ0FDMUZpRixRQUFRbEYsYUFBYSxDQUFDQyxTQUFTLEdBQUdxRCxLQUFLSSxTQUFTLENBQzlDd0IsUUFBUWxGLGFBQWEsQ0FBQ0MsU0FBUzs0QkFFbkM7d0JBQ0Y7b0JBQ0Y7Z0JBQ0Y7WUFDRjtZQUNBLElBQUkyTCwyQkFBMkJEO1lBQy9CLE1BQU1FLDBCQUEwQlY7WUFDaEMsSUFBSSxDQUFDVSx3QkFBd0I3TCxhQUFhLEtBQUssS0FBSyxLQUFLLE9BQU82TCx3QkFBd0I3TCxhQUFhLEtBQUssUUFBTyxLQUFPNkwsQ0FBQUEsd0JBQXdCM0ssVUFBVSxLQUFLLEtBQUssS0FBSyxPQUFPMkssd0JBQXdCM0ssVUFBVSxLQUFLLFFBQU8sR0FBSTtnQkFDaE87WUFDRjtZQUNBLElBQUk2Siw2QkFBNkI7Z0JBQy9CLE1BQU1NLGVBQWVRLHdCQUF3QjdMLGFBQWE7Z0JBQzFELElBQUksQ0FBRSxRQUFPcUwsaUJBQWlCLFFBQU8sR0FBSTtvQkFDdkNDLFFBQVFDLElBQUksQ0FDVjtvQkFFRjtnQkFDRjtnQkFDQSxNQUFNQyx1QkFBdUIsTUFBTVQsNEJBQTRCRyxzQkFBc0JHO2dCQUNyRixJQUFJRyx5QkFBeUIsS0FBSyxHQUNoQztnQkFDRkcsMEJBQTBCSDtnQkFDMUJQLGtCQUFrQk87WUFDcEI7WUFDQSxJQUFJUix5QkFBeUI7Z0JBQzNCLE1BQU1TLFlBQVlJLHdCQUF3QjNLLFVBQVU7Z0JBQ3BELElBQUksQ0FBRSxRQUFPdUssY0FBYyxRQUFPLEdBQUk7b0JBQ3BDSCxRQUFRQyxJQUFJLENBQ1Y7b0JBRUY7Z0JBQ0Y7Z0JBQ0EsTUFBTUcsbUJBQW1CLE1BQU1WLHdCQUF3QkUsc0JBQXNCTztnQkFDN0UsSUFBSUMscUJBQXFCLEtBQUssR0FDNUI7Z0JBQ0ZDLDBCQUEwQkQ7Z0JBQzFCVCxrQkFBa0JTO1lBQ3BCO1FBQ0Y7SUFDRjtBQUNGO0FBRUEsZ0JBQWdCO0FBQ3lDO0FBQ1I7QUFDakQsSUFBSU0sZUFBZUMsT0FBT0MsR0FBRyxDQUFDO0FBQzlCLFNBQVNDLFdBQVdDLFdBQVcsRUFBRSxFQUMvQkMsUUFBUSxFQUNULEdBQUcsQ0FBQyxDQUFDO0lBQ0osT0FBTztRQUNMLENBQUNMLGFBQWEsRUFBRTtRQUNoQk0sT0FBTyxLQUFLO1FBQ1osZ0NBQWdDO1FBQ2hDLENBQUNSLG1FQUFlQSxDQUFDLEVBQUU7UUFDbkJLLFlBQVlDO1FBQ1pDO0lBQ0Y7QUFDRjtBQUNBLFNBQVNFLFNBQVNqTixLQUFLO0lBQ3JCLE9BQU8sT0FBT0EsVUFBVSxZQUFZQSxVQUFVLFFBQVEwTSxnQkFBZ0IxTSxTQUFTQSxLQUFLLENBQUMwTSxhQUFhLEtBQUssUUFBUSxnQkFBZ0IxTSxTQUFTLGNBQWNBO0FBQ3hKO0FBQ0EsU0FBU2tOLFNBQVNDLE1BQU07SUFDdEIsT0FBT0YsU0FBU0UsVUFBVUEsU0FBU0MsVUFBVUQ7QUFDL0M7QUFDQSxTQUFTQyxVQUFVQyxVQUFVO0lBQzNCLE9BQU9SLFdBQ0wsa0VBQWtFO0lBQ2xFSiw4REFBZUEsQ0FBQ1ksYUFDaEI7UUFDRU4sVUFBVSxDQUFDL007WUFDVCxNQUFNTCxTQUFTME4sV0FBV0MsU0FBUyxDQUFDdE47WUFDcEMsT0FBT0wsT0FBTzROLE9BQU8sR0FBRztnQkFBRUEsU0FBUztnQkFBTXZOLE9BQU9MLE9BQU9nSCxJQUFJO1lBQUMsSUFBSTtnQkFBRTRHLFNBQVM7Z0JBQU8zQyxPQUFPakwsT0FBT2lMLEtBQUs7WUFBQztRQUN4RztJQUNGO0FBRUo7QUFpQkUsQ0FDRixrQ0FBa0MiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9uZXh0anMtZmlyc3RfY2hhdGJvdC8uL25vZGVfbW9kdWxlcy9AYWktc2RrL3VpLXV0aWxzL2Rpc3QvaW5kZXgubWpzPzc4M2IiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gc3JjL2luZGV4LnRzXG5pbXBvcnQgeyBnZW5lcmF0ZUlkIH0gZnJvbSBcIkBhaS1zZGsvcHJvdmlkZXItdXRpbHNcIjtcblxuLy8gc3JjL3Byb2Nlc3MtZGF0YS1wcm90b2NvbC1yZXNwb25zZS50c1xuaW1wb3J0IHsgZ2VuZXJhdGVJZCBhcyBnZW5lcmF0ZUlkRnVuY3Rpb24gfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuXG4vLyBzcmMvcGFyc2UtcGFydGlhbC1qc29uLnRzXG5pbXBvcnQgU2VjdXJlSlNPTiBmcm9tIFwic2VjdXJlLWpzb24tcGFyc2VcIjtcblxuLy8gc3JjL2ZpeC1qc29uLnRzXG5mdW5jdGlvbiBmaXhKc29uKGlucHV0KSB7XG4gIGNvbnN0IHN0YWNrID0gW1wiUk9PVFwiXTtcbiAgbGV0IGxhc3RWYWxpZEluZGV4ID0gLTE7XG4gIGxldCBsaXRlcmFsU3RhcnQgPSBudWxsO1xuICBmdW5jdGlvbiBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBzd2FwU3RhdGUpIHtcbiAgICB7XG4gICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgIHN0YWNrLnB1c2goc3dhcFN0YXRlKTtcbiAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR1wiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiZlwiOlxuICAgICAgICBjYXNlIFwidFwiOlxuICAgICAgICBjYXNlIFwiblwiOiB7XG4gICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIGxpdGVyYWxTdGFydCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTElURVJBTFwiKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICBjYXNlIFwiLVwiOiB7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCIwXCI6XG4gICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgIGNhc2UgXCIyXCI6XG4gICAgICAgIGNhc2UgXCIzXCI6XG4gICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgIGNhc2UgXCI1XCI6XG4gICAgICAgIGNhc2UgXCI2XCI6XG4gICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgIGNhc2UgXCI4XCI6XG4gICAgICAgIGNhc2UgXCI5XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfTlVNQkVSXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJ7XCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX1NUQVJUXCIpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIGNhc2UgXCJbXCI6IHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgc3RhY2sucHVzaChzd2FwU3RhdGUpO1xuICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfU1RBUlRcIik7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyT2JqZWN0VmFsdWUoY2hhciwgaSkge1xuICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgY2FzZSBcIixcIjoge1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgc3RhY2sucHVzaChcIklOU0lERV9PQkpFQ1RfQUZURVJfQ09NTUFcIik7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIn1cIjoge1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZShjaGFyLCBpKSB7XG4gICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJdXCI6IHtcbiAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcbiAgICBjb25zdCBjaGFyID0gaW5wdXRbaV07XG4gICAgY29uc3QgY3VycmVudFN0YXRlID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgc3dpdGNoIChjdXJyZW50U3RhdGUpIHtcbiAgICAgIGNhc2UgXCJST09UXCI6XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiRklOSVNIXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX1NUQVJUXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwifVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0tFWVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0tFWVwiOiB7XG4gICAgICAgIHN3aXRjaCAoY2hhcikge1xuICAgICAgICAgIGNhc2UgJ1wiJzoge1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiOlwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0JFRk9SRV9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgc3dpdGNoIChjaGFyKSB7XG4gICAgICAgICAgY2FzZSAnXCInOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGxhc3RWYWxpZEluZGV4ID0gaTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXFxcXFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wdXNoKFwiSU5TSURFX1NUUklOR19FU0NBUEVcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfU1RBUlRcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBwcm9jZXNzVmFsdWVTdGFydChjaGFyLCBpLCBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiLFwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIHN0YWNrLnB1c2goXCJJTlNJREVfQVJSQVlfQUZURVJfQ09NTUFcIik7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcIl1cIjoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgc3RhY2sucG9wKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgZGVmYXVsdDoge1xuICAgICAgICAgICAgbGFzdFZhbGlkSW5kZXggPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9BUlJBWV9BRlRFUl9DT01NQVwiOiB7XG4gICAgICAgIHByb2Nlc3NWYWx1ZVN0YXJ0KGNoYXIsIGksIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCIpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HX0VTQ0FQRVwiOiB7XG4gICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9OVU1CRVJcIjoge1xuICAgICAgICBzd2l0Y2ggKGNoYXIpIHtcbiAgICAgICAgICBjYXNlIFwiMFwiOlxuICAgICAgICAgIGNhc2UgXCIxXCI6XG4gICAgICAgICAgY2FzZSBcIjJcIjpcbiAgICAgICAgICBjYXNlIFwiM1wiOlxuICAgICAgICAgIGNhc2UgXCI0XCI6XG4gICAgICAgICAgY2FzZSBcIjVcIjpcbiAgICAgICAgICBjYXNlIFwiNlwiOlxuICAgICAgICAgIGNhc2UgXCI3XCI6XG4gICAgICAgICAgY2FzZSBcIjhcIjpcbiAgICAgICAgICBjYXNlIFwiOVwiOiB7XG4gICAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgY2FzZSBcImVcIjpcbiAgICAgICAgICBjYXNlIFwiRVwiOlxuICAgICAgICAgIGNhc2UgXCItXCI6XG4gICAgICAgICAgY2FzZSBcIi5cIjoge1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCIsXCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlckFycmF5VmFsdWUoY2hhciwgaSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICAgIHByb2Nlc3NBZnRlck9iamVjdFZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGNhc2UgXCJ9XCI6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9PQkpFQ1RfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjYXNlIFwiXVwiOiB7XG4gICAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICAgIGlmIChzdGFja1tzdGFjay5sZW5ndGggLSAxXSA9PT0gXCJJTlNJREVfQVJSQVlfQUZURVJfVkFMVUVcIikge1xuICAgICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgIHN0YWNrLnBvcCgpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9MSVRFUkFMXCI6IHtcbiAgICAgICAgY29uc3QgcGFydGlhbExpdGVyYWwgPSBpbnB1dC5zdWJzdHJpbmcobGl0ZXJhbFN0YXJ0LCBpICsgMSk7XG4gICAgICAgIGlmICghXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpICYmICFcInRydWVcIi5zdGFydHNXaXRoKHBhcnRpYWxMaXRlcmFsKSAmJiAhXCJudWxsXCIuc3RhcnRzV2l0aChwYXJ0aWFsTGl0ZXJhbCkpIHtcbiAgICAgICAgICBzdGFjay5wb3AoKTtcbiAgICAgICAgICBpZiAoc3RhY2tbc3RhY2subGVuZ3RoIC0gMV0gPT09IFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJPYmplY3RWYWx1ZShjaGFyLCBpKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKHN0YWNrW3N0YWNrLmxlbmd0aCAtIDFdID09PSBcIklOU0lERV9BUlJBWV9BRlRFUl9WQUxVRVwiKSB7XG4gICAgICAgICAgICBwcm9jZXNzQWZ0ZXJBcnJheVZhbHVlKGNoYXIsIGkpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBsYXN0VmFsaWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGxldCByZXN1bHQgPSBpbnB1dC5zbGljZSgwLCBsYXN0VmFsaWRJbmRleCArIDEpO1xuICBmb3IgKGxldCBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSAwOyBpLS0pIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0YWNrW2ldO1xuICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgIGNhc2UgXCJJTlNJREVfU1RSSU5HXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9ICdcIic7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfS0VZXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9LRVlcIjpcbiAgICAgIGNhc2UgXCJJTlNJREVfT0JKRUNUX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9TVEFSVFwiOlxuICAgICAgY2FzZSBcIklOU0lERV9PQkpFQ1RfQkVGT1JFX1ZBTFVFXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX09CSkVDVF9BRlRFUl9WQUxVRVwiOiB7XG4gICAgICAgIHJlc3VsdCArPSBcIn1cIjtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX1NUQVJUXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX0NPTU1BXCI6XG4gICAgICBjYXNlIFwiSU5TSURFX0FSUkFZX0FGVEVSX1ZBTFVFXCI6IHtcbiAgICAgICAgcmVzdWx0ICs9IFwiXVwiO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGNhc2UgXCJJTlNJREVfTElURVJBTFwiOiB7XG4gICAgICAgIGNvbnN0IHBhcnRpYWxMaXRlcmFsID0gaW5wdXQuc3Vic3RyaW5nKGxpdGVyYWxTdGFydCwgaW5wdXQubGVuZ3RoKTtcbiAgICAgICAgaWYgKFwidHJ1ZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwidHJ1ZVwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH0gZWxzZSBpZiAoXCJmYWxzZVwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwiZmFsc2VcIi5zbGljZShwYXJ0aWFsTGl0ZXJhbC5sZW5ndGgpO1xuICAgICAgICB9IGVsc2UgaWYgKFwibnVsbFwiLnN0YXJ0c1dpdGgocGFydGlhbExpdGVyYWwpKSB7XG4gICAgICAgICAgcmVzdWx0ICs9IFwibnVsbFwiLnNsaWNlKHBhcnRpYWxMaXRlcmFsLmxlbmd0aCk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLy8gc3JjL3BhcnNlLXBhcnRpYWwtanNvbi50c1xuZnVuY3Rpb24gcGFyc2VQYXJ0aWFsSnNvbihqc29uVGV4dCkge1xuICBpZiAoanNvblRleHQgPT09IHZvaWQgMCkge1xuICAgIHJldHVybiB7IHZhbHVlOiB2b2lkIDAsIHN0YXRlOiBcInVuZGVmaW5lZC1pbnB1dFwiIH07XG4gIH1cbiAgdHJ5IHtcbiAgICByZXR1cm4ge1xuICAgICAgdmFsdWU6IFNlY3VyZUpTT04ucGFyc2UoanNvblRleHQpLFxuICAgICAgc3RhdGU6IFwic3VjY2Vzc2Z1bC1wYXJzZVwiXG4gICAgfTtcbiAgfSBjYXRjaCAoaWdub3JlZCkge1xuICAgIHRyeSB7XG4gICAgICByZXR1cm4ge1xuICAgICAgICB2YWx1ZTogU2VjdXJlSlNPTi5wYXJzZShmaXhKc29uKGpzb25UZXh0KSksXG4gICAgICAgIHN0YXRlOiBcInJlcGFpcmVkLXBhcnNlXCJcbiAgICAgIH07XG4gICAgfSBjYXRjaCAoaWdub3JlZDIpIHtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHsgdmFsdWU6IHZvaWQgMCwgc3RhdGU6IFwiZmFpbGVkLXBhcnNlXCIgfTtcbn1cblxuLy8gc3JjL3N0cmVhbS1wYXJ0cy50c1xudmFyIHRleHRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjBcIixcbiAgbmFtZTogXCJ0ZXh0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodHlwZW9mIHZhbHVlICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1widGV4dFwiIHBhcnRzIGV4cGVjdCBhIHN0cmluZyB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJ0ZXh0XCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZnVuY3Rpb25DYWxsU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCIxXCIsXG4gIG5hbWU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmdW5jdGlvbl9jYWxsXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsICE9PSBcIm9iamVjdFwiIHx8IHZhbHVlLmZ1bmN0aW9uX2NhbGwgPT0gbnVsbCB8fCAhKFwibmFtZVwiIGluIHZhbHVlLmZ1bmN0aW9uX2NhbGwpIHx8ICEoXCJhcmd1bWVudHNcIiBpbiB2YWx1ZS5mdW5jdGlvbl9jYWxsKSB8fCB0eXBlb2YgdmFsdWUuZnVuY3Rpb25fY2FsbC5uYW1lICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmdW5jdGlvbl9jYWxsXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJmdW5jdGlvbl9jYWxsXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZnVuY3Rpb25fY2FsbFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIGRhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjJcIixcbiAgbmFtZTogXCJkYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wiZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJkYXRhXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgZXJyb3JTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjNcIixcbiAgbmFtZTogXCJlcnJvclwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKCdcImVycm9yXCIgcGFydHMgZXhwZWN0IGEgc3RyaW5nIHZhbHVlLicpO1xuICAgIH1cbiAgICByZXR1cm4geyB0eXBlOiBcImVycm9yXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNFwiLFxuICBuYW1lOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdmFsdWUpIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJjb250ZW50XCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5pZCAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdmFsdWUucm9sZSAhPT0gXCJzdHJpbmdcIiB8fCB2YWx1ZS5yb2xlICE9PSBcImFzc2lzdGFudFwiIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLmNvbnRlbnQpIHx8ICF2YWx1ZS5jb250ZW50LmV2ZXJ5KFxuICAgICAgKGl0ZW0pID0+IGl0ZW0gIT0gbnVsbCAmJiB0eXBlb2YgaXRlbSA9PT0gXCJvYmplY3RcIiAmJiBcInR5cGVcIiBpbiBpdGVtICYmIGl0ZW0udHlwZSA9PT0gXCJ0ZXh0XCIgJiYgXCJ0ZXh0XCIgaW4gaXRlbSAmJiBpdGVtLnRleHQgIT0gbnVsbCAmJiB0eXBlb2YgaXRlbS50ZXh0ID09PSBcIm9iamVjdFwiICYmIFwidmFsdWVcIiBpbiBpdGVtLnRleHQgJiYgdHlwZW9mIGl0ZW0udGV4dC52YWx1ZSA9PT0gXCJzdHJpbmdcIlxuICAgICkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYW4gXCJpZFwiLCBcInJvbGVcIiwgYW5kIFwiY29udGVudFwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcImFzc2lzdGFudF9tZXNzYWdlXCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjVcIixcbiAgbmFtZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRocmVhZElkXCIgaW4gdmFsdWUpIHx8ICEoXCJtZXNzYWdlSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRocmVhZElkICE9PSBcInN0cmluZ1wiIHx8IHR5cGVvZiB2YWx1ZS5tZXNzYWdlSWQgIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiYXNzaXN0YW50X2NvbnRyb2xfZGF0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidGhyZWFkSWRcIiBhbmQgXCJtZXNzYWdlSWRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJhc3Npc3RhbnRfY29udHJvbF9kYXRhXCIsXG4gICAgICB2YWx1ZToge1xuICAgICAgICB0aHJlYWRJZDogdmFsdWUudGhyZWFkSWQsXG4gICAgICAgIG1lc3NhZ2VJZDogdmFsdWUubWVzc2FnZUlkXG4gICAgICB9XG4gICAgfTtcbiAgfVxufTtcbnZhciBkYXRhTWVzc2FnZVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiNlwiLFxuICBuYW1lOiBcImRhdGFfbWVzc2FnZVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJyb2xlXCIgaW4gdmFsdWUpIHx8ICEoXCJkYXRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5yb2xlICE9PSBcInN0cmluZ1wiIHx8IHZhbHVlLnJvbGUgIT09IFwiZGF0YVwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcImRhdGFfbWVzc2FnZVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwicm9sZVwiIGFuZCBcImRhdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJkYXRhX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sQ2FsbHNTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjdcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxzXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xfY2FsbHNcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xfY2FsbHMgIT09IFwib2JqZWN0XCIgfHwgdmFsdWUudG9vbF9jYWxscyA9PSBudWxsIHx8ICFBcnJheS5pc0FycmF5KHZhbHVlLnRvb2xfY2FsbHMpIHx8IHZhbHVlLnRvb2xfY2FsbHMuc29tZShcbiAgICAgICh0YykgPT4gdGMgPT0gbnVsbCB8fCB0eXBlb2YgdGMgIT09IFwib2JqZWN0XCIgfHwgIShcImlkXCIgaW4gdGMpIHx8IHR5cGVvZiB0Yy5pZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidHlwZVwiIGluIHRjKSB8fCB0eXBlb2YgdGMudHlwZSAhPT0gXCJzdHJpbmdcIiB8fCAhKFwiZnVuY3Rpb25cIiBpbiB0YykgfHwgdGMuZnVuY3Rpb24gPT0gbnVsbCB8fCB0eXBlb2YgdGMuZnVuY3Rpb24gIT09IFwib2JqZWN0XCIgfHwgIShcImFyZ3VtZW50c1wiIGluIHRjLmZ1bmN0aW9uKSB8fCB0eXBlb2YgdGMuZnVuY3Rpb24ubmFtZSAhPT0gXCJzdHJpbmdcIiB8fCB0eXBlb2YgdGMuZnVuY3Rpb24uYXJndW1lbnRzICE9PSBcInN0cmluZ1wiXG4gICAgKSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxzXCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgVG9vbENhbGxQYXlsb2FkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICB0eXBlOiBcInRvb2xfY2FsbHNcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjhcIixcbiAgbmFtZTogXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAoIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1wibWVzc2FnZV9hbm5vdGF0aW9uc1wiIHBhcnRzIGV4cGVjdCBhbiBhcnJheSB2YWx1ZS4nKTtcbiAgICB9XG4gICAgcmV0dXJuIHsgdHlwZTogXCJtZXNzYWdlX2Fubm90YXRpb25zXCIsIHZhbHVlIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcIjlcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwidG9vbE5hbWVcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xOYW1lICE9PSBcInN0cmluZ1wiIHx8ICEoXCJhcmdzXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5hcmdzICE9PSBcIm9iamVjdFwiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiLCBcInRvb2xOYW1lXCIsIGFuZCBcImFyZ3NcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciB0b29sUmVzdWx0U3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJhXCIsXG4gIG5hbWU6IFwidG9vbF9yZXN1bHRcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwidG9vbENhbGxJZFwiIGluIHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUudG9vbENhbGxJZCAhPT0gXCJzdHJpbmdcIiB8fCAhKFwicmVzdWx0XCIgaW4gdmFsdWUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfcmVzdWx0XCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIGEgXCJyZXN1bHRcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX3Jlc3VsdFwiLFxuICAgICAgdmFsdWVcbiAgICB9O1xuICB9XG59O1xudmFyIHRvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImJcIixcbiAgbmFtZTogXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsXG4gIHBhcnNlOiAodmFsdWUpID0+IHtcbiAgICBpZiAodmFsdWUgPT0gbnVsbCB8fCB0eXBlb2YgdmFsdWUgIT09IFwib2JqZWN0XCIgfHwgIShcInRvb2xDYWxsSWRcIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLnRvb2xDYWxsSWQgIT09IFwic3RyaW5nXCIgfHwgIShcInRvb2xOYW1lXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sTmFtZSAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIgcGFydHMgZXhwZWN0IGFuIG9iamVjdCB3aXRoIGEgXCJ0b29sQ2FsbElkXCIgYW5kIFwidG9vbE5hbWVcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIsXG4gICAgICB2YWx1ZVxuICAgIH07XG4gIH1cbn07XG52YXIgdG9vbENhbGxEZWx0YVN0cmVhbVBhcnQgPSB7XG4gIGNvZGU6IFwiY1wiLFxuICBuYW1lOiBcInRvb2xfY2FsbF9kZWx0YVwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJ0b29sQ2FsbElkXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS50b29sQ2FsbElkICE9PSBcInN0cmluZ1wiIHx8ICEoXCJhcmdzVGV4dERlbHRhXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5hcmdzVGV4dERlbHRhICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdcInRvb2xfY2FsbF9kZWx0YVwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwidG9vbENhbGxJZFwiIGFuZCBcImFyZ3NUZXh0RGVsdGFcIiBwcm9wZXJ0eS4nXG4gICAgICApO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJ0b29sX2NhbGxfZGVsdGFcIixcbiAgICAgIHZhbHVlXG4gICAgfTtcbiAgfVxufTtcbnZhciBmaW5pc2hNZXNzYWdlU3RyZWFtUGFydCA9IHtcbiAgY29kZTogXCJkXCIsXG4gIG5hbWU6IFwiZmluaXNoX21lc3NhZ2VcIixcbiAgcGFyc2U6ICh2YWx1ZSkgPT4ge1xuICAgIGlmICh2YWx1ZSA9PSBudWxsIHx8IHR5cGVvZiB2YWx1ZSAhPT0gXCJvYmplY3RcIiB8fCAhKFwiZmluaXNoUmVhc29uXCIgaW4gdmFsdWUpIHx8IHR5cGVvZiB2YWx1ZS5maW5pc2hSZWFzb24gIT09IFwic3RyaW5nXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgJ1wiZmluaXNoX21lc3NhZ2VcIiBwYXJ0cyBleHBlY3QgYW4gb2JqZWN0IHdpdGggYSBcImZpbmlzaFJlYXNvblwiIHByb3BlcnR5LidcbiAgICAgICk7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgIGZpbmlzaFJlYXNvbjogdmFsdWUuZmluaXNoUmVhc29uXG4gICAgfTtcbiAgICBpZiAoXCJ1c2FnZVwiIGluIHZhbHVlICYmIHZhbHVlLnVzYWdlICE9IG51bGwgJiYgdHlwZW9mIHZhbHVlLnVzYWdlID09PSBcIm9iamVjdFwiICYmIFwicHJvbXB0VG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UgJiYgXCJjb21wbGV0aW9uVG9rZW5zXCIgaW4gdmFsdWUudXNhZ2UpIHtcbiAgICAgIHJlc3VsdC51c2FnZSA9IHtcbiAgICAgICAgcHJvbXB0VG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zID09PSBcIm51bWJlclwiID8gdmFsdWUudXNhZ2UucHJvbXB0VG9rZW5zIDogTnVtYmVyLk5hTixcbiAgICAgICAgY29tcGxldGlvblRva2VuczogdHlwZW9mIHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5jb21wbGV0aW9uVG9rZW5zIDogTnVtYmVyLk5hTlxuICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6IFwiZmluaXNoX21lc3NhZ2VcIixcbiAgICAgIHZhbHVlOiByZXN1bHRcbiAgICB9O1xuICB9XG59O1xudmFyIGZpbmlzaFN0ZXBTdHJlYW1QYXJ0ID0ge1xuICBjb2RlOiBcImVcIixcbiAgbmFtZTogXCJmaW5pc2hfc3RlcFwiLFxuICBwYXJzZTogKHZhbHVlKSA9PiB7XG4gICAgaWYgKHZhbHVlID09IG51bGwgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiIHx8ICEoXCJmaW5pc2hSZWFzb25cIiBpbiB2YWx1ZSkgfHwgdHlwZW9mIHZhbHVlLmZpbmlzaFJlYXNvbiAhPT0gXCJzdHJpbmdcIikge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnXCJmaW5pc2hfc3RlcFwiIHBhcnRzIGV4cGVjdCBhbiBvYmplY3Qgd2l0aCBhIFwiZmluaXNoUmVhc29uXCIgcHJvcGVydHkuJ1xuICAgICAgKTtcbiAgICB9XG4gICAgY29uc3QgcmVzdWx0ID0ge1xuICAgICAgZmluaXNoUmVhc29uOiB2YWx1ZS5maW5pc2hSZWFzb24sXG4gICAgICBpc0NvbnRpbnVlZDogZmFsc2VcbiAgICB9O1xuICAgIGlmIChcInVzYWdlXCIgaW4gdmFsdWUgJiYgdmFsdWUudXNhZ2UgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudXNhZ2UgPT09IFwib2JqZWN0XCIgJiYgXCJwcm9tcHRUb2tlbnNcIiBpbiB2YWx1ZS51c2FnZSAmJiBcImNvbXBsZXRpb25Ub2tlbnNcIiBpbiB2YWx1ZS51c2FnZSkge1xuICAgICAgcmVzdWx0LnVzYWdlID0ge1xuICAgICAgICBwcm9tcHRUb2tlbnM6IHR5cGVvZiB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgPT09IFwibnVtYmVyXCIgPyB2YWx1ZS51c2FnZS5wcm9tcHRUb2tlbnMgOiBOdW1iZXIuTmFOLFxuICAgICAgICBjb21wbGV0aW9uVG9rZW5zOiB0eXBlb2YgdmFsdWUudXNhZ2UuY29tcGxldGlvblRva2VucyA9PT0gXCJudW1iZXJcIiA/IHZhbHVlLnVzYWdlLmNvbXBsZXRpb25Ub2tlbnMgOiBOdW1iZXIuTmFOXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAoXCJpc0NvbnRpbnVlZFwiIGluIHZhbHVlICYmIHR5cGVvZiB2YWx1ZS5pc0NvbnRpbnVlZCA9PT0gXCJib29sZWFuXCIpIHtcbiAgICAgIHJlc3VsdC5pc0NvbnRpbnVlZCA9IHZhbHVlLmlzQ29udGludWVkO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgdHlwZTogXCJmaW5pc2hfc3RlcFwiLFxuICAgICAgdmFsdWU6IHJlc3VsdFxuICAgIH07XG4gIH1cbn07XG52YXIgc3RyZWFtUGFydHMgPSBbXG4gIHRleHRTdHJlYW1QYXJ0LFxuICBmdW5jdGlvbkNhbGxTdHJlYW1QYXJ0LFxuICBkYXRhU3RyZWFtUGFydCxcbiAgZXJyb3JTdHJlYW1QYXJ0LFxuICBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCxcbiAgYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LFxuICBkYXRhTWVzc2FnZVN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsc1N0cmVhbVBhcnQsXG4gIG1lc3NhZ2VBbm5vdGF0aW9uc1N0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtUGFydCxcbiAgdG9vbFJlc3VsdFN0cmVhbVBhcnQsXG4gIHRvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0LFxuICB0b29sQ2FsbERlbHRhU3RyZWFtUGFydCxcbiAgZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQsXG4gIGZpbmlzaFN0ZXBTdHJlYW1QYXJ0XG5dO1xudmFyIHN0cmVhbVBhcnRzQnlDb2RlID0ge1xuICBbdGV4dFN0cmVhbVBhcnQuY29kZV06IHRleHRTdHJlYW1QYXJ0LFxuICBbZnVuY3Rpb25DYWxsU3RyZWFtUGFydC5jb2RlXTogZnVuY3Rpb25DYWxsU3RyZWFtUGFydCxcbiAgW2RhdGFTdHJlYW1QYXJ0LmNvZGVdOiBkYXRhU3RyZWFtUGFydCxcbiAgW2Vycm9yU3RyZWFtUGFydC5jb2RlXTogZXJyb3JTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50TWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGFzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0LFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0LmNvZGVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQsXG4gIFtkYXRhTWVzc2FnZVN0cmVhbVBhcnQuY29kZV06IGRhdGFNZXNzYWdlU3RyZWFtUGFydCxcbiAgW3Rvb2xDYWxsc1N0cmVhbVBhcnQuY29kZV06IHRvb2xDYWxsc1N0cmVhbVBhcnQsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LFxuICBbdG9vbENhbGxTdHJlYW1QYXJ0LmNvZGVdOiB0b29sQ2FsbFN0cmVhbVBhcnQsXG4gIFt0b29sUmVzdWx0U3RyZWFtUGFydC5jb2RlXTogdG9vbFJlc3VsdFN0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQsXG4gIFt0b29sQ2FsbERlbHRhU3RyZWFtUGFydC5jb2RlXTogdG9vbENhbGxEZWx0YVN0cmVhbVBhcnQsXG4gIFtmaW5pc2hNZXNzYWdlU3RyZWFtUGFydC5jb2RlXTogZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQsXG4gIFtmaW5pc2hTdGVwU3RyZWFtUGFydC5jb2RlXTogZmluaXNoU3RlcFN0cmVhbVBhcnRcbn07XG52YXIgU3RyZWFtU3RyaW5nUHJlZml4ZXMgPSB7XG4gIFt0ZXh0U3RyZWFtUGFydC5uYW1lXTogdGV4dFN0cmVhbVBhcnQuY29kZSxcbiAgW2Z1bmN0aW9uQ2FsbFN0cmVhbVBhcnQubmFtZV06IGZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBkYXRhU3RyZWFtUGFydC5jb2RlLFxuICBbZXJyb3JTdHJlYW1QYXJ0Lm5hbWVdOiBlcnJvclN0cmVhbVBhcnQuY29kZSxcbiAgW2Fzc2lzdGFudE1lc3NhZ2VTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydC5jb2RlLFxuICBbYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0Lm5hbWVdOiBhc3Npc3RhbnRDb250cm9sRGF0YVN0cmVhbVBhcnQuY29kZSxcbiAgW2RhdGFNZXNzYWdlU3RyZWFtUGFydC5uYW1lXTogZGF0YU1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbHNTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbHNTdHJlYW1QYXJ0LmNvZGUsXG4gIFttZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0Lm5hbWVdOiBtZXNzYWdlQW5ub3RhdGlvbnNTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbVBhcnQubmFtZV06IHRvb2xDYWxsU3RyZWFtUGFydC5jb2RlLFxuICBbdG9vbFJlc3VsdFN0cmVhbVBhcnQubmFtZV06IHRvb2xSZXN1bHRTdHJlYW1QYXJ0LmNvZGUsXG4gIFt0b29sQ2FsbFN0cmVhbWluZ1N0YXJ0U3RyZWFtUGFydC5uYW1lXTogdG9vbENhbGxTdHJlYW1pbmdTdGFydFN0cmVhbVBhcnQuY29kZSxcbiAgW3Rvb2xDYWxsRGVsdGFTdHJlYW1QYXJ0Lm5hbWVdOiB0b29sQ2FsbERlbHRhU3RyZWFtUGFydC5jb2RlLFxuICBbZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQubmFtZV06IGZpbmlzaE1lc3NhZ2VTdHJlYW1QYXJ0LmNvZGUsXG4gIFtmaW5pc2hTdGVwU3RyZWFtUGFydC5uYW1lXTogZmluaXNoU3RlcFN0cmVhbVBhcnQuY29kZVxufTtcbnZhciB2YWxpZENvZGVzID0gc3RyZWFtUGFydHMubWFwKChwYXJ0KSA9PiBwYXJ0LmNvZGUpO1xudmFyIHBhcnNlU3RyZWFtUGFydCA9IChsaW5lKSA9PiB7XG4gIGNvbnN0IGZpcnN0U2VwYXJhdG9ySW5kZXggPSBsaW5lLmluZGV4T2YoXCI6XCIpO1xuICBpZiAoZmlyc3RTZXBhcmF0b3JJbmRleCA9PT0gLTEpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJGYWlsZWQgdG8gcGFyc2Ugc3RyZWFtIHN0cmluZy4gTm8gc2VwYXJhdG9yIGZvdW5kLlwiKTtcbiAgfVxuICBjb25zdCBwcmVmaXggPSBsaW5lLnNsaWNlKDAsIGZpcnN0U2VwYXJhdG9ySW5kZXgpO1xuICBpZiAoIXZhbGlkQ29kZXMuaW5jbHVkZXMocHJlZml4KSkge1xuICAgIHRocm93IG5ldyBFcnJvcihgRmFpbGVkIHRvIHBhcnNlIHN0cmVhbSBzdHJpbmcuIEludmFsaWQgY29kZSAke3ByZWZpeH0uYCk7XG4gIH1cbiAgY29uc3QgY29kZSA9IHByZWZpeDtcbiAgY29uc3QgdGV4dFZhbHVlID0gbGluZS5zbGljZShmaXJzdFNlcGFyYXRvckluZGV4ICsgMSk7XG4gIGNvbnN0IGpzb25WYWx1ZSA9IEpTT04ucGFyc2UodGV4dFZhbHVlKTtcbiAgcmV0dXJuIHN0cmVhbVBhcnRzQnlDb2RlW2NvZGVdLnBhcnNlKGpzb25WYWx1ZSk7XG59O1xuZnVuY3Rpb24gZm9ybWF0U3RyZWFtUGFydCh0eXBlLCB2YWx1ZSkge1xuICBjb25zdCBzdHJlYW1QYXJ0ID0gc3RyZWFtUGFydHMuZmluZCgocGFydCkgPT4gcGFydC5uYW1lID09PSB0eXBlKTtcbiAgaWYgKCFzdHJlYW1QYXJ0KSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKGBJbnZhbGlkIHN0cmVhbSBwYXJ0IHR5cGU6ICR7dHlwZX1gKTtcbiAgfVxuICByZXR1cm4gYCR7c3RyZWFtUGFydC5jb2RlfToke0pTT04uc3RyaW5naWZ5KHZhbHVlKX1cbmA7XG59XG5cbi8vIHNyYy9yZWFkLWRhdGEtc3RyZWFtLnRzXG52YXIgTkVXTElORSA9IFwiXFxuXCIuY2hhckNvZGVBdCgwKTtcbmZ1bmN0aW9uIGNvbmNhdENodW5rcyhjaHVua3MsIHRvdGFsTGVuZ3RoKSB7XG4gIGNvbnN0IGNvbmNhdGVuYXRlZENodW5rcyA9IG5ldyBVaW50OEFycmF5KHRvdGFsTGVuZ3RoKTtcbiAgbGV0IG9mZnNldCA9IDA7XG4gIGZvciAoY29uc3QgY2h1bmsgb2YgY2h1bmtzKSB7XG4gICAgY29uY2F0ZW5hdGVkQ2h1bmtzLnNldChjaHVuaywgb2Zmc2V0KTtcbiAgICBvZmZzZXQgKz0gY2h1bmsubGVuZ3RoO1xuICB9XG4gIGNodW5rcy5sZW5ndGggPSAwO1xuICByZXR1cm4gY29uY2F0ZW5hdGVkQ2h1bmtzO1xufVxuYXN5bmMgZnVuY3Rpb24qIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICBpc0Fib3J0ZWRcbn0gPSB7fSkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGNvbnN0IGNodW5rcyA9IFtdO1xuICBsZXQgdG90YWxMZW5ndGggPSAwO1xuICB3aGlsZSAodHJ1ZSkge1xuICAgIGNvbnN0IHsgdmFsdWUgfSA9IGF3YWl0IHJlYWRlci5yZWFkKCk7XG4gICAgaWYgKHZhbHVlKSB7XG4gICAgICBjaHVua3MucHVzaCh2YWx1ZSk7XG4gICAgICB0b3RhbExlbmd0aCArPSB2YWx1ZS5sZW5ndGg7XG4gICAgICBpZiAodmFsdWVbdmFsdWUubGVuZ3RoIC0gMV0gIT09IE5FV0xJTkUpIHtcbiAgICAgICAgY29udGludWU7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChjaHVua3MubGVuZ3RoID09PSAwKSB7XG4gICAgICBicmVhaztcbiAgICB9XG4gICAgY29uc3QgY29uY2F0ZW5hdGVkQ2h1bmtzID0gY29uY2F0Q2h1bmtzKGNodW5rcywgdG90YWxMZW5ndGgpO1xuICAgIHRvdGFsTGVuZ3RoID0gMDtcbiAgICBjb25zdCBzdHJlYW1QYXJ0czIgPSBkZWNvZGVyLmRlY29kZShjb25jYXRlbmF0ZWRDaHVua3MsIHsgc3RyZWFtOiB0cnVlIH0pLnNwbGl0KFwiXFxuXCIpLmZpbHRlcigobGluZSkgPT4gbGluZSAhPT0gXCJcIikubWFwKHBhcnNlU3RyZWFtUGFydCk7XG4gICAgZm9yIChjb25zdCBzdHJlYW1QYXJ0IG9mIHN0cmVhbVBhcnRzMikge1xuICAgICAgeWllbGQgc3RyZWFtUGFydDtcbiAgICB9XG4gICAgaWYgKGlzQWJvcnRlZCA9PSBudWxsID8gdm9pZCAwIDogaXNBYm9ydGVkKCkpIHtcbiAgICAgIHJlYWRlci5jYW5jZWwoKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvcHJvY2Vzcy1kYXRhLXByb3RvY29sLXJlc3BvbnNlLnRzXG5mdW5jdGlvbiBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShtZXNzYWdlLCBhbm5vdGF0aW9ucykge1xuICBpZiAoIW1lc3NhZ2UgfHwgIWFubm90YXRpb25zIHx8ICFhbm5vdGF0aW9ucy5sZW5ndGgpXG4gICAgcmV0dXJuIG1lc3NhZ2U7XG4gIHJldHVybiB7IC4uLm1lc3NhZ2UsIGFubm90YXRpb25zOiBbLi4uYW5ub3RhdGlvbnNdIH07XG59XG5hc3luYyBmdW5jdGlvbiBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2Uoe1xuICByZWFkZXIsXG4gIGFib3J0Q29udHJvbGxlclJlZixcbiAgdXBkYXRlLFxuICBvblRvb2xDYWxsLFxuICBvbkZpbmlzaCxcbiAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDIgPSBnZW5lcmF0ZUlkRnVuY3Rpb24sXG4gIGdldEN1cnJlbnREYXRlID0gKCkgPT4gLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKClcbn0pIHtcbiAgdmFyIF9hO1xuICBjb25zdCBjcmVhdGVkQXQgPSBnZXRDdXJyZW50RGF0ZSgpO1xuICBsZXQgcHJlZml4TWFwID0ge307XG4gIGxldCBuZXh0UHJlZml4TWFwID0gdm9pZCAwO1xuICBjb25zdCBwcmV2aW91c01lc3NhZ2VzID0gW107XG4gIGNvbnN0IGRhdGEgPSBbXTtcbiAgbGV0IG1lc3NhZ2VBbm5vdGF0aW9ucyA9IHZvaWQgMDtcbiAgY29uc3QgcGFydGlhbFRvb2xDYWxscyA9IHt9O1xuICBsZXQgdXNhZ2UgPSB7XG4gICAgY29tcGxldGlvblRva2VuczogTmFOLFxuICAgIHByb21wdFRva2VuczogTmFOLFxuICAgIHRvdGFsVG9rZW5zOiBOYU5cbiAgfTtcbiAgbGV0IGZpbmlzaFJlYXNvbiA9IFwidW5rbm93blwiO1xuICBmb3IgYXdhaXQgKGNvbnN0IHsgdHlwZSwgdmFsdWUgfSBvZiByZWFkRGF0YVN0cmVhbShyZWFkZXIsIHtcbiAgICBpc0Fib3J0ZWQ6ICgpID0+IChhYm9ydENvbnRyb2xsZXJSZWYgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlclJlZi5jdXJyZW50KSA9PT0gbnVsbFxuICB9KSkge1xuICAgIGlmICh0eXBlID09PSBcImVycm9yXCIpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcih2YWx1ZSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImZpbmlzaF9zdGVwXCIpIHtcbiAgICAgIGlmICghdmFsdWUuaXNDb250aW51ZWQpIHtcbiAgICAgICAgbmV4dFByZWZpeE1hcCA9IHt9O1xuICAgICAgfVxuICAgICAgY29udGludWU7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImZpbmlzaF9tZXNzYWdlXCIpIHtcbiAgICAgIGZpbmlzaFJlYXNvbiA9IHZhbHVlLmZpbmlzaFJlYXNvbjtcbiAgICAgIGlmICh2YWx1ZS51c2FnZSAhPSBudWxsKSB7XG4gICAgICAgIGNvbnN0IHsgY29tcGxldGlvblRva2VucywgcHJvbXB0VG9rZW5zIH0gPSB2YWx1ZS51c2FnZTtcbiAgICAgICAgdXNhZ2UgPSB7XG4gICAgICAgICAgY29tcGxldGlvblRva2VucyxcbiAgICAgICAgICBwcm9tcHRUb2tlbnMsXG4gICAgICAgICAgdG90YWxUb2tlbnM6IGNvbXBsZXRpb25Ub2tlbnMgKyBwcm9tcHRUb2tlbnNcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGNvbnRpbnVlO1xuICAgIH1cbiAgICBpZiAobmV4dFByZWZpeE1hcCAhPSBudWxsICYmICh0eXBlID09PSBcInRleHRcIiB8fCB0eXBlID09PSBcInRvb2xfY2FsbFwiIHx8IHR5cGUgPT09IFwidG9vbF9jYWxsX3N0cmVhbWluZ19zdGFydFwiIHx8IHR5cGUgPT09IFwidG9vbF9jYWxsX2RlbHRhXCIgfHwgdHlwZSA9PT0gXCJ0b29sX3Jlc3VsdFwiKSkge1xuICAgICAgaWYgKHByZWZpeE1hcC50ZXh0KSB7XG4gICAgICAgIHByZXZpb3VzTWVzc2FnZXMucHVzaChwcmVmaXhNYXAudGV4dCk7XG4gICAgICB9XG4gICAgICBpZiAocHJlZml4TWFwLmZ1bmN0aW9uX2NhbGwpIHtcbiAgICAgICAgcHJldmlvdXNNZXNzYWdlcy5wdXNoKHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhNYXAudG9vbF9jYWxscykge1xuICAgICAgICBwcmV2aW91c01lc3NhZ2VzLnB1c2gocHJlZml4TWFwLnRvb2xfY2FsbHMpO1xuICAgICAgfVxuICAgICAgcHJlZml4TWFwID0gbmV4dFByZWZpeE1hcDtcbiAgICAgIG5leHRQcmVmaXhNYXAgPSB2b2lkIDA7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcInRleHRcIikge1xuICAgICAgaWYgKHByZWZpeE1hcFtcInRleHRcIl0pIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICAuLi5wcmVmaXhNYXBbXCJ0ZXh0XCJdLFxuICAgICAgICAgIGNvbnRlbnQ6IChwcmVmaXhNYXBbXCJ0ZXh0XCJdLmNvbnRlbnQgfHwgXCJcIikgKyB2YWx1ZVxuICAgICAgICB9O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcHJlZml4TWFwW1widGV4dFwiXSA9IHtcbiAgICAgICAgICBpZDogZ2VuZXJhdGVJZDIoKSxcbiAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgIGNvbnRlbnQ6IHZhbHVlLFxuICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICB9O1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gXCJ0b29sX2NhbGxfc3RyZWFtaW5nX3N0YXJ0XCIpIHtcbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dCA9PSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0ID0ge1xuICAgICAgICAgIGlkOiBnZW5lcmF0ZUlkMigpLFxuICAgICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICBjcmVhdGVkQXRcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMgPSBbXTtcbiAgICAgIH1cbiAgICAgIHBhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF0gPSB7XG4gICAgICAgIHRleHQ6IFwiXCIsXG4gICAgICAgIHRvb2xOYW1lOiB2YWx1ZS50b29sTmFtZSxcbiAgICAgICAgcHJlZml4TWFwSW5kZXg6IHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucy5sZW5ndGhcbiAgICAgIH07XG4gICAgICBwcmVmaXhNYXAudGV4dC50b29sSW52b2NhdGlvbnMucHVzaCh7XG4gICAgICAgIHN0YXRlOiBcInBhcnRpYWwtY2FsbFwiLFxuICAgICAgICB0b29sQ2FsbElkOiB2YWx1ZS50b29sQ2FsbElkLFxuICAgICAgICB0b29sTmFtZTogdmFsdWUudG9vbE5hbWUsXG4gICAgICAgIGFyZ3M6IHZvaWQgMFxuICAgICAgfSk7XG4gICAgfSBlbHNlIGlmICh0eXBlID09PSBcInRvb2xfY2FsbF9kZWx0YVwiKSB7XG4gICAgICBjb25zdCBwYXJ0aWFsVG9vbENhbGwgPSBwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdO1xuICAgICAgcGFydGlhbFRvb2xDYWxsLnRleHQgKz0gdmFsdWUuYXJnc1RleHREZWx0YTtcbiAgICAgIGNvbnN0IHsgdmFsdWU6IHBhcnRpYWxBcmdzIH0gPSBwYXJzZVBhcnRpYWxKc29uKHBhcnRpYWxUb29sQ2FsbC50ZXh0KTtcbiAgICAgIHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9uc1twYXJ0aWFsVG9vbENhbGwucHJlZml4TWFwSW5kZXhdID0ge1xuICAgICAgICBzdGF0ZTogXCJwYXJ0aWFsLWNhbGxcIixcbiAgICAgICAgdG9vbENhbGxJZDogdmFsdWUudG9vbENhbGxJZCxcbiAgICAgICAgdG9vbE5hbWU6IHBhcnRpYWxUb29sQ2FsbC50b29sTmFtZSxcbiAgICAgICAgYXJnczogcGFydGlhbEFyZ3NcbiAgICAgIH07XG4gICAgICBwcmVmaXhNYXAudGV4dC5pbnRlcm5hbFVwZGF0ZUlkID0gZ2VuZXJhdGVJZDIoKTtcbiAgICB9IGVsc2UgaWYgKHR5cGUgPT09IFwidG9vbF9jYWxsXCIpIHtcbiAgICAgIGlmIChwYXJ0aWFsVG9vbENhbGxzW3ZhbHVlLnRvb2xDYWxsSWRdICE9IG51bGwpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zW3BhcnRpYWxUb29sQ2FsbHNbdmFsdWUudG9vbENhbGxJZF0ucHJlZml4TWFwSW5kZXhdID0geyBzdGF0ZTogXCJjYWxsXCIsIC4uLnZhbHVlIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJlZml4TWFwLnRleHQgPT0gbnVsbCkge1xuICAgICAgICAgIHByZWZpeE1hcC50ZXh0ID0ge1xuICAgICAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgICAgICByb2xlOiBcImFzc2lzdGFudFwiLFxuICAgICAgICAgICAgY29udGVudDogXCJcIixcbiAgICAgICAgICAgIGNyZWF0ZWRBdFxuICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucyA9PSBudWxsKSB7XG4gICAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zID0gW107XG4gICAgICAgIH1cbiAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zLnB1c2goe1xuICAgICAgICAgIHN0YXRlOiBcImNhbGxcIixcbiAgICAgICAgICAuLi52YWx1ZVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIHByZWZpeE1hcC50ZXh0LmludGVybmFsVXBkYXRlSWQgPSBnZW5lcmF0ZUlkMigpO1xuICAgICAgaWYgKG9uVG9vbENhbGwpIHtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgb25Ub29sQ2FsbCh7IHRvb2xDYWxsOiB2YWx1ZSB9KTtcbiAgICAgICAgaWYgKHJlc3VsdCAhPSBudWxsKSB7XG4gICAgICAgICAgcHJlZml4TWFwLnRleHQudG9vbEludm9jYXRpb25zW3ByZWZpeE1hcC50ZXh0LnRvb2xJbnZvY2F0aW9ucy5sZW5ndGggLSAxXSA9IHsgc3RhdGU6IFwicmVzdWx0XCIsIC4uLnZhbHVlLCByZXN1bHQgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAodHlwZSA9PT0gXCJ0b29sX3Jlc3VsdFwiKSB7XG4gICAgICBjb25zdCB0b29sSW52b2NhdGlvbnMgPSAoX2EgPSBwcmVmaXhNYXAudGV4dCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9hLnRvb2xJbnZvY2F0aW9ucztcbiAgICAgIGlmICh0b29sSW52b2NhdGlvbnMgPT0gbnVsbCkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXCJ0b29sX3Jlc3VsdCBtdXN0IGJlIHByZWNlZGVkIGJ5IGEgdG9vbF9jYWxsXCIpO1xuICAgICAgfVxuICAgICAgY29uc3QgdG9vbEludm9jYXRpb25JbmRleCA9IHRvb2xJbnZvY2F0aW9ucy5maW5kSW5kZXgoXG4gICAgICAgIChpbnZvY2F0aW9uKSA9PiBpbnZvY2F0aW9uLnRvb2xDYWxsSWQgPT09IHZhbHVlLnRvb2xDYWxsSWRcbiAgICAgICk7XG4gICAgICBpZiAodG9vbEludm9jYXRpb25JbmRleCA9PT0gLTEpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgIFwidG9vbF9yZXN1bHQgbXVzdCBiZSBwcmVjZWRlZCBieSBhIHRvb2xfY2FsbCB3aXRoIHRoZSBzYW1lIHRvb2xDYWxsSWRcIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdG9vbEludm9jYXRpb25zW3Rvb2xJbnZvY2F0aW9uSW5kZXhdID0ge1xuICAgICAgICAuLi50b29sSW52b2NhdGlvbnNbdG9vbEludm9jYXRpb25JbmRleF0sXG4gICAgICAgIHN0YXRlOiBcInJlc3VsdFwiLFxuICAgICAgICAuLi52YWx1ZVxuICAgICAgfTtcbiAgICB9XG4gICAgbGV0IGZ1bmN0aW9uQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcImZ1bmN0aW9uX2NhbGxcIikge1xuICAgICAgcHJlZml4TWFwW1wiZnVuY3Rpb25fY2FsbFwiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIGZ1bmN0aW9uX2NhbGw6IHZhbHVlLmZ1bmN0aW9uX2NhbGwsXG4gICAgICAgIG5hbWU6IHZhbHVlLmZ1bmN0aW9uX2NhbGwubmFtZSxcbiAgICAgICAgY3JlYXRlZEF0XG4gICAgICB9O1xuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcImZ1bmN0aW9uX2NhbGxcIl07XG4gICAgfVxuICAgIGxldCB0b29sQ2FsbE1lc3NhZ2UgPSBudWxsO1xuICAgIGlmICh0eXBlID09PSBcInRvb2xfY2FsbHNcIikge1xuICAgICAgcHJlZml4TWFwW1widG9vbF9jYWxsc1wiXSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCIsXG4gICAgICAgIHRvb2xfY2FsbHM6IHZhbHVlLnRvb2xfY2FsbHMsXG4gICAgICAgIGNyZWF0ZWRBdFxuICAgICAgfTtcbiAgICAgIHRvb2xDYWxsTWVzc2FnZSA9IHByZWZpeE1hcFtcInRvb2xfY2FsbHNcIl07XG4gICAgfVxuICAgIGlmICh0eXBlID09PSBcImRhdGFcIikge1xuICAgICAgZGF0YS5wdXNoKC4uLnZhbHVlKTtcbiAgICB9XG4gICAgbGV0IHJlc3BvbnNlTWVzc2FnZSA9IHByZWZpeE1hcFtcInRleHRcIl07XG4gICAgaWYgKHR5cGUgPT09IFwibWVzc2FnZV9hbm5vdGF0aW9uc1wiKSB7XG4gICAgICBpZiAoIW1lc3NhZ2VBbm5vdGF0aW9ucykge1xuICAgICAgICBtZXNzYWdlQW5ub3RhdGlvbnMgPSBbLi4udmFsdWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZUFubm90YXRpb25zLnB1c2goLi4udmFsdWUpO1xuICAgICAgfVxuICAgICAgZnVuY3Rpb25DYWxsTWVzc2FnZSA9IGFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKFxuICAgICAgICBwcmVmaXhNYXBbXCJmdW5jdGlvbl9jYWxsXCJdLFxuICAgICAgICBtZXNzYWdlQW5ub3RhdGlvbnNcbiAgICAgICk7XG4gICAgICB0b29sQ2FsbE1lc3NhZ2UgPSBhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZShcbiAgICAgICAgcHJlZml4TWFwW1widG9vbF9jYWxsc1wiXSxcbiAgICAgICAgbWVzc2FnZUFubm90YXRpb25zXG4gICAgICApO1xuICAgICAgcmVzcG9uc2VNZXNzYWdlID0gYXNzaWduQW5ub3RhdGlvbnNUb01lc3NhZ2UoXG4gICAgICAgIHByZWZpeE1hcFtcInRleHRcIl0sXG4gICAgICAgIG1lc3NhZ2VBbm5vdGF0aW9uc1xuICAgICAgKTtcbiAgICAgIGlmIChwcmVmaXhNYXAudGV4dCAhPSBudWxsKSB7XG4gICAgICAgIHByZWZpeE1hcC50ZXh0LmludGVybmFsVXBkYXRlSWQgPSBnZW5lcmF0ZUlkMigpO1xuICAgICAgfVxuICAgIH1cbiAgICBpZiAobWVzc2FnZUFubm90YXRpb25zID09IG51bGwgPyB2b2lkIDAgOiBtZXNzYWdlQW5ub3RhdGlvbnMubGVuZ3RoKSB7XG4gICAgICBpZiAocHJlZml4TWFwLnRleHQpIHtcbiAgICAgICAgcHJlZml4TWFwLnRleHQuYW5ub3RhdGlvbnMgPSBbLi4ubWVzc2FnZUFubm90YXRpb25zXTtcbiAgICAgIH1cbiAgICAgIGlmIChwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbCkge1xuICAgICAgICBwcmVmaXhNYXAuZnVuY3Rpb25fY2FsbC5hbm5vdGF0aW9ucyA9IFsuLi5tZXNzYWdlQW5ub3RhdGlvbnNdO1xuICAgICAgfVxuICAgICAgaWYgKHByZWZpeE1hcC50b29sX2NhbGxzKSB7XG4gICAgICAgIHByZWZpeE1hcC50b29sX2NhbGxzLmFubm90YXRpb25zID0gWy4uLm1lc3NhZ2VBbm5vdGF0aW9uc107XG4gICAgICB9XG4gICAgfVxuICAgIGNvbnN0IG1lcmdlZCA9IFtmdW5jdGlvbkNhbGxNZXNzYWdlLCB0b29sQ2FsbE1lc3NhZ2UsIHJlc3BvbnNlTWVzc2FnZV0uZmlsdGVyKEJvb2xlYW4pLm1hcCgobWVzc2FnZSkgPT4gKHtcbiAgICAgIC4uLmFzc2lnbkFubm90YXRpb25zVG9NZXNzYWdlKG1lc3NhZ2UsIG1lc3NhZ2VBbm5vdGF0aW9ucylcbiAgICB9KSk7XG4gICAgdXBkYXRlKFsuLi5wcmV2aW91c01lc3NhZ2VzLCAuLi5tZXJnZWRdLCBbLi4uZGF0YV0pO1xuICB9XG4gIG9uRmluaXNoID09IG51bGwgPyB2b2lkIDAgOiBvbkZpbmlzaCh7IG1lc3NhZ2U6IHByZWZpeE1hcC50ZXh0LCBmaW5pc2hSZWFzb24sIHVzYWdlIH0pO1xuICByZXR1cm4ge1xuICAgIG1lc3NhZ2VzOiBbXG4gICAgICBwcmVmaXhNYXAudGV4dCxcbiAgICAgIHByZWZpeE1hcC5mdW5jdGlvbl9jYWxsLFxuICAgICAgcHJlZml4TWFwLnRvb2xfY2FsbHNcbiAgICBdLmZpbHRlcihCb29sZWFuKSxcbiAgICBkYXRhXG4gIH07XG59XG5cbi8vIHNyYy9jYWxsLWNoYXQtYXBpLnRzXG52YXIgZ2V0T3JpZ2luYWxGZXRjaCA9ICgpID0+IGZldGNoO1xuYXN5bmMgZnVuY3Rpb24gY2FsbENoYXRBcGkoe1xuICBhcGksXG4gIGJvZHksXG4gIHN0cmVhbVByb3RvY29sID0gXCJkYXRhXCIsXG4gIGNyZWRlbnRpYWxzLFxuICBoZWFkZXJzLFxuICBhYm9ydENvbnRyb2xsZXIsXG4gIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSxcbiAgb25SZXNwb25zZSxcbiAgb25VcGRhdGUsXG4gIG9uRmluaXNoLFxuICBvblRvb2xDYWxsLFxuICBnZW5lcmF0ZUlkOiBnZW5lcmF0ZUlkMixcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2goKVxufSkge1xuICB2YXIgX2EsIF9iO1xuICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGZldGNoMihhcGksIHtcbiAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLFxuICAgIGhlYWRlcnM6IHtcbiAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgLi4uaGVhZGVyc1xuICAgIH0sXG4gICAgc2lnbmFsOiAoX2EgPSBhYm9ydENvbnRyb2xsZXIgPT0gbnVsbCA/IHZvaWQgMCA6IGFib3J0Q29udHJvbGxlcigpKSA9PSBudWxsID8gdm9pZCAwIDogX2Euc2lnbmFsLFxuICAgIGNyZWRlbnRpYWxzXG4gIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICByZXN0b3JlTWVzc2FnZXNPbkZhaWx1cmUoKTtcbiAgICB0aHJvdyBlcnI7XG4gIH0pO1xuICBpZiAob25SZXNwb25zZSkge1xuICAgIHRyeSB7XG4gICAgICBhd2FpdCBvblJlc3BvbnNlKHJlc3BvbnNlKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG4gIH1cbiAgaWYgKCFyZXNwb25zZS5vaykge1xuICAgIHJlc3RvcmVNZXNzYWdlc09uRmFpbHVyZSgpO1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIChfYiA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKSkgIT0gbnVsbCA/IF9iIDogXCJGYWlsZWQgdG8gZmV0Y2ggdGhlIGNoYXQgcmVzcG9uc2UuXCJcbiAgICApO1xuICB9XG4gIGlmICghcmVzcG9uc2UuYm9keSkge1xuICAgIHRocm93IG5ldyBFcnJvcihcIlRoZSByZXNwb25zZSBib2R5IGlzIGVtcHR5LlwiKTtcbiAgfVxuICBjb25zdCByZWFkZXIgPSByZXNwb25zZS5ib2R5LmdldFJlYWRlcigpO1xuICBzd2l0Y2ggKHN0cmVhbVByb3RvY29sKSB7XG4gICAgY2FzZSBcInRleHRcIjoge1xuICAgICAgY29uc3QgZGVjb2RlciA9IGNyZWF0ZUNodW5rRGVjb2RlcigpO1xuICAgICAgY29uc3QgcmVzdWx0TWVzc2FnZSA9IHtcbiAgICAgICAgaWQ6IGdlbmVyYXRlSWQyKCksXG4gICAgICAgIGNyZWF0ZWRBdDogLyogQF9fUFVSRV9fICovIG5ldyBEYXRlKCksXG4gICAgICAgIHJvbGU6IFwiYXNzaXN0YW50XCIsXG4gICAgICAgIGNvbnRlbnQ6IFwiXCJcbiAgICAgIH07XG4gICAgICB3aGlsZSAodHJ1ZSkge1xuICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAoZG9uZSkge1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdE1lc3NhZ2UuY29udGVudCArPSBkZWNvZGVyKHZhbHVlKTtcbiAgICAgICAgb25VcGRhdGUoW3sgLi4ucmVzdWx0TWVzc2FnZSB9XSwgW10pO1xuICAgICAgICBpZiAoKGFib3J0Q29udHJvbGxlciA9PSBudWxsID8gdm9pZCAwIDogYWJvcnRDb250cm9sbGVyKCkpID09PSBudWxsKSB7XG4gICAgICAgICAgcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBvbkZpbmlzaCA9PSBudWxsID8gdm9pZCAwIDogb25GaW5pc2gocmVzdWx0TWVzc2FnZSwge1xuICAgICAgICB1c2FnZTogeyBjb21wbGV0aW9uVG9rZW5zOiBOYU4sIHByb21wdFRva2VuczogTmFOLCB0b3RhbFRva2VuczogTmFOIH0sXG4gICAgICAgIGZpbmlzaFJlYXNvbjogXCJ1bmtub3duXCJcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgbWVzc2FnZXM6IFtyZXN1bHRNZXNzYWdlXSxcbiAgICAgICAgZGF0YTogW11cbiAgICAgIH07XG4gICAgfVxuICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgIHJldHVybiBhd2FpdCBwcm9jZXNzRGF0YVByb3RvY29sUmVzcG9uc2Uoe1xuICAgICAgICByZWFkZXIsXG4gICAgICAgIGFib3J0Q29udHJvbGxlclJlZjogYWJvcnRDb250cm9sbGVyICE9IG51bGwgPyB7IGN1cnJlbnQ6IGFib3J0Q29udHJvbGxlcigpIH0gOiB2b2lkIDAsXG4gICAgICAgIHVwZGF0ZTogb25VcGRhdGUsXG4gICAgICAgIG9uVG9vbENhbGwsXG4gICAgICAgIG9uRmluaXNoKHsgbWVzc2FnZSwgZmluaXNoUmVhc29uLCB1c2FnZSB9KSB7XG4gICAgICAgICAgaWYgKG9uRmluaXNoICYmIG1lc3NhZ2UgIT0gbnVsbCkge1xuICAgICAgICAgICAgb25GaW5pc2gobWVzc2FnZSwgeyB1c2FnZSwgZmluaXNoUmVhc29uIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZ2VuZXJhdGVJZDogZ2VuZXJhdGVJZDJcbiAgICAgIH0pO1xuICAgIH1cbiAgICBkZWZhdWx0OiB7XG4gICAgICBjb25zdCBleGhhdXN0aXZlQ2hlY2sgPSBzdHJlYW1Qcm90b2NvbDtcbiAgICAgIHRocm93IG5ldyBFcnJvcihgVW5rbm93biBzdHJlYW0gcHJvdG9jb2w6ICR7ZXhoYXVzdGl2ZUNoZWNrfWApO1xuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvY2FsbC1jb21wbGV0aW9uLWFwaS50c1xudmFyIGdldE9yaWdpbmFsRmV0Y2gyID0gKCkgPT4gZmV0Y2g7XG5hc3luYyBmdW5jdGlvbiBjYWxsQ29tcGxldGlvbkFwaSh7XG4gIGFwaSxcbiAgcHJvbXB0LFxuICBjcmVkZW50aWFscyxcbiAgaGVhZGVycyxcbiAgYm9keSxcbiAgc3RyZWFtUHJvdG9jb2wgPSBcImRhdGFcIixcbiAgc2V0Q29tcGxldGlvbixcbiAgc2V0TG9hZGluZyxcbiAgc2V0RXJyb3IsXG4gIHNldEFib3J0Q29udHJvbGxlcixcbiAgb25SZXNwb25zZSxcbiAgb25GaW5pc2gsXG4gIG9uRXJyb3IsXG4gIG9uRGF0YSxcbiAgZmV0Y2g6IGZldGNoMiA9IGdldE9yaWdpbmFsRmV0Y2gyKClcbn0pIHtcbiAgdHJ5IHtcbiAgICBzZXRMb2FkaW5nKHRydWUpO1xuICAgIHNldEVycm9yKHZvaWQgMCk7XG4gICAgY29uc3QgYWJvcnRDb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHNldEFib3J0Q29udHJvbGxlcihhYm9ydENvbnRyb2xsZXIpO1xuICAgIHNldENvbXBsZXRpb24oXCJcIik7XG4gICAgY29uc3QgcmVzID0gYXdhaXQgZmV0Y2gyKGFwaSwge1xuICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KHtcbiAgICAgICAgcHJvbXB0LFxuICAgICAgICAuLi5ib2R5XG4gICAgICB9KSxcbiAgICAgIGNyZWRlbnRpYWxzLFxuICAgICAgaGVhZGVyczoge1xuICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgLi4uaGVhZGVyc1xuICAgICAgfSxcbiAgICAgIHNpZ25hbDogYWJvcnRDb250cm9sbGVyLnNpZ25hbFxuICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgIHRocm93IGVycjtcbiAgICB9KTtcbiAgICBpZiAob25SZXNwb25zZSkge1xuICAgICAgdHJ5IHtcbiAgICAgICAgYXdhaXQgb25SZXNwb25zZShyZXMpO1xuICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgIHRocm93IGVycjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFyZXMub2spIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgYXdhaXQgcmVzLnRleHQoKSB8fCBcIkZhaWxlZCB0byBmZXRjaCB0aGUgY2hhdCByZXNwb25zZS5cIlxuICAgICAgKTtcbiAgICB9XG4gICAgaWYgKCFyZXMuYm9keSkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHJlc3BvbnNlIGJvZHkgaXMgZW1wdHkuXCIpO1xuICAgIH1cbiAgICBsZXQgcmVzdWx0ID0gXCJcIjtcbiAgICBjb25zdCByZWFkZXIgPSByZXMuYm9keS5nZXRSZWFkZXIoKTtcbiAgICBzd2l0Y2ggKHN0cmVhbVByb3RvY29sKSB7XG4gICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgIGNvbnN0IGRlY29kZXIgPSBjcmVhdGVDaHVua0RlY29kZXIoKTtcbiAgICAgICAgd2hpbGUgKHRydWUpIHtcbiAgICAgICAgICBjb25zdCB7IGRvbmUsIHZhbHVlIH0gPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICAgIGlmIChkb25lKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgcmVzdWx0ICs9IGRlY29kZXIodmFsdWUpO1xuICAgICAgICAgIHNldENvbXBsZXRpb24ocmVzdWx0KTtcbiAgICAgICAgICBpZiAoYWJvcnRDb250cm9sbGVyID09PSBudWxsKSB7XG4gICAgICAgICAgICByZWFkZXIuY2FuY2VsKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBjYXNlIFwiZGF0YVwiOiB7XG4gICAgICAgIGZvciBhd2FpdCAoY29uc3QgeyB0eXBlLCB2YWx1ZSB9IG9mIHJlYWREYXRhU3RyZWFtKHJlYWRlciwge1xuICAgICAgICAgIGlzQWJvcnRlZDogKCkgPT4gYWJvcnRDb250cm9sbGVyID09PSBudWxsXG4gICAgICAgIH0pKSB7XG4gICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlIFwidGV4dFwiOiB7XG4gICAgICAgICAgICAgIHJlc3VsdCArPSB2YWx1ZTtcbiAgICAgICAgICAgICAgc2V0Q29tcGxldGlvbihyZXN1bHQpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgXCJkYXRhXCI6IHtcbiAgICAgICAgICAgICAgb25EYXRhID09IG51bGwgPyB2b2lkIDAgOiBvbkRhdGEodmFsdWUpO1xuICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgICBkZWZhdWx0OiB7XG4gICAgICAgIGNvbnN0IGV4aGF1c3RpdmVDaGVjayA9IHN0cmVhbVByb3RvY29sO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoYFVua25vd24gc3RyZWFtIHByb3RvY29sOiAke2V4aGF1c3RpdmVDaGVja31gKTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9uRmluaXNoKSB7XG4gICAgICBvbkZpbmlzaChwcm9tcHQsIHJlc3VsdCk7XG4gICAgfVxuICAgIHNldEFib3J0Q29udHJvbGxlcihudWxsKTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICBpZiAoZXJyLm5hbWUgPT09IFwiQWJvcnRFcnJvclwiKSB7XG4gICAgICBzZXRBYm9ydENvbnRyb2xsZXIobnVsbCk7XG4gICAgICByZXR1cm4gbnVsbDtcbiAgICB9XG4gICAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBpZiAob25FcnJvcikge1xuICAgICAgICBvbkVycm9yKGVycik7XG4gICAgICB9XG4gICAgfVxuICAgIHNldEVycm9yKGVycik7XG4gIH0gZmluYWxseSB7XG4gICAgc2V0TG9hZGluZyhmYWxzZSk7XG4gIH1cbn1cblxuLy8gc3JjL2NyZWF0ZS1jaHVuay1kZWNvZGVyLnRzXG5mdW5jdGlvbiBjcmVhdGVDaHVua0RlY29kZXIoY29tcGxleCkge1xuICBjb25zdCBkZWNvZGVyID0gbmV3IFRleHREZWNvZGVyKCk7XG4gIGlmICghY29tcGxleCkge1xuICAgIHJldHVybiBmdW5jdGlvbihjaHVuaykge1xuICAgICAgaWYgKCFjaHVuaylcbiAgICAgICAgcmV0dXJuIFwiXCI7XG4gICAgICByZXR1cm4gZGVjb2Rlci5kZWNvZGUoY2h1bmssIHsgc3RyZWFtOiB0cnVlIH0pO1xuICAgIH07XG4gIH1cbiAgcmV0dXJuIGZ1bmN0aW9uKGNodW5rKSB7XG4gICAgY29uc3QgZGVjb2RlZCA9IGRlY29kZXIuZGVjb2RlKGNodW5rLCB7IHN0cmVhbTogdHJ1ZSB9KS5zcGxpdChcIlxcblwiKS5maWx0ZXIoKGxpbmUpID0+IGxpbmUgIT09IFwiXCIpO1xuICAgIHJldHVybiBkZWNvZGVkLm1hcChwYXJzZVN0cmVhbVBhcnQpLmZpbHRlcihCb29sZWFuKTtcbiAgfTtcbn1cblxuLy8gc3JjL2RhdGEtdXJsLnRzXG5mdW5jdGlvbiBnZXRUZXh0RnJvbURhdGFVcmwoZGF0YVVybCkge1xuICBjb25zdCBbaGVhZGVyLCBiYXNlNjRDb250ZW50XSA9IGRhdGFVcmwuc3BsaXQoXCIsXCIpO1xuICBjb25zdCBtaW1lVHlwZSA9IGhlYWRlci5zcGxpdChcIjtcIilbMF0uc3BsaXQoXCI6XCIpWzFdO1xuICBpZiAobWltZVR5cGUgPT0gbnVsbCB8fCBiYXNlNjRDb250ZW50ID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIGRhdGEgVVJMIGZvcm1hdFwiKTtcbiAgfVxuICB0cnkge1xuICAgIHJldHVybiB3aW5kb3cuYXRvYihiYXNlNjRDb250ZW50KTtcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoYEVycm9yIGRlY29kaW5nIGRhdGEgVVJMYCk7XG4gIH1cbn1cblxuLy8gc3JjL2lzLWRlZXAtZXF1YWwtZGF0YS50c1xuZnVuY3Rpb24gaXNEZWVwRXF1YWxEYXRhKG9iajEsIG9iajIpIHtcbiAgaWYgKG9iajEgPT09IG9iajIpXG4gICAgcmV0dXJuIHRydWU7XG4gIGlmIChvYmoxID09IG51bGwgfHwgb2JqMiA9PSBudWxsKVxuICAgIHJldHVybiBmYWxzZTtcbiAgaWYgKHR5cGVvZiBvYmoxICE9PSBcIm9iamVjdFwiICYmIHR5cGVvZiBvYmoyICE9PSBcIm9iamVjdFwiKVxuICAgIHJldHVybiBvYmoxID09PSBvYmoyO1xuICBpZiAob2JqMS5jb25zdHJ1Y3RvciAhPT0gb2JqMi5jb25zdHJ1Y3RvcilcbiAgICByZXR1cm4gZmFsc2U7XG4gIGlmIChvYmoxIGluc3RhbmNlb2YgRGF0ZSAmJiBvYmoyIGluc3RhbmNlb2YgRGF0ZSkge1xuICAgIHJldHVybiBvYmoxLmdldFRpbWUoKSA9PT0gb2JqMi5nZXRUaW1lKCk7XG4gIH1cbiAgaWYgKEFycmF5LmlzQXJyYXkob2JqMSkpIHtcbiAgICBpZiAob2JqMS5sZW5ndGggIT09IG9iajIubGVuZ3RoKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgb2JqMS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtpXSwgb2JqMltpXSkpXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmoxKTtcbiAgY29uc3Qga2V5czIgPSBPYmplY3Qua2V5cyhvYmoyKTtcbiAgaWYgKGtleXMxLmxlbmd0aCAhPT0ga2V5czIubGVuZ3RoKVxuICAgIHJldHVybiBmYWxzZTtcbiAgZm9yIChjb25zdCBrZXkgb2Yga2V5czEpIHtcbiAgICBpZiAoIWtleXMyLmluY2x1ZGVzKGtleSkpXG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgaWYgKCFpc0RlZXBFcXVhbERhdGEob2JqMVtrZXldLCBvYmoyW2tleV0pKVxuICAgICAgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG4vLyBzcmMvcHJvY2Vzcy1jaGF0LXN0cmVhbS50c1xuYXN5bmMgZnVuY3Rpb24gcHJvY2Vzc0NoYXRTdHJlYW0oe1xuICBnZXRTdHJlYW1lZFJlc3BvbnNlLFxuICBleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwsXG4gIGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsLFxuICB1cGRhdGVDaGF0UmVxdWVzdCxcbiAgZ2V0Q3VycmVudE1lc3NhZ2VzXG59KSB7XG4gIHdoaWxlICh0cnVlKSB7XG4gICAgY29uc3QgbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSA9IGF3YWl0IGdldFN0cmVhbWVkUmVzcG9uc2UoKTtcbiAgICBpZiAoXCJtZXNzYWdlc1wiIGluIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UpIHtcbiAgICAgIGxldCBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IGZhbHNlO1xuICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIG1lc3NhZ2VzQW5kRGF0YU9ySnVzdE1lc3NhZ2UubWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwgPT09IHZvaWQgMCB8fCB0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcInN0cmluZ1wiKSAmJiAobWVzc2FnZS50b29sX2NhbGxzID09PSB2b2lkIDAgfHwgdHlwZW9mIG1lc3NhZ2UudG9vbF9jYWxscyA9PT0gXCJzdHJpbmdcIikpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBoYXNGb2xsb3dpbmdSZXNwb25zZSA9IHRydWU7XG4gICAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGwgPSBtZXNzYWdlLmZ1bmN0aW9uX2NhbGw7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmdW5jdGlvbkNhbGwgIT09IFwib2JqZWN0XCIpIHtcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihcbiAgICAgICAgICAgICAgXCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwgc2hvdWxkIG5vdCBiZSBkZWZpbmVkIHdoZW4gdXNpbmcgdG9vbHNcIlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChcbiAgICAgICAgICAgIGdldEN1cnJlbnRNZXNzYWdlcygpLFxuICAgICAgICAgICAgZnVuY3Rpb25DYWxsXG4gICAgICAgICAgKTtcbiAgICAgICAgICBpZiAoZnVuY3Rpb25DYWxsUmVzcG9uc2UgPT09IHZvaWQgMCkge1xuICAgICAgICAgICAgaGFzRm9sbG93aW5nUmVzcG9uc2UgPSBmYWxzZTtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgIH1cbiAgICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKSB7XG4gICAgICAgICAgY29uc3QgdG9vbENhbGxzID0gbWVzc2FnZS50b29sX2NhbGxzO1xuICAgICAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0b29sQ2FsbHMpIHx8IHRvb2xDYWxscy5zb21lKCh0b29sQ2FsbCkgPT4gdHlwZW9mIHRvb2xDYWxsICE9PSBcIm9iamVjdFwiKSkge1xuICAgICAgICAgICAgY29uc29sZS53YXJuKFxuICAgICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIHRvb2xzXCJcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29uc3QgdG9vbENhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vblRvb2xDYWxsKGdldEN1cnJlbnRNZXNzYWdlcygpLCB0b29sQ2FsbHMpO1xuICAgICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGhhc0ZvbGxvd2luZ1Jlc3BvbnNlID0gZmFsc2U7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgICB9XG4gICAgICAgICAgdXBkYXRlQ2hhdFJlcXVlc3QodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmICghaGFzRm9sbG93aW5nUmVzcG9uc2UpIHtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGxldCBmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyID0gZnVuY3Rpb24ocmVzcG9uc2UpIHtcbiAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlIG9mIHJlc3BvbnNlLm1lc3NhZ2VzKSB7XG4gICAgICAgICAgaWYgKG1lc3NhZ2UudG9vbF9jYWxscyAhPT0gdm9pZCAwKSB7XG4gICAgICAgICAgICBmb3IgKGNvbnN0IHRvb2xDYWxsIG9mIG1lc3NhZ2UudG9vbF9jYWxscykge1xuICAgICAgICAgICAgICBpZiAodHlwZW9mIHRvb2xDYWxsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRvb2xDYWxsLmZ1bmN0aW9uLmFyZ3VtZW50cyAmJiB0eXBlb2YgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgICB0b29sQ2FsbC5mdW5jdGlvbi5hcmd1bWVudHMgPSBKU09OLnN0cmluZ2lmeShcbiAgICAgICAgICAgICAgICAgICAgdG9vbENhbGwuZnVuY3Rpb24uYXJndW1lbnRzXG4gICAgICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobWVzc2FnZS5mdW5jdGlvbl9jYWxsICE9PSB2b2lkIDApIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcIm9iamVjdFwiKSB7XG4gICAgICAgICAgICAgIGlmIChtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICYmIHR5cGVvZiBtZXNzYWdlLmZ1bmN0aW9uX2NhbGwuYXJndW1lbnRzICE9PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50cyA9IEpTT04uc3RyaW5naWZ5KFxuICAgICAgICAgICAgICAgICAgbWVzc2FnZS5mdW5jdGlvbl9jYWxsLmFyZ3VtZW50c1xuICAgICAgICAgICAgICAgICk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH07XG4gICAgICB2YXIgZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzID0gZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzMjtcbiAgICAgIGNvbnN0IHN0cmVhbWVkUmVzcG9uc2VNZXNzYWdlID0gbWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZTtcbiAgICAgIGlmICgoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbCA9PT0gdm9pZCAwIHx8IHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS5mdW5jdGlvbl9jYWxsID09PSBcInN0cmluZ1wiKSAmJiAoc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscyA9PT0gdm9pZCAwIHx8IHR5cGVvZiBzdHJlYW1lZFJlc3BvbnNlTWVzc2FnZS50b29sX2NhbGxzID09PSBcInN0cmluZ1wiKSkge1xuICAgICAgICBicmVhaztcbiAgICAgIH1cbiAgICAgIGlmIChleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwpIHtcbiAgICAgICAgY29uc3QgZnVuY3Rpb25DYWxsID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UuZnVuY3Rpb25fY2FsbDtcbiAgICAgICAgaWYgKCEodHlwZW9mIGZ1bmN0aW9uQ2FsbCA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbCBzaG91bGQgbm90IGJlIGRlZmluZWQgd2hlbiB1c2luZyB0b29sc1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBmdW5jdGlvbkNhbGxSZXNwb25zZSA9IGF3YWl0IGV4cGVyaW1lbnRhbF9vbkZ1bmN0aW9uQ2FsbChnZXRDdXJyZW50TWVzc2FnZXMoKSwgZnVuY3Rpb25DYWxsKTtcbiAgICAgICAgaWYgKGZ1bmN0aW9uQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czIoZnVuY3Rpb25DYWxsUmVzcG9uc2UpO1xuICAgICAgICB1cGRhdGVDaGF0UmVxdWVzdChmdW5jdGlvbkNhbGxSZXNwb25zZSk7XG4gICAgICB9XG4gICAgICBpZiAoZXhwZXJpbWVudGFsX29uVG9vbENhbGwpIHtcbiAgICAgICAgY29uc3QgdG9vbENhbGxzID0gc3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UudG9vbF9jYWxscztcbiAgICAgICAgaWYgKCEodHlwZW9mIHRvb2xDYWxscyA9PT0gXCJvYmplY3RcIikpIHtcbiAgICAgICAgICBjb25zb2xlLndhcm4oXG4gICAgICAgICAgICBcImV4cGVyaW1lbnRhbF9vblRvb2xDYWxsIHNob3VsZCBub3QgYmUgZGVmaW5lZCB3aGVuIHVzaW5nIGZ1bmN0aW9uc1wiXG4gICAgICAgICAgKTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCB0b29sQ2FsbFJlc3BvbnNlID0gYXdhaXQgZXhwZXJpbWVudGFsX29uVG9vbENhbGwoZ2V0Q3VycmVudE1lc3NhZ2VzKCksIHRvb2xDYWxscyk7XG4gICAgICAgIGlmICh0b29sQ2FsbFJlc3BvbnNlID09PSB2b2lkIDApXG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGZpeEZ1bmN0aW9uQ2FsbEFyZ3VtZW50czIodG9vbENhbGxSZXNwb25zZSk7XG4gICAgICAgIHVwZGF0ZUNoYXRSZXF1ZXN0KHRvb2xDYWxsUmVzcG9uc2UpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vLyBzcmMvc2NoZW1hLnRzXG5pbXBvcnQgeyB2YWxpZGF0b3JTeW1ib2wgfSBmcm9tIFwiQGFpLXNkay9wcm92aWRlci11dGlsc1wiO1xuaW1wb3J0IHpvZFRvSnNvblNjaGVtYSBmcm9tIFwiem9kLXRvLWpzb24tc2NoZW1hXCI7XG52YXIgc2NoZW1hU3ltYm9sID0gU3ltYm9sLmZvcihcInZlcmNlbC5haS5zY2hlbWFcIik7XG5mdW5jdGlvbiBqc29uU2NoZW1hKGpzb25TY2hlbWEyLCB7XG4gIHZhbGlkYXRlXG59ID0ge30pIHtcbiAgcmV0dXJuIHtcbiAgICBbc2NoZW1hU3ltYm9sXTogdHJ1ZSxcbiAgICBfdHlwZTogdm9pZCAwLFxuICAgIC8vIHNob3VsZCBuZXZlciBiZSB1c2VkIGRpcmVjdGx5XG4gICAgW3ZhbGlkYXRvclN5bWJvbF06IHRydWUsXG4gICAganNvblNjaGVtYToganNvblNjaGVtYTIsXG4gICAgdmFsaWRhdGVcbiAgfTtcbn1cbmZ1bmN0aW9uIGlzU2NoZW1hKHZhbHVlKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwgJiYgc2NoZW1hU3ltYm9sIGluIHZhbHVlICYmIHZhbHVlW3NjaGVtYVN5bWJvbF0gPT09IHRydWUgJiYgXCJqc29uU2NoZW1hXCIgaW4gdmFsdWUgJiYgXCJ2YWxpZGF0ZVwiIGluIHZhbHVlO1xufVxuZnVuY3Rpb24gYXNTY2hlbWEoc2NoZW1hKSB7XG4gIHJldHVybiBpc1NjaGVtYShzY2hlbWEpID8gc2NoZW1hIDogem9kU2NoZW1hKHNjaGVtYSk7XG59XG5mdW5jdGlvbiB6b2RTY2hlbWEoem9kU2NoZW1hMikge1xuICByZXR1cm4ganNvblNjaGVtYShcbiAgICAvLyB3ZSBhc3N1bWUgdGhhdCB6b2RUb0pzb25TY2hlbWEgd2lsbCByZXR1cm4gYSB2YWxpZCBKU09OU2NoZW1hNzpcbiAgICB6b2RUb0pzb25TY2hlbWEoem9kU2NoZW1hMiksXG4gICAge1xuICAgICAgdmFsaWRhdGU6ICh2YWx1ZSkgPT4ge1xuICAgICAgICBjb25zdCByZXN1bHQgPSB6b2RTY2hlbWEyLnNhZmVQYXJzZSh2YWx1ZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQuc3VjY2VzcyA/IHsgc3VjY2VzczogdHJ1ZSwgdmFsdWU6IHJlc3VsdC5kYXRhIH0gOiB7IHN1Y2Nlc3M6IGZhbHNlLCBlcnJvcjogcmVzdWx0LmVycm9yIH07XG4gICAgICB9XG4gICAgfVxuICApO1xufVxuZXhwb3J0IHtcbiAgYXNTY2hlbWEsXG4gIGNhbGxDaGF0QXBpLFxuICBjYWxsQ29tcGxldGlvbkFwaSxcbiAgY3JlYXRlQ2h1bmtEZWNvZGVyLFxuICBmb3JtYXRTdHJlYW1QYXJ0LFxuICBnZW5lcmF0ZUlkLFxuICBnZXRUZXh0RnJvbURhdGFVcmwsXG4gIGlzRGVlcEVxdWFsRGF0YSxcbiAganNvblNjaGVtYSxcbiAgcGFyc2VQYXJ0aWFsSnNvbixcbiAgcGFyc2VTdHJlYW1QYXJ0LFxuICBwcm9jZXNzQ2hhdFN0cmVhbSxcbiAgcHJvY2Vzc0RhdGFQcm90b2NvbFJlc3BvbnNlLFxuICByZWFkRGF0YVN0cmVhbSxcbiAgem9kU2NoZW1hXG59O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXgubWpzLm1hcCJdLCJuYW1lcyI6WyJnZW5lcmF0ZUlkIiwiZ2VuZXJhdGVJZEZ1bmN0aW9uIiwiU2VjdXJlSlNPTiIsImZpeEpzb24iLCJpbnB1dCIsInN0YWNrIiwibGFzdFZhbGlkSW5kZXgiLCJsaXRlcmFsU3RhcnQiLCJwcm9jZXNzVmFsdWVTdGFydCIsImNoYXIiLCJpIiwic3dhcFN0YXRlIiwicG9wIiwicHVzaCIsInByb2Nlc3NBZnRlck9iamVjdFZhbHVlIiwicHJvY2Vzc0FmdGVyQXJyYXlWYWx1ZSIsImxlbmd0aCIsImN1cnJlbnRTdGF0ZSIsInBhcnRpYWxMaXRlcmFsIiwic3Vic3RyaW5nIiwic3RhcnRzV2l0aCIsInJlc3VsdCIsInNsaWNlIiwic3RhdGUiLCJwYXJzZVBhcnRpYWxKc29uIiwianNvblRleHQiLCJ2YWx1ZSIsInBhcnNlIiwiaWdub3JlZCIsImlnbm9yZWQyIiwidGV4dFN0cmVhbVBhcnQiLCJjb2RlIiwibmFtZSIsIkVycm9yIiwidHlwZSIsImZ1bmN0aW9uQ2FsbFN0cmVhbVBhcnQiLCJmdW5jdGlvbl9jYWxsIiwiYXJndW1lbnRzIiwiZGF0YVN0cmVhbVBhcnQiLCJBcnJheSIsImlzQXJyYXkiLCJlcnJvclN0cmVhbVBhcnQiLCJhc3Npc3RhbnRNZXNzYWdlU3RyZWFtUGFydCIsImlkIiwicm9sZSIsImNvbnRlbnQiLCJldmVyeSIsIml0ZW0iLCJ0ZXh0IiwiYXNzaXN0YW50Q29udHJvbERhdGFTdHJlYW1QYXJ0IiwidGhyZWFkSWQiLCJtZXNzYWdlSWQiLCJkYXRhTWVzc2FnZVN0cmVhbVBhcnQiLCJ0b29sQ2FsbHNTdHJlYW1QYXJ0IiwidG9vbF9jYWxscyIsInNvbWUiLCJ0YyIsImZ1bmN0aW9uIiwibWVzc2FnZUFubm90YXRpb25zU3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtUGFydCIsInRvb2xDYWxsSWQiLCJ0b29sTmFtZSIsImFyZ3MiLCJ0b29sUmVzdWx0U3RyZWFtUGFydCIsInRvb2xDYWxsU3RyZWFtaW5nU3RhcnRTdHJlYW1QYXJ0IiwidG9vbENhbGxEZWx0YVN0cmVhbVBhcnQiLCJhcmdzVGV4dERlbHRhIiwiZmluaXNoTWVzc2FnZVN0cmVhbVBhcnQiLCJmaW5pc2hSZWFzb24iLCJ1c2FnZSIsInByb21wdFRva2VucyIsIk51bWJlciIsIk5hTiIsImNvbXBsZXRpb25Ub2tlbnMiLCJmaW5pc2hTdGVwU3RyZWFtUGFydCIsImlzQ29udGludWVkIiwic3RyZWFtUGFydHMiLCJzdHJlYW1QYXJ0c0J5Q29kZSIsIlN0cmVhbVN0cmluZ1ByZWZpeGVzIiwidmFsaWRDb2RlcyIsIm1hcCIsInBhcnQiLCJwYXJzZVN0cmVhbVBhcnQiLCJsaW5lIiwiZmlyc3RTZXBhcmF0b3JJbmRleCIsImluZGV4T2YiLCJwcmVmaXgiLCJpbmNsdWRlcyIsInRleHRWYWx1ZSIsImpzb25WYWx1ZSIsIkpTT04iLCJmb3JtYXRTdHJlYW1QYXJ0Iiwic3RyZWFtUGFydCIsImZpbmQiLCJzdHJpbmdpZnkiLCJORVdMSU5FIiwiY2hhckNvZGVBdCIsImNvbmNhdENodW5rcyIsImNodW5rcyIsInRvdGFsTGVuZ3RoIiwiY29uY2F0ZW5hdGVkQ2h1bmtzIiwiVWludDhBcnJheSIsIm9mZnNldCIsImNodW5rIiwic2V0IiwicmVhZERhdGFTdHJlYW0iLCJyZWFkZXIiLCJpc0Fib3J0ZWQiLCJkZWNvZGVyIiwiVGV4dERlY29kZXIiLCJyZWFkIiwic3RyZWFtUGFydHMyIiwiZGVjb2RlIiwic3RyZWFtIiwic3BsaXQiLCJmaWx0ZXIiLCJjYW5jZWwiLCJhc3NpZ25Bbm5vdGF0aW9uc1RvTWVzc2FnZSIsIm1lc3NhZ2UiLCJhbm5vdGF0aW9ucyIsInByb2Nlc3NEYXRhUHJvdG9jb2xSZXNwb25zZSIsImFib3J0Q29udHJvbGxlclJlZiIsInVwZGF0ZSIsIm9uVG9vbENhbGwiLCJvbkZpbmlzaCIsImdlbmVyYXRlSWQyIiwiZ2V0Q3VycmVudERhdGUiLCJEYXRlIiwiX2EiLCJjcmVhdGVkQXQiLCJwcmVmaXhNYXAiLCJuZXh0UHJlZml4TWFwIiwicHJldmlvdXNNZXNzYWdlcyIsImRhdGEiLCJtZXNzYWdlQW5ub3RhdGlvbnMiLCJwYXJ0aWFsVG9vbENhbGxzIiwidG90YWxUb2tlbnMiLCJjdXJyZW50IiwidG9vbEludm9jYXRpb25zIiwicHJlZml4TWFwSW5kZXgiLCJwYXJ0aWFsVG9vbENhbGwiLCJwYXJ0aWFsQXJncyIsImludGVybmFsVXBkYXRlSWQiLCJ0b29sQ2FsbCIsInRvb2xJbnZvY2F0aW9uSW5kZXgiLCJmaW5kSW5kZXgiLCJpbnZvY2F0aW9uIiwiZnVuY3Rpb25DYWxsTWVzc2FnZSIsInRvb2xDYWxsTWVzc2FnZSIsInJlc3BvbnNlTWVzc2FnZSIsIm1lcmdlZCIsIkJvb2xlYW4iLCJtZXNzYWdlcyIsImdldE9yaWdpbmFsRmV0Y2giLCJmZXRjaCIsImNhbGxDaGF0QXBpIiwiYXBpIiwiYm9keSIsInN0cmVhbVByb3RvY29sIiwiY3JlZGVudGlhbHMiLCJoZWFkZXJzIiwiYWJvcnRDb250cm9sbGVyIiwicmVzdG9yZU1lc3NhZ2VzT25GYWlsdXJlIiwib25SZXNwb25zZSIsIm9uVXBkYXRlIiwiZmV0Y2gyIiwiX2IiLCJyZXNwb25zZSIsIm1ldGhvZCIsInNpZ25hbCIsImNhdGNoIiwiZXJyIiwib2siLCJnZXRSZWFkZXIiLCJjcmVhdGVDaHVua0RlY29kZXIiLCJyZXN1bHRNZXNzYWdlIiwiZG9uZSIsImV4aGF1c3RpdmVDaGVjayIsImdldE9yaWdpbmFsRmV0Y2gyIiwiY2FsbENvbXBsZXRpb25BcGkiLCJwcm9tcHQiLCJzZXRDb21wbGV0aW9uIiwic2V0TG9hZGluZyIsInNldEVycm9yIiwic2V0QWJvcnRDb250cm9sbGVyIiwib25FcnJvciIsIm9uRGF0YSIsIkFib3J0Q29udHJvbGxlciIsInJlcyIsImNvbXBsZXgiLCJkZWNvZGVkIiwiZ2V0VGV4dEZyb21EYXRhVXJsIiwiZGF0YVVybCIsImhlYWRlciIsImJhc2U2NENvbnRlbnQiLCJtaW1lVHlwZSIsIndpbmRvdyIsImF0b2IiLCJlcnJvciIsImlzRGVlcEVxdWFsRGF0YSIsIm9iajEiLCJvYmoyIiwiY29uc3RydWN0b3IiLCJnZXRUaW1lIiwia2V5czEiLCJPYmplY3QiLCJrZXlzIiwia2V5czIiLCJrZXkiLCJwcm9jZXNzQ2hhdFN0cmVhbSIsImdldFN0cmVhbWVkUmVzcG9uc2UiLCJleHBlcmltZW50YWxfb25GdW5jdGlvbkNhbGwiLCJleHBlcmltZW50YWxfb25Ub29sQ2FsbCIsInVwZGF0ZUNoYXRSZXF1ZXN0IiwiZ2V0Q3VycmVudE1lc3NhZ2VzIiwibWVzc2FnZXNBbmREYXRhT3JKdXN0TWVzc2FnZSIsImhhc0ZvbGxvd2luZ1Jlc3BvbnNlIiwiZnVuY3Rpb25DYWxsIiwiY29uc29sZSIsIndhcm4iLCJmdW5jdGlvbkNhbGxSZXNwb25zZSIsInRvb2xDYWxscyIsInRvb2xDYWxsUmVzcG9uc2UiLCJmaXhGdW5jdGlvbkNhbGxBcmd1bWVudHMyIiwiZml4RnVuY3Rpb25DYWxsQXJndW1lbnRzIiwic3RyZWFtZWRSZXNwb25zZU1lc3NhZ2UiLCJ2YWxpZGF0b3JTeW1ib2wiLCJ6b2RUb0pzb25TY2hlbWEiLCJzY2hlbWFTeW1ib2wiLCJTeW1ib2wiLCJmb3IiLCJqc29uU2NoZW1hIiwianNvblNjaGVtYTIiLCJ2YWxpZGF0ZSIsIl90eXBlIiwiaXNTY2hlbWEiLCJhc1NjaGVtYSIsInNjaGVtYSIsInpvZFNjaGVtYSIsInpvZFNjaGVtYTIiLCJzYWZlUGFyc2UiLCJzdWNjZXNzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@ai-sdk/ui-utils/dist/index.mjs\n");

/***/ })

};
;